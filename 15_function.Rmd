---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Функции

### Введение

Написание хороших функций --- это путешествие длинною в жизнь, и да начнётся оно сейчас.

#### Используемые ресурсы

Здесь работаем с базовым функционалом, дополнительные пакеты, не потребуются

### Когда следует писать функции

Когда есть необходимость повторять фрагмент кода более чем два раза.

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Код выше масштабирует значения в каждом столбцу таким образом, чтобы они изменялись в пределах от 0 до 1. Но если присмотреться к выводу `df$b` можно увидеть значения больше единицы. Почему так произошло? Потому что в коде ошибка --- `(max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)` в минимуме вместо `df$b`, стоит `df$a`. 

Не так-то просто обнаружить ошибку в коде, среди однообразных выводов. Внесение повторяющегося кода в функцию --- неплохая идея, поскольку это избавит от ошибок подобного кода.

Чтобы написать фукнцию, нужно сначала проанализировать код. Сколько в нём имеется входных переменных.

В этом коде:

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

Есть лишь одна входная переменная `df$a`. Чтобы облегчить понимание кода вынесем повторяющийся числовой вектор во временную переменную с простым именем

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

Теперь можно заметить, что и тут код дублируется --- диапазон данных вычислется три раза. Хотя это можно сделать только один раз. В этом нам поможет базовая функция `range()`. 

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

На сколько проще и читабельнее стал код. Но и это ещё не всё. Теперь на авансцену выходит --- создание функции

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Итак, как видно из кода выше, создание новой функции включает три ключевых момента

1. Необходимо выбрать *имя* функции. Здесь мы используем имя `rescale01`, поскольку функция масштабирует вектор таким образом, чтобы его значения изменялись в пределах от 0 до 1.

2. Необходимо перечислить входные значения, или *аргументы* функции, после ключевого слова `function`, заключив их в круглые скобки. В данном случае имеется всего один аргумент --- это `(x)`, но если бы их было больше, вызов функции выглядел примерно так `function(x, y, z)`.

3. Разработанный код помещается в тело *функции* --- заключенный в фигурные скобки блок кода, следующий непосредственно за названием функции со списком аргументов.

Если взглянуть на ситуацию в целом, то мы сначала создали простой код, а затем превратили её в функцию. Так следует поступать и в остальных ситуациях. 

На этой стадии целесообразно проверить как работает функция с разными значениями

```{r}
rescale01(c(1, 2, 3, NA, 0.2))
```

Со временем --- очень захочется превратить эти неформальные интерактивные проверки в формальные автоматизированные тесты. Этот процесс называют блочным тестированием. 

Об этом можно узнать больше по адресу <http://r-pkgs.had.co.nz/tests.html>.

Теперь, когда у нас есть функция, мы можем заменить исходный пример.

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

И для сравнения, рядом первоначальный код

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Тут есть ещё над чем работать, например очень хочется избавиться от дублирования и сделать это всё "одной строкой", но об этом мы узнаем чуть позже. 

Большим преимуществом функций, является то, что при изменении требований коду изменение нужно вносить в одном месте. Например, можно обнаружить, что некоторые значения приводят к аварийной работе функции.

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Поскольку мы внесли код в функцию, правку нужно врести в одном месте

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

Это важная составляющая принципа --- НЕ ПОВТОРЯЙСЯ ("Do not repeat yourself", DRY). Чем больше повторений, тем сложнее держать в голове все места, которые будут нуждаться в обновлении.


#### Упражнение 19.2.1.1
<div class="question">
Why is `TRUE` not a parameter to `rescale01()`? What would happen if `x` contained a single missing value, and `na.rm` was `FALSE`?
</div>


Напомню функцию `rescale01()`

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

`TRUE` не является параметром функции, поскольку он не указан в круглых скобках после слова тэга `function`

Если `x` содержит единственное пропущенное значение и `na.rm = FALSE`, то эта функция по-прежнему возвращает не пропущенное значение.

```{r}
rescale01_alt <- function(x, na.rm = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt(c(NA, 1:5), na.rm = FALSE)

rescale01_alt(c(NA, 1:5), na.rm = TRUE)
```

Опция `finite = TRUE` у параметра `range()` удалит все неконечные элементы, а NA - неконечный элемент.

Однако, если и `finite = FALSE` и `na.rm = FALSE`, то эта функция будет возвращать вектор значений `NA`. 
Напомним, арифметические операции со значениями NA возвращают NA.

```{r}
rescale01_alt2 <- function(x, na.rm = FALSE, finite = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = finite)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt2(c(NA, 1:5), na.rm = FALSE, finite = FALSE)
```

#### Упражнение 19.2.1.2
<div class="question">
In the second variant of `rescale01()`, infinite values are left unchanged. Rewrite `rescale01()` so that `-Inf` is mapped to 0, and `Inf` is mapped to 1.
</div>

Для решения хочется использовать конструкцию если `y == -Inf`, то верни 0, если `y == Inf` то верни 1.
Но так как с работой с условиями я ещё не знаком, то внесу эти в явном виде.

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  y <- (x - rng[1]) / (rng[2] - rng[1])
  y[y == -Inf] <- 0
  y[y == Inf] <- 1
  y
}

rescale01(c(0:3, -Inf, Inf, NA))
```

#### Упражнение 19.2.1.3
<div class="question">
Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?
</div>

```{r}
x <- c(0:10)

mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```


1. Эта функция подсчитывает делит количество пропущенных значений на общее количество значений. 
Другими словами --- функция возвращает долю пропущенных значений.

```{r}
t <- c(NA, NA, NA, NA, 1:6)
i <- c(NA, NA, NA, 1:7)

is.na(x)
mean(is.na(x))
```

Я бы назвал эту функцию missing_value_rate, или ещё лучше --- `NA_rate`

```{r}
NA_rate <- function(x) {
  mean(is.na(x))
}

NA_rate(t)
NA_rate(i)
```

2. Эта функция нормирует выборку относительно единицы или другими словами возвращает вес каждого значения в векторе, при этом пропущенные значения не берутся в расчёт.

```{r}
x <- c(2, 10000)
x
x / sum(x, na.rm = TRUE)
```

Я бы назвал эту функцию `weight_to_one` поскольку она показывает вес каждого значения относительно единицы

```{r}
weight_to_one <- function(x) {
  x / sum(x, na.rm = TRUE)
}

weight_to_one(x)
```

Будет выглядеть хорошо, ну по крайне мере однообразно с базовыми функциями, если вынести `na.rm` (по аналогии с `mean` и `median`) со значением по умолчанию `FALSE` как параметр функции. То есть указать его в круглых скобочках после слова `function()`

```{r}
weight_to_one <- function(x, na.rm = FALSE) {
  x / sum(x)
}

weight_to_one(x)
```

3. Стандартное отклонение делённое на среднеарифметическое --- это [коэффициент вариации](http://statistica.ru/glossary/general/koeffitsient-variatsii/). 
Поэтому я назову эту функцию `coefficient_of_variation`.

```{r}
gti <- c(1:1000)

coefficient_of_variation <- function(x) {
  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
}

coefficient_of_variation(gti)
```

Будет ещё лучше, если я, как в предыдущем примере, вынесу `na.rm = FALSE` в параметр функции. Тогда можно будет управлять выводом функции, не изменяя её код.

```{r}
coefficient_of_variation <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}
```

#### Упражнение 19.2.1.4
<div class="question">
Follow <http://nicercode.github.io/intro/writing-functions.html> to write your own functions to compute the variance and skew of a numeric vector.
</div>

Первая функция, которую многие люди, похоже, должны написать, --- это вычислить стандартную ошибку среднего для некоторой переменной, потому что, как ни странно, эта функция не поставляется с базовым пакетом R. Она вычисляется следующим образом $\sqrt{\mathrm{var}(x)/n}$

```{r}
x <- c(1:169)

var(x)
```

`var` --- подсчитывает дисперсию (`variance`). Это то что нам нужно написать самим. 

Но для начала мы напишем функцию для определения стандартной ошибки:

```{r}
standart.error <- function(x) {
  sqrt(var(x)/length(x))
}
```

Но вот таким образом, на самом деле она выглядит "некрасиво" и слабочитаемо. Понятнее будет, если каждую опцию внести в отдельную внутреннюю переменную

```{r}
standart.error <- function(x) {
  v <- var(x)
  n <- length(x)
  sqrt(v/n)
}
```

Правда же так гораздо приятнее? Теперь возьмёмся за функцию дисперсии

По определению, дисперсия --- это среднеквадратическое отклонение от среднего или 
$$
D = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \bar{x}) ^2 \text{,}
$$
Отлично. Теперь переведём это в функцию. $n$ в формуле это длина вектора или `length(x)`. $\bar{x}$ --- это математическое ожидание или среднее `mean(x)`. Тогда вся формула будет иметь вид

```{r}
variance <- function(x, na.rm = FALSE) {
    n <- length(x)
    m <- mean(x, na.rm = na.rm)
    sum((x - m)^2) * (1/(n - 1))
}
```

И теперь проверим нашу функцию

```{r}
x <- c(1:169)

var(x)
variance(x)
```

Отлично!

Возьмёмся за коэффициент асимметрии числового вектора. 
Неформально говоря, коэффициент асимметрии положителен, если правый хвост распределения длиннее левого, и отрицателен в противном случае.
Если распределение симметрично относительно математического ожидания, то его коэффициент асимметрии равен нулю.

![alt text](img/skew.png)

Этот коэффициент считается следующим образом

$$
\gamma_1 = \frac{\frac{1}{n - 2}\left(\sum_{i=1}^{n}(x_{i} - \bar x)^3\right)}{D^{3 / 2}}
$$

Или переводя в функцию, получим
```{r}
skewness <- function(x, na.rm = FALSE) {
  v <- var(x, na.rm = na.rm)
  n <- length(x)
  m <- mean(x, na.rm = na.rm)
  (sum(x - m)^3 / (n - 2)) / v^(3 / 2)
}
```

#### Упражнение 19.2.1.5
<div class="question">
Write `both_na()`, a function that takes two vectors of the same length and returns the number of positions that have an NA in both vectors.
</div>

Сначала разберёмся, как нам считать пропуски.
Чтобы определить пропущенное значение воспользуемся функцией `is.na()`

```{r}
t <- c(1, 2, NA)
y <- c(NA, NA, NA)
is.na(t)
```

А количество значений `TRUE` в векторе, нам поможет посчитать функция `sum()`

```{r}
sum(is.na(t))
sum(is.na(y))
```

Итак, теперь нам надо посмотреть в скольких местах в обоих векторах встречаются пропуски.
В нашем случае это один раз

Такое выражение не верно, оно даёт сумму всех пропущенных значений в обоих векторах
```{r}
sum(is.na(t)) + sum(is.na(y))

```


Такое выражение тоже не подходит, поскольку это логическое `ИЛИ` и оно сравнивает оба вектора и считает за единицу, случай если хотя бы в одном векторе был пропуск.
```{r}
sum(is.na(t) | is.na(y))
```

Тогда наше решение --- это логический оператор `И`. Функция ниже возвращает сумму случаев когда оба значения вектора есть пропущенные значения
```{r}
sum(is.na(t) & is.na(y))
```

Теперь определим это в функцию

```{r}
both_na <- function(x, y) {
  sum(is.na(x) & is.na(y))
}
both_na(t, y)
```

Вуаля

#### Упражнение 19.2.1.6
<div class="question">
What do the following functions do? Why are they useful even though they are so short?

```{r}
is_directory <- function(x) file.info(x)$isdir
is_readable <- function(x) file.access(x, 4) == 0
```
</div>

Функция `is_directory()` проверяет, является ли путь в `x` каталогом. 
Функция `is_readable()` проверяет, является ли путь в `x` доступный для чтения. 
Что означает, что файл существует и у пользователя есть разрешение на его открытие. 
Эти функции полезны даже при том, что они короткие, потому что их имена значительно упрощают работу кода.


#### Упражнение 19.2.1.6
<div class="question">
Read the complete lyrics to “Little Bunny Foo Foo”. There’s a lot of duplication in this song. Extend the initial piping example to recreate the complete song, and use functions to reduce the duplication.
</div>

Пожалуй я скипну это упражнение и вернусь к нему однажды


### Функции создаются для компьютеров и людей

Делай читабельные функции с внятным названием

Будь последовательным --- используй один стиль именования функций.

Семейство аналогичных функций называй согласованно.

Избегай перекрывания имен функций и переменных.

Комментируй свой код отвечая на вопрос `зачем?`. Избегай комментов отвечающих на вопрос `что?` и `как?`

Делай понятный код.

Подумай о добавлении промежуточных переменных.


