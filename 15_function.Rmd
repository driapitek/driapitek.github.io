---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Функции

### Введение

Написание хороших функций --- это путешествие длинною в жизнь, и да начнётся оно сейчас.

#### Используемые ресурсы

Здесь работаем с базовым функционалом, дополнительные пакеты, не потребуются

```{r}
library(lubridate)
library(magrittr)
library(stringr)
library(ggplot2)
```


### Когда следует писать функции

Когда есть необходимость повторять фрагмент кода более чем два раза.

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Код выше масштабирует значения в каждом столбцу таким образом, чтобы они изменялись в пределах от 0 до 1. Но если присмотреться к выводу `df$b` можно увидеть значения больше единицы. Почему так произошло? Потому что в коде ошибка --- `(max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)` в минимуме вместо `df$b`, стоит `df$a`. 

Не так-то просто обнаружить ошибку в коде, среди однообразных выводов. Внесение повторяющегося кода в функцию --- неплохая идея, поскольку это избавит от ошибок подобного кода.

Чтобы написать фукнцию, нужно сначала проанализировать код. Сколько в нём имеется входных переменных.

В этом коде:

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

Есть лишь одна входная переменная `df$a`. Чтобы облегчить понимание кода вынесем повторяющийся числовой вектор во временную переменную с простым именем

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

Теперь можно заметить, что и тут код дублируется --- диапазон данных вычислется три раза. Хотя это можно сделать только один раз. В этом нам поможет базовая функция `range()`. 

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

На сколько проще и читабельнее стал код. Но и это ещё не всё. Теперь на авансцену выходит --- создание функции

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Итак, как видно из кода выше, создание новой функции включает три ключевых момента

1. Необходимо выбрать *имя* функции. Здесь мы используем имя `rescale01`, поскольку функция масштабирует вектор таким образом, чтобы его значения изменялись в пределах от 0 до 1.

2. Необходимо перечислить входные значения, или *аргументы* функции, после ключевого слова `function`, заключив их в круглые скобки. В данном случае имеется всего один аргумент --- это `(x)`, но если бы их было больше, вызов функции выглядел примерно так `function(x, y, z)`.

3. Разработанный код помещается в тело *функции* --- заключенный в фигурные скобки блок кода, следующий непосредственно за названием функции со списком аргументов.

Если взглянуть на ситуацию в целом, то мы сначала создали простой код, а затем превратили её в функцию. Так следует поступать и в остальных ситуациях. 

На этой стадии целесообразно проверить как работает функция с разными значениями

```{r}
rescale01(c(1, 2, 3, NA, 0.2))
```

Со временем --- очень захочется превратить эти неформальные интерактивные проверки в формальные автоматизированные тесты. Этот процесс называют блочным тестированием. 

Об этом можно узнать больше по адресу <http://r-pkgs.had.co.nz/tests.html>.

Теперь, когда у нас есть функция, мы можем заменить исходный пример.

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

И для сравнения, рядом первоначальный код

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Тут есть ещё над чем работать, например очень хочется избавиться от дублирования и сделать это всё "одной строкой", но об этом мы узнаем чуть позже. 

Большим преимуществом функций, является то, что при изменении требований коду изменение нужно вносить в одном месте. Например, можно обнаружить, что некоторые значения приводят к аварийной работе функции.

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Поскольку мы внесли код в функцию, правку нужно врести в одном месте

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

Это важная составляющая принципа --- НЕ ПОВТОРЯЙСЯ ("Do not repeat yourself", DRY). Чем больше повторений, тем сложнее держать в голове все места, которые будут нуждаться в обновлении.


#### Упражнение 19.2.1.1
<div class="question">
Why is `TRUE` not a parameter to `rescale01()`? What would happen if `x` contained a single missing value, and `na.rm` was `FALSE`?
</div>


Напомню функцию `rescale01()`

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

`TRUE` не является параметром функции, поскольку он не указан в круглых скобках после слова тэга `function`

Если `x` содержит единственное пропущенное значение и `na.rm = FALSE`, то эта функция по-прежнему возвращает не пропущенное значение.

```{r}
rescale01_alt <- function(x, na.rm = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt(c(NA, 1:5), na.rm = FALSE)

rescale01_alt(c(NA, 1:5), na.rm = TRUE)
```

Опция `finite = TRUE` у параметра `range()` удалит все неконечные элементы, а NA - неконечный элемент.

Однако, если и `finite = FALSE` и `na.rm = FALSE`, то эта функция будет возвращать вектор значений `NA`. 
Напомним, арифметические операции со значениями NA возвращают NA.

```{r}
rescale01_alt2 <- function(x, na.rm = FALSE, finite = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = finite)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt2(c(NA, 1:5), na.rm = FALSE, finite = FALSE)
```

#### Упражнение 19.2.1.2
<div class="question">
In the second variant of `rescale01()`, infinite values are left unchanged. Rewrite `rescale01()` so that `-Inf` is mapped to 0, and `Inf` is mapped to 1.
</div>

Для решения хочется использовать конструкцию если `y == -Inf`, то верни 0, если `y == Inf` то верни 1.
Но так как с работой с условиями я ещё не знаком, то внесу эти в явном виде.

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  y <- (x - rng[1]) / (rng[2] - rng[1])
  y[y == -Inf] <- 0
  y[y == Inf] <- 1
  y
}

rescale01(c(0:3, -Inf, Inf, NA))
```

#### Упражнение 19.2.1.3
<div class="question">
Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?
</div>

```{r}
x <- c(0:10)

mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```


1. Эта функция подсчитывает делит количество пропущенных значений на общее количество значений. 
Другими словами --- функция возвращает долю пропущенных значений.

```{r}
t <- c(NA, NA, NA, NA, 1:6)
i <- c(NA, NA, NA, 1:7)

is.na(x)
mean(is.na(x))
```

Я бы назвал эту функцию missing_value_rate, или ещё лучше --- `NA_rate`

```{r}
NA_rate <- function(x) {
  mean(is.na(x))
}

NA_rate(t)
NA_rate(i)
```

2. Эта функция нормирует выборку относительно единицы или другими словами возвращает вес каждого значения в векторе, при этом пропущенные значения не берутся в расчёт.

```{r}
x <- c(2, 10000)
x
x / sum(x, na.rm = TRUE)
```

Я бы назвал эту функцию `weight_to_one` поскольку она показывает вес каждого значения относительно единицы

```{r}
weight_to_one <- function(x) {
  x / sum(x, na.rm = TRUE)
}

weight_to_one(x)
```

Будет выглядеть хорошо, ну по крайне мере однообразно с базовыми функциями, если вынести `na.rm` (по аналогии с `mean` и `median`) со значением по умолчанию `FALSE` как параметр функции. То есть указать его в круглых скобочках после слова `function()`

```{r}
weight_to_one <- function(x, na.rm = FALSE) {
  x / sum(x)
}

weight_to_one(x)
```

3. Стандартное отклонение делённое на среднеарифметическое --- это [коэффициент вариации](http://statistica.ru/glossary/general/koeffitsient-variatsii/). 
Поэтому я назову эту функцию `coefficient_of_variation`.

```{r}
gti <- c(1:1000)

coefficient_of_variation <- function(x) {
  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
}

coefficient_of_variation(gti)
```

Будет ещё лучше, если я, как в предыдущем примере, вынесу `na.rm = FALSE` в параметр функции. Тогда можно будет управлять выводом функции, не изменяя её код.

```{r}
coefficient_of_variation <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}
```

#### Упражнение 19.2.1.4
<div class="question">
Follow <http://nicercode.github.io/intro/writing-functions.html> to write your own functions to compute the variance and skew of a numeric vector.
</div>

Первая функция, которую многие люди, похоже, должны написать, --- это вычислить стандартную ошибку среднего для некоторой переменной, потому что, как ни странно, эта функция не поставляется с базовым пакетом R. Она вычисляется следующим образом $\sqrt{\mathrm{var}(x)/n}$

```{r}
x <- c(1:169)

var(x)
```

`var` --- подсчитывает дисперсию (`variance`). Это то что нам нужно написать самим. 

Но для начала мы напишем функцию для определения стандартной ошибки:

```{r}
standart.error <- function(x) {
  sqrt(var(x)/length(x))
}
```

Но вот таким образом, на самом деле она выглядит "некрасиво" и слабочитаемо. Понятнее будет, если каждую опцию внести в отдельную внутреннюю переменную

```{r}
standart.error <- function(x) {
  v <- var(x)
  n <- length(x)
  sqrt(v/n)
}
```

Правда же так гораздо приятнее? Теперь возьмёмся за функцию дисперсии

По определению, дисперсия --- это среднеквадратическое отклонение от среднего или 
$$
D = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \bar{x}) ^2 \text{,}
$$
Отлично. Теперь переведём это в функцию. $n$ в формуле это длина вектора или `length(x)`. $\bar{x}$ --- это математическое ожидание или среднее `mean(x)`. Тогда вся формула будет иметь вид

```{r}
variance <- function(x, na.rm = FALSE) {
    n <- length(x)
    m <- mean(x, na.rm = na.rm)
    sum((x - m)^2) * (1/(n - 1))
}
```

И теперь проверим нашу функцию

```{r}
x <- c(1:169)

var(x)
variance(x)
```

Отлично!

Возьмёмся за коэффициент асимметрии числового вектора. 
Неформально говоря, коэффициент асимметрии положителен, если правый хвост распределения длиннее левого, и отрицателен в противном случае.
Если распределение симметрично относительно математического ожидания, то его коэффициент асимметрии равен нулю.

![alt text](img/skew.png)

Этот коэффициент считается следующим образом

$$
\gamma_1 = \frac{\frac{1}{n - 2}\left(\sum_{i=1}^{n}(x_{i} - \bar x)^3\right)}{D^{3 / 2}}
$$

Или переводя в функцию, получим
```{r}
skewness <- function(x, na.rm = FALSE) {
  v <- var(x, na.rm = na.rm)
  n <- length(x)
  m <- mean(x, na.rm = na.rm)
  (sum(x - m)^3 / (n - 2)) / v^(3 / 2)
}
```

#### Упражнение 19.2.1.5
<div class="question">
Write `both_na()`, a function that takes two vectors of the same length and returns the number of positions that have an NA in both vectors.
</div>

Сначала разберёмся, как нам считать пропуски.
Чтобы определить пропущенное значение воспользуемся функцией `is.na()`

```{r}
t <- c(1, 2, NA)
y <- c(NA, NA, NA)
is.na(t)
```

А количество значений `TRUE` в векторе, нам поможет посчитать функция `sum()`

```{r}
sum(is.na(t))
sum(is.na(y))
```

Итак, теперь нам надо посмотреть в скольких местах в обоих векторах встречаются пропуски.
В нашем случае это один раз

Такое выражение не верно, оно даёт сумму всех пропущенных значений в обоих векторах
```{r}
sum(is.na(t)) + sum(is.na(y))

```


Такое выражение тоже не подходит, поскольку это логическое `ИЛИ` и оно сравнивает оба вектора и считает за единицу, случай если хотя бы в одном векторе был пропуск.
```{r}
sum(is.na(t) | is.na(y))
```

Тогда наше решение --- это логический оператор `И`. Функция ниже возвращает сумму случаев когда оба значения вектора есть пропущенные значения
```{r}
sum(is.na(t) & is.na(y))
```

Теперь определим это в функцию

```{r}
both_na <- function(x, y) {
  sum(is.na(x) & is.na(y))
}
both_na(t, y)
```

Вуаля

#### Упражнение 19.2.1.6
<div class="question">
What do the following functions do? Why are they useful even though they are so short?

```{r}
is_directory <- function(x) file.info(x)$isdir
is_readable <- function(x) file.access(x, 4) == 0
```
</div>

Функция `is_directory()` проверяет, является ли путь в `x` каталогом. 
Функция `is_readable()` проверяет, является ли путь в `x` доступный для чтения. 
Что означает, что файл существует и у пользователя есть разрешение на его открытие. 
Эти функции полезны даже при том, что они короткие, потому что их имена значительно упрощают работу кода.


#### Упражнение 19.2.1.6
<div class="question">
Read the complete lyrics to “Little Bunny Foo Foo”. There’s a lot of duplication in this song. Extend the initial piping example to recreate the complete song, and use functions to reduce the duplication.
</div>

Пожалуй я скипну это упражнение и вернусь к нему однажды


### Функции создаются для компьютеров и людей

Делай читабельные функции с внятным названием

Будь последовательным --- используй один стиль именования функций.

Семейство аналогичных функций называй согласованно.

Избегай перекрывания имен функций и переменных.

Комментируй свой код отвечая на вопрос `зачем?`. Избегай комментов отвечающих на вопрос `что?` и `как?`

Делай понятный код.

Подумай о добавлении промежуточных переменных.


#### Упражнение 19.3.1.1
<div class="question">
Read the source code for each of the following three functions, puzzle out what they do, and then brainstorm better names.
</div>

1. Пойдём по порядку. 

```{r}
f1 <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}
```


В `f1` используются следующие функции:
  
  `substr()` извлекает подстроки в символьном векторе с заданными параметрами начала извлечения и конца
  
```{r}
substr(c("abc77777", "abd77777", "qwe77777"), 1, 5)
```
  
  `nchar()` считает количество символов в каждом члене символьного вектора
  
```{r}
x <- c("abc77777", "abd77777", "qwe77777")
y <- "ab"

# Всё вместе это работает так
substr(x, 1, nchar(y)) == y
```

```{r}
f1(c("resdfj", "rejsdj-", "eradsf,", "resdfj"), "re")
```
  
  Теперь как работает эта функция. `substr()` принимает первым значением параметр `string` (это на самом деле немного путает вначале, потому что `string` не название функции, а название параметра).
  
  Дальше указана единица --- т.е. из вектора будут извлекаться значения с первой позиции. 
  
  Далее следует функция `nchar(prefix)` --- которая считает количество символов во втором заданном в функцию векторе. Полученное число будет третьим параметром для функции `substr()`, т.е. он задаёт конечное значение извлекаемого вектора. 
  
  Таким образом выражение `substr(string, 1, nchar(prefix))` всегда будет брать из заданных символьных векторов количество символов с первого по длинну префикса.
  
  И наконец операция `== prefix` сравнивает извлечённые символы с заданным префиксом. И возвращает булево значение `TRUE` если вектор содержит префикс и `FALSE`
  
  Исходя из выше описанного я бы назвал функцию `f1` `имеет_префикс()` или по-английски `has_prefix()`
  
```{r}
has_prefix <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}
```

2. Функция `f2` отбрасывает последний элемент вектора `x`

```{r}
f2 <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}
```

Но тут добавлено условие --- если длинна заданного вектора равна или меньше единице, то возвращается `NULL`. И это логично, потому что отбросить последнее значение от единичного вектора всё равно что взять ноль.
```{r}
f2(1)
```

Я бы назваль эту функцию `пни последнего` или `kick_last`

```{r}
kick_last <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}
```

3. В функции `f3` 

```{r}
f3 <- function(x, y) {
  rep(y, length.out = length(x))
}
```
 
  используется функция `rep()` --- она копирует  значения в `x` с заданным параметром `length.out` который указывает желаемую длинy выходного вектора, т.е. длине вектора `x`. Другие входные данные будут приведены к двойному вектору, и первый элемент будет взят. Игнорируется, если NA или недействительным.


```{r}
x <- c("ab", "c77", "c777", "abd77777", "qwe77777")
length(x)
y <- c(1:2)
f3(x, y)

rep(1:4, length.out = 9)
```

Получается, функция `f3` берёт параметр `y` и повторяет его столько раз, какая длина у `x`.

```{r}
f3(c(1:4), "cv")
```

Эту функцию можно назвать `расширение()` или `recycle()`

#### Упражнение 19.3.1.2
<div class="question">
Take a function that you’ve written recently and spend 5 minutes brainstorming a better name for it and its arguments.
</div>

Вернусь сюда когда начну писать свои функции

#### Упражнение 19.3.1.3
<div class="question">
Compare and contrast `rnorm()` and `MASS::mvrnorm()`. How could you make them more consistent?
</div>

```{r}
#?rnorm
```


`rnorm()` производит выборки из одномерного нормального распределения, а `MASS::mvrnorm` - из многомерного нормального распределения. 
Основными аргументами в `rnorm()` являются

* `n` --- кол-во наблюдений

* `mean` --- мат.ожидание

* `sd` --- стандартное отклонение.

Основными аргументами `MASS::mvrnorm` являются 

* `n`  --- необходимое кол-во образцов

* `mu` --- вектор, дающий средние значения переменных.

* `Sigma` --- положительно определенная симметричная матрица, определяющая ковариационную матрицу переменных.

Чтобы быть последовательными, они должны иметь одинаковые имена. Однако это сложно. В общем случае лучше соответствовать более широко используемым функциям, например, `rmvnorm()` должен следовать соглашениям `rnorm()`. Однако, хотя среднее значение является правильным в многомерном случае, `sd` не имеет смысла в многомерном случае. Однако обе функции внутренне согласованы. Не было бы хорошей практикой иметь в качестве аргументов аргументы `mu` и `sd`, а в качестве аргументов - Sigma.


#### Упражнение 19.3.1.4
<div class="question">
Make a case for why `norm_r()`, `norm_d()` etc would be better than `rnorm()`, `dnorm()`. Make a case for the opposite.
</div>


Если функции названы `norm_r()` и `norm_d()`, группы соглашений об именах функционируют по их распределению.

Если они названы `rnorm()` и `dnorm()`, соглашение об именовании группирует функции по действию, которое они выполняют.

* Функции r * всегда выбирают из распределений: например, `rnorm()`, `rbinom()`, `runif()` и `rexp()`.

* Функции d * вычисляют плотность вероятности или массу распределения: например, `dnorm()`, `dbinom()`, `dunif()` и `dexp()`.

В дистрибутивах `R` используется это последнее соглашение об именах.

### Условное выполнение

Инструкция `if` позволяет организовать условное выполнение кода. Она имеет следующий синтаксис

```{r}
#if (условие) {
  # код выполняемый если условие TRUE
#} else {
  # код выполняемый если условие FALSE
#}
```

Чтобы получить справку нужно заключить инструкцию в апострофы `?`if``

Рассмотрим пример простой функции, которая возвращает логический вектор, указывающий на то, именован или не именован каждый из элементов вектора

```{r}
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
```

Стандартное для функций правило --- функция возвращает последнее вычисленное значение. В случае функции выше, это может быть результат вычисления любой из двух ветвей оператора `if`

#### Условия

Результатом вычисления условия должно быть логическое значение --- либо `TRUE` либо `FALSE`.

Если это вектор --- будет предупреждение.

Если `NA` --- будет ошибка.

Несколько условий можно объединять при помощи логических векторов `||` (ИЛИ) `&&` (И). 
Они используют короткий цикл вычислений --- как только для оператора обнаруживается, что первое условие равно `TRUE`, остальные условия не обрабатываются.
Аналогично для `&&` --- Если первое условие `FALSE`, остальные не обрабатываются.

Важно --- никогда не использовать операторы `|` `&` в инструкции `if` потому что эти операции векторизованы и применяются к нескольким значениям. Если имеется логический вектор, можно свернуть его в одиночное значение с помощью функции `any()` или `all()`.

Будь внимателен при проверке на равенство. Оператор `==` векторизован, это означает что может быть получено более чем одно выходное значение. В током случае можно проверить, что длина переменной уже равна 1, свернуть вектор с помощью функции `any()` или `all()` или использовать не векторизованную функцию `identical()`.

Функция `identical()` строгая --- она всегда возвращает одиночное значение `TRUE`, либо одиночное значение `FALSE` и не выполняет прпиведение типов. Это означает, что нужно быть аккуратным при сравнении целых чисел с числами двойной точности.

```{r}
identical(0L, 0)
```

Так же будь осторожен при проверке вещественных чисел.

```{r}
x <- sqrt(2) ^ 2
x
x == 2
x - 2
```

вместо этого используй для сравнения функцию `dplyr::near()`

И ещё --- не сравнивай `x == NA`, оно не принесет никакой пользы.

#### Множественные условия

Несколько инструкций можно объединить в цепочки

```{r}
#if (this) {
  # сделай это
#} else if (that) {
  # сделай ещё что-то
#} else {
  # 
#}
```

Если цепочка получается длинной, подумай как её переписать. Одна полезная методика предпологает использование функции `switch()`. Эта функция позволяет выбирать ветвь кода на основании заданной позиции или имени.

```{r}
foo <- function(x, y, op) {
 switch(op,
  plus = x + y,
  minus = x - y,
  times = x * y,
  divide = x / y,
  stop("Unknown op!")
)
}
```

Работает она таким образом --- в аргументах функции указываем тег триггер. В теле `switch`-а указываем условия наступления триггера.

вызывается триггер вот таким образом:

```{r}
foo(2, 5, "plus")
foo(2, 5, "divide")
foo(2, 5, "plва")
```

Ещё есть функция `cut()`. Разберём её работу в упражнениях

#### Стиль кода

За инструкцией `if` должны следовать курвы `{}`. Содержимое внутри скобочек должно отделяться двумя пробелами.
Так легче отслеживать иерархию в коде, скользя взглядом вдоль левого края.

Открывающаяся скобка не должна стоять на отдельной строке.

За ней всегда должен следовать переход на новую строка.

Закрывающаяюся курва всегда должна распологаться на отдельной строке, если за ней не следует блок `else`.

Код в фигурных скобках следует всегда отделять пробелами.

```{r}
# Good
if (y < 0 && debug) {
  message("Y is negative")
}

if (y == 0) {
  log(x)
} else {
  y ^ x
}
```

В случае коротких конструкций, умещающихся в одной строке, фигурные скобки можно опустить.

```{r}
y <- 10
x <- if (y < 20) "Too low" else "Too high"
```

Но так лучше не делать, лучше повысить чтение кода курвами

```{r}
if (y < 20) {
  x <- "Too low" 
} else {
  x <- "Too high"
}
```

#### Упражнение 19.4.4.1
<div class="question">
What’s the difference between `if` and `ifelse()`? 
Carefully read the help and construct three examples that illustrate the key differences.
</div>

У `ifelse()` следующие аргументы `ifelse(test, yes, no)`. 

`test` --- логическая проверка. Объект.

`yes`	--- return values for true elements of `test`.

`no`	--- return values for false elements of `test`.

```{r}
x <- c(6:-4)

sqrt(ifelse(x >= 0, x, NA))
if(x >= 0) sqrt(x)
```

Ключевое слово `if` проверяет одно условие, тогда как `ifelse()` проверяет каждый элемент.

```{r}
y <- 10
if (y < 20) {
  "Too low" 
}

if (y < 0) {
  "Too low" 
}
```

В то время как `ifelse()`

```{r}
ifelse(y < 20, "Too high", "Too low")
ifelse(y < 0, "Too high", "Too low")
```

#### Упражнение 19.4.4.2
<div class="question">
Write a greeting function that says “good morning”, “good afternoon”, or “good evening”, depending on the time of day. (Hint: use a time argument that defaults to `lubridate::now()`. That will make it easier to test your function.)
</div>

Итак функция должна работать следующим образом.
Если текущее время меньше либо равно 12:00 --- то выведи «good morning»,
Если текущее время меньше либо равно 18:00 --- то выведи «good afternoon»,
Для всего оставшегося времени выведи «good evening».


```{r}
greeting <- function(time = now()) {
  hour <- hour(time)
  if (hour <= 12) {
    print("good morning")
  } else if (hour <= 18) {
    print("good afternoon")
  } else {
    print("good evening")
  }
}

greeting(now())

hour(ymd_h("2017-01-08:05"))

greeting((ymd_h("2017-01-08:05")))
```

#### Упражнение 19.4.4.3
<div class="question">
Implement a `fizzbuzz` function. It takes a single number as input. If the number is divisible by three, it returns “fizz”. If it’s divisible by five it returns “buzz”. If it’s divisible by three and five, it returns “fizzbuzz”. Otherwise, it returns the number. Make sure you first write working code before you create the function.
</div>

Если остаток от деления на 3 равен нулю и остаток от деления на 5 равен нулю верни «fizzbuzz»,
Если остаток от деления на 3 равен нулю, то верни «fizz»,
Если остаток от деления на 5 равен нулю, то верни «buzz»,
В любом другом случае верни само число

```{r}
fizzbuzz <- function(x) {
  if (x %% 3 == 0 && x %% 5 == 0) {
    print("fizzbuzz")
  } else if (x %% 3 == 0) {
    print("fizz")
  } else if (x %% 5 == 0) {
    print("buzz")
  } else {
    print(x)
  }
}
```

```{r}
fizzbuzz(6)
fizzbuzz(5)
fizzbuzz(15)
fizzbuzz(4)
```

#### Упражнение 19.4.4.4
<div class="question">
How could you use `cut()` to simplify this set of nested if-else statements?

How would you change the call to `cut()` if I’d used `<` instead of `<=`? What is the other chief advantage of `cut()` for this problem? (Hint: what happens if you have many values in temp?)
</div>

```{r}
temp <- seq(-20, 40, by = 5)
temp
```

```{r}
if (temp <= 0) {
  "freezing"
} else if (temp <= 10) {
  "cold"
} else if (temp <= 20) {
  "cool"
} else if (temp <= 30) {
  "warm"
} else {
  "hot"
}
```

Функция `cut()` делит диапазон `x` на интервалы и кодирует значения в `x` в зависимости от того, на какой интервал они попадают. Крайний левый интервал соответствует первому уровню, следующий левый - второму уровню и так далее.

У функции есть аргумент `breaks` --- числовой вектор из двух или более уникальных точек разреза, либо одно число (больше или равное 2), дающее число интервалов, на которые должен быть вырезан x. Число интервалов 

У функции есть логический аргумент `right`, по умолчанию заданный `right = TRUE` указывающий, должны ли интервалы быть закрыты справа (и открыты слева) или наоборот.

```{r}
Z <- stats::rnorm(10000)
table(cut(Z, breaks = -6:6))
```

```{r}
aaa <- c(1,2,3,4,5,2,3,4,5,6,7)
table(cut(aaa, 11))
```

Если посмотреть на скобочки, когда параметр `right = TRUE`, то они являются включающим множеством т.е. неравенством `<=` что подходит для первого условия нашей задачи. Тогда для оптимизации функции нужно проделать следующее:

1. Указать диапазоны --- от минус бесконечности, 0, 10, 20, 30, до плюс бесконечности.

2. Указать параметр --- `right = TRUE`,

3. Указать подписи --- "freezing", "cold", "cool", "warm", "hot" в параметре `labels()`

Итого получаем:

```{r}
temp
table(cut(temp, c(-Inf, 0, 10, 20, 30, Inf),
  right = TRUE,
  labels = c("freezing", "cold", "cool", "warm", "hot")
))
```

Если неравенство станет строгим, то есть сменится `<=` на `<`, тогда нам нужно будет поменять параметр на противоположное значение `right = FALSE`

```{r}
table(cut(temp, c(-Inf, 0, 10, 20, 30, Inf),
  right = FALSE,
  labels = c("freezing", "cold", "cool", "warm", "hot")
))
```

Двумя преимуществами использования `cut()` является:

1. `cut()` работает с векторами, тогда как, `if` работает только с одним значением, 

1. для изменения условия сравнения нужно было только изменить аргумент `right`, в то время как в инструкции `if`  пришлось бы изменить четыре оператора.

#### Упражнение 19.4.4.5
<div class="question">
What happens if you use `switch()` with numeric values?
</div>

В `switch(n, ...)`, если `n` является числовым, он вернет `n`-й аргумент из `...`. Это означает, что если `n = 1`, `switch()` вернет первый аргумент в `...`, если `n = 2`, второй и тд. Например,

```{r}
switch(1, "cat", "dog", "cow")

switch(3, "cat", "dog", "cow")

# При нуле и меньше функция работает вхолостую
switch(0, "cat", "dog", "cow")

switch(-1, "cat", "dog", "cow")

# Если чесло нецело, то игнорируется нецелая часть.
# Не округляется, а именно отсекается
switch(1.5, "cat", "dog", "cow")

switch(3.2, "cat", "dog", "cow")
```

#### Упражнение 19.4.4.6
<div class="question">
What does this switch() call do? What happens if x is “e”?

```{r}
switch(x, 
  a = ,
  b = "ab",
  c = ,
  d = "cd"
)
```

Experiment, then carefully read the documentation.
</div>

```{r}
foo1 <- function(x) {
 switch(x, 
  a = ,
  b = "ab",
  c = ,
  d = "cd"
)
}
```

```{r}
foo1("a")
foo1("b")
foo1("c")
foo1("d")
foo1("e")
foo1("f")
```

Если есть совпадение, то этот элемент оценивается, если только он не отсутствует, и в этом случае следующий не пропущенный элемент оценивается, поэтому, например, `switch("cc", a = 1, cc =, cd =, d = 2)` оценивается как 2. Если найдено более одного совпадения, используется первый соответствующий элемент. В случае отсутствия совпадения, если есть неназванный элемент ... возвращается его значение. (Если существует более одного такого аргумента, сообщается об ошибке.)

### Аргументы функций

Аргументы, можно разделить на две категории:

* ПРедоставляют данные

* ПРедоставляют параметеры, управляющие деталями вычислений

Аргументы с данными указываются в начале.
Аргументы с параметрами указываются в конце. И правилом хорошего тона будет указать значение по умолчанию

```{r}
# Вычисление доверительного интервала вокруг среднего,
# С использованием нормального распределения
mean_ci <- function(x, conf = 0.95) {
  se <- sd(x) / sqrt(length(x))
  alpha <- 1 - conf
  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))
}

x <- runif(105)
x
mean_ci(x)
```

Функция предоставляет рандомное отклонение со следующими параметрами `runif(n, min = 0, max = 1)`

Значение по умолчанию --- наиболее часто используемое значение.
Исключение --- безопасность. Например --- `na.rm = FALSE` использовать значение `TRUE`, даже если чаще всего пропущенные значения и игнорируются, делать это по умолчанию плохая затея. 
Тут просматривается паттернализм --- если делается выбор, по умолчанию то максимально безопасный. Чтобы изменить его, нужно сделать это осознанно.

Если перекрываешь значение по умолчанию аргумента, управляющего вычислениями, то нужно использовать полное имя

```{r}
# Good
mean(1:10, na.rm = TRUE)

# Bad
# mean(x = 1:10, , FALSE)
# mean(, TRUE, x = c(1:10, NA))
```

Используй пробелы, это упростит чтение кода

```{r}
# Good
average <- mean(feet / 12 + inches, na.rm = TRUE)

# Bad
average<-mean(feet/12+inches,na.rm=TRUE)
```

#### Выбор имени

Имя аргументов очень важная штука. Имена нужны для упрощения восприятия твоего кода читателем, а не программой.

Существуют часто употребимые названия аргументов, их следует запомнить

* x, y, z: vectors.

* w: a vector of weights.

* df: a data frame.

* i, j: numeric indices (typically rows and columns).

* n: length, or number of rows.

* p: number of columns.

Во всех остальных случаях операйся на уже существующие имена. Например используй имя `na.rm` для аргумента который опускает пропущенные значения.

#### Проверка значений

Часто бывает полезно сделать ограничения явными. ПРедположим, мы написали функции для вычисления взвешенных итоговых статистик

```{r}
wt_mean <- function(x, w) {
  sum(x * w) / sum(w)
}
wt_var <- function(x, w) {
  mu <- wt_mean(x, w)
  sum(w * (x - mu) ^ 2) / sum(w)
}
wt_sd <- function(x, w) {
  sqrt(wt_var(x, w))
}
```

Что произойдёт, если `x` и `w` имеют разную длинну.

```{r}
wt_mean(1:6, 1:3)
```

Хорошая практика заключается в проверке важных предусловий и генерирования ошибки, если они не выполняются

```{r}
wt_mean <- function(x, w) {
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call = FALSE)
  }
  sum(x * w) / sum(x)
}
```

Робастная --- устойчивая к ошибкам. С этим нужно не перестараться.

Например, если бы мы добавили в функцию аргумент `na.rm`, то мы вероятно, не проверяли бы его слишком тщательно

```{r}
wt_mean <- function(x, w, na.rm = FALSE) {
  # Проверка на то, логический ли параметр
  if (!is.logical(na.rm)) {
    stop("`na.rm` must be logical")
  }
  # Проверка на совпадение длины
  if (length(na.rm) != 1) {
    stop("`na.rm` must be length 1")
  }
  if (length(x) != length(w)) {
    stop("`x` and `w` must be the same length", call. = FALSE)
  }
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}
```

```{r}
wt_mean(1:3, 2:4, na.rm = 0)
```

Для получения столь небольшого выигрыша нам пришлось проделать много дополнительной работ.
ПОлезным компромиссом является использование встроенной функции `stopifnot()`, которая выполняет проверку того, что каждый аргумент равен `TRUE`, и генерирует типовое сообщение об ошибке, если это не так.

```{r}
wt_mean <- function(x, w, na.rm = FALSE) {
  stopifnot(is.logical(na.rm), length(na.rm) == 1)
  stopifnot(length(x) == length(w))
  
  if (na.rm) {
    miss <- is.na(x) | is.na(w)
    x <- x[!miss]
    w <- w[!miss]
  }
  sum(w * x) / sum(w)
}
```

```{r}
wt_mean(1:6, 6:1, na.rm = "foo")
```

Заметим, что когда мы используем функцию `stopifnot()`, мы утверждаем что именно должно быть истинным, а не проверяете что может быть неправильным.

#### Точка-точка-точка (...)

В R многие функции принимают произвольное количество входных параметров со значениями.

```{r}
sum(1, 2, 3, 4, 5)
```

Как они это делают? При помощи сабжа --- `...` (многоточие). Этот аргумент захватывает любое количество аргументов, которым не назначено явных имен.

Такой подход очень удобен, посколько далее можно передать эти точки другой функции. Это особенно полезно, если функция в основном используется в качестве оболочки другой функции. 
Например обычно мы создаем следующие вспомогательные функции-оболочки для функции `str_c()`

```{r}
commas <- function(...) stringr::str_c(..., collapse = ", ")
commas(letters[1:10])

rule <- function(..., pad = "-") {
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
}
rule("Important output")
```

В данном случае многоточия позволяют передать функции `str_c()` любые аргументы, не нуждающиеся в обработке. 

Любые неправильно записанные аргументы не будут генерировать ошибку.
Из-за этого опечатки могут легко пройти незамеыченными.

```{r}
x <- c(1, 2)
sum(x, na.mr = TRUE)
sum(x, na.rm = TRUE)
```

#### Ленивые вычисления

Аргументы обрабатываются в соответствии с концепцией ленивых *отложенных* вычислений.

Вычисление аргументов откладывается до тех пор, пока в этом не возникнет необходимости.

Отсюда следует, что те аргументы, которые не используются в функции, никогда не вычисляются.

#### Упражнение 19.5.5.1
<div class="question">
What does `commas(letters, collapse = "-")` do? Why?
</div>

Для начала напомню функцию которую мы прописали в параграфе "многоточие"

```{r}
commas <- function(...) stringr::str_c(..., collapse = ", ")
commas(letters[1:10])
```


```{r}
commas(letters, collapse = "-")
```

Когда функция `commas()` свертывание задается способом указанном выше, она выдает ошибку.

Это связано с тем, что когда аргумент `collapse` передается `commas()`, он передается в `str_c()` как часть `...`. Другими словами, предыдущий код эквивалентен

```{r}
str_c(letters, collapse = "-", collapse = ", ")
```

Тем не менее, ошибочно давать один и тот же именованный аргумент функции дважды.
Почитай хэлп к `?stringr::str_c` --- `collapse` аргумент для `str_c`.

Один из способов разрешить пользователю переопределять разделитель в  `commas()` --- это добавить аргумент свертывания в функцию.

```{r}
commas <- function(..., collapse = ", ") {
  stringr::str_c(..., collapse = collapse)
}
commas(letters, collapse = "-")
```

Это может запутать. Поэтому имеет смысл назвать аргумент `collapse` в `commas()` как-нибудь по-другому например `furl`, или ещё каким-нибудь словом синонимом.

```{r}
commas <- function(..., furl = ", ") {
  stringr::str_c(..., collapse = furl)
}
commas(letters, furl = "-")
```

#### Упражнение 19.5.5.2
<div class="question">
It’d be nice if you could supply multiple characters to the `pad` argument, e.g. `rule("Title", pad = "-+")`. 
Why doesn’t this currently work? 
How could you fix it?
</div>

Функция `rule` добивает до конца консоли заданные в `pad` символы. По умолчанию мы задали один символ `-`

```{r}
rule <- function(..., pad = "-") {
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  cat(title, " ", stringr::str_dup(pad, width), "\n", sep = "")
}
rule("Important output")
```

Разберём всё по порядку.

Функция `getOption("width")` --- возвращает текущую длину консоли

```{r}
getOption("width")
```

Отсюда получается, что выражение `getOption("width") - nchar(title) - 5` возвращает длинну текущего окна консоли минус длинну передаваемого заголовка и минус 5

Функция `cat()` --- это конкатенация.

```{r}
cat("1", 2, "doggy")
```

Функция `stringr::str_dup()` повторяет вектор строк заданное количество раз.


```{r}
fruit <- c("apple", "pear", "banana")
stringr::str_dup(fruit, 2)
```


Итого функция `rule()` дублирует `pad` количество раз, равное желаемой ширине, минус длина `title` и пять дополнительных символов. Это подразумевает, что `pad` --- это всего лишь один символ. Если бы `pad` был двухсимвольным, результат будет почти вдвое длиннее.

```{r}
rule("Important output", pad = "+-")
rule("Important output", pad = "+-Ж")
rule("Important output", pad = "+-01")
```

Чтобы функция работала с несколькими символами в `pad`, одним из подходов можно укоротить количество выводимых символов.

```{r}
rule <- function(..., pad = "-") {
  title <- paste0(...)
  width <- getOption("width") - nchar(title) - 5
  gap <- stringr::str_dup(
    pad,
    ceiling(width / stringr::str_length(title))
  )
  cat(title, " ", gap, "\n", sep = "")
}

rule("Valuable output", pad = "-+38")
```

Это решение в пределе не совершенно, поскольку при увеличении количества символов, разделитель будет переходить на другую строку. Этого можно избежать усекая строку. Но это уже отладка функции. Вернусь к этой проблеме немного попозже.

#### Упражнение 19.5.5.3
<div class="question">
What does the `trim` argument to `mean()` do? 
When might you use it?
</div>

`trim` --- это доля (от 0 до 0,5) наблюдений, которая будет обрезана с каждого конца `x` до вычисления среднего значения. Значения дифферента за пределами этого диапазона принимаются в качестве ближайшей конечной точки.

Это может пригодится, когда известны выбросы в данных, и понятно, что их можно отбросить.
Это полезно для расчета показателя центральной тенденции, который устойчив к выбросам.

```{r}
x <- (1:10)
y <- c(100, 1, 1, 1, 1, 1, 1, 1, 1, 100)

matrix <- as_tibble(cbind(x, y))

ggplot(data = matrix, aes(x,y)) +
  geom_point()

mean(y)
mean(y, trim = 0.2)
```

#### Упражнение 19.5.5.4
<div class="question">
The default value for the method argument to `cor()` is `c("pearson", "kendall", "spearman")`. 
What does that mean? 
What value is used by default?
</div>

```{r}
# ?cor
```

В описании говорится:

`method` --- это строка символов, указывающая, какой коэффициент корреляции должен быть вычислен. Один из «pearson» (по умолчанию), «kendall» или «spearman».

Это означает, что аргумент метода может принимать одно из этих трех значений. Первое значение, «pearson», используется по умолчанию.

### Возвращаемые значения

При организации возврата следует помнить две вещи:

* Облегчит ли чтение текста функции преждевременный возврат

* Нельзя ли сделать функцию пригодной для включения в цепочки канала

#### Явные команды возврата

Обычно возврат значения является последней инструкцией функции, однако можно организовать преждевременный при помощи `return()`

```{r}
complicated_function <- function(x, y, z) {
  if (length(x) == 0 || length(y) == 0) {
    return(0)
  }
    
  # Complicated code here
}
```

Другой ситуацией является инструкция `if` с одним сложным и одним простым блоками. Например

```{r}
f <- function() {
  if (x) {
    # Do 
    # something
    # that
    # takes
    # many
    # lines
    # to
    # express
  } else {
    # return something short
  }
}
```

Но если первый блок ичень длинный то к тому времени, когда дойдём до `else` можно забыть об условии. Один из способов устранить это недоразумение --- использовать ранний возврат

```{r}
f <- function() {
  if (!x) {
    return(something_short)
  }

  # Do 
  # something
  # that
  # takes
  # many
  # lines
  # to
  # express
}
```

В этом случае на ранний возврат обращаешь внимание сразу, не просматривая весь длинный код.

#### Написание функций, пригодных для включения в канал

Функции способные работать в канале можно разбить на два типа:

* преобразования

* побочные

Преобразующие --- имеется четко определённый первичный объект, который передается в качестве первого аргумента, и его модифицированная версия возвращается функцией.
Например для `dplyr` и `tidyr` --- ключевыми объектами являются фреймы данных.

Функции с побочным эффектом вызываются в первую очередь для какого-либо действия, например для рисования графика или созхранения файла, а не для преобразования объекта. Эти функции должны возвращать первый аргумент "невидимо", поэтому по умолчанию они ничего не выводят, но могут быть использованы в канале. Напримео, следующая функцию выводит кол-во отсутствующих значений во фрейме данных.

```{r}
show_missings <- function(df) {
  n <- sum(is.na(df))
  cat("Missing values: ", n, "\n", sep = "")
  
  invisible(df)
}
```

Если мы вызываем её интерактивно, то вызыво `invisible()` означает, что входной объект `df` не выводится.

```{r}
show_missings(mtcars)
```

Но он есть, просто по умолчанию не выводится.

```{r}
x <- show_missings(mtcars) 

class(x)

dim(x)
```

И мы всё ещё можем использовать функцию в канале.

```{r}
mtcars %>% 
  show_missings() %>% 
  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% 
  show_missings()
```

### Окружение

Окружение функции в значительной мере определяют как работают функции. Окружение управляет тем, как R находит значение, связанное с именем. Возьмем, например,

```{r}
f <- function(x) {
  x + y
}
```

Во многих языках программирования этот код будет ошибочным --- потому что отсутствует определение переменной `y`.
Но в данном случае это нормальный код, так как в R для определения значений переменных используется *лексическая область видимости*. Поскольку переменная `y` не определена в функции, R будет искать её в *окружении*, содержащим определение функции.

```{r}
y <- 100
f(10)

y <- 1000
f(10)
```

R сила --- благодаря своей гибкости можно переопределять базовые функции. И ещё много чего, о чём можно узнать из книги *Advanced R* <http://adv-r.had.co.nz>