---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Функции

### Введение

Написание хороших функций --- это путешествие длинною в жизнь, и да начнётся оно сейчас.

#### Используемые ресурсы

Здесь работаем с базовым функционалом, дополнительные пакеты, не потребуются

```{r}
library(lubridate)
```


### Когда следует писать функции

Когда есть необходимость повторять фрагмент кода более чем два раза.

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Код выше масштабирует значения в каждом столбцу таким образом, чтобы они изменялись в пределах от 0 до 1. Но если присмотреться к выводу `df$b` можно увидеть значения больше единицы. Почему так произошло? Потому что в коде ошибка --- `(max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)` в минимуме вместо `df$b`, стоит `df$a`. 

Не так-то просто обнаружить ошибку в коде, среди однообразных выводов. Внесение повторяющегося кода в функцию --- неплохая идея, поскольку это избавит от ошибок подобного кода.

Чтобы написать фукнцию, нужно сначала проанализировать код. Сколько в нём имеется входных переменных.

В этом коде:

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

Есть лишь одна входная переменная `df$a`. Чтобы облегчить понимание кода вынесем повторяющийся числовой вектор во временную переменную с простым именем

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

Теперь можно заметить, что и тут код дублируется --- диапазон данных вычислется три раза. Хотя это можно сделать только один раз. В этом нам поможет базовая функция `range()`. 

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

На сколько проще и читабельнее стал код. Но и это ещё не всё. Теперь на авансцену выходит --- создание функции

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Итак, как видно из кода выше, создание новой функции включает три ключевых момента

1. Необходимо выбрать *имя* функции. Здесь мы используем имя `rescale01`, поскольку функция масштабирует вектор таким образом, чтобы его значения изменялись в пределах от 0 до 1.

2. Необходимо перечислить входные значения, или *аргументы* функции, после ключевого слова `function`, заключив их в круглые скобки. В данном случае имеется всего один аргумент --- это `(x)`, но если бы их было больше, вызов функции выглядел примерно так `function(x, y, z)`.

3. Разработанный код помещается в тело *функции* --- заключенный в фигурные скобки блок кода, следующий непосредственно за названием функции со списком аргументов.

Если взглянуть на ситуацию в целом, то мы сначала создали простой код, а затем превратили её в функцию. Так следует поступать и в остальных ситуациях. 

На этой стадии целесообразно проверить как работает функция с разными значениями

```{r}
rescale01(c(1, 2, 3, NA, 0.2))
```

Со временем --- очень захочется превратить эти неформальные интерактивные проверки в формальные автоматизированные тесты. Этот процесс называют блочным тестированием. 

Об этом можно узнать больше по адресу <http://r-pkgs.had.co.nz/tests.html>.

Теперь, когда у нас есть функция, мы можем заменить исходный пример.

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

И для сравнения, рядом первоначальный код

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Тут есть ещё над чем работать, например очень хочется избавиться от дублирования и сделать это всё "одной строкой", но об этом мы узнаем чуть позже. 

Большим преимуществом функций, является то, что при изменении требований коду изменение нужно вносить в одном месте. Например, можно обнаружить, что некоторые значения приводят к аварийной работе функции.

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Поскольку мы внесли код в функцию, правку нужно врести в одном месте

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

Это важная составляющая принципа --- НЕ ПОВТОРЯЙСЯ ("Do not repeat yourself", DRY). Чем больше повторений, тем сложнее держать в голове все места, которые будут нуждаться в обновлении.


#### Упражнение 19.2.1.1
<div class="question">
Why is `TRUE` not a parameter to `rescale01()`? What would happen if `x` contained a single missing value, and `na.rm` was `FALSE`?
</div>


Напомню функцию `rescale01()`

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

`TRUE` не является параметром функции, поскольку он не указан в круглых скобках после слова тэга `function`

Если `x` содержит единственное пропущенное значение и `na.rm = FALSE`, то эта функция по-прежнему возвращает не пропущенное значение.

```{r}
rescale01_alt <- function(x, na.rm = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt(c(NA, 1:5), na.rm = FALSE)

rescale01_alt(c(NA, 1:5), na.rm = TRUE)
```

Опция `finite = TRUE` у параметра `range()` удалит все неконечные элементы, а NA - неконечный элемент.

Однако, если и `finite = FALSE` и `na.rm = FALSE`, то эта функция будет возвращать вектор значений `NA`. 
Напомним, арифметические операции со значениями NA возвращают NA.

```{r}
rescale01_alt2 <- function(x, na.rm = FALSE, finite = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = finite)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt2(c(NA, 1:5), na.rm = FALSE, finite = FALSE)
```

#### Упражнение 19.2.1.2
<div class="question">
In the second variant of `rescale01()`, infinite values are left unchanged. Rewrite `rescale01()` so that `-Inf` is mapped to 0, and `Inf` is mapped to 1.
</div>

Для решения хочется использовать конструкцию если `y == -Inf`, то верни 0, если `y == Inf` то верни 1.
Но так как с работой с условиями я ещё не знаком, то внесу эти в явном виде.

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  y <- (x - rng[1]) / (rng[2] - rng[1])
  y[y == -Inf] <- 0
  y[y == Inf] <- 1
  y
}

rescale01(c(0:3, -Inf, Inf, NA))
```

#### Упражнение 19.2.1.3
<div class="question">
Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?
</div>

```{r}
x <- c(0:10)

mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```


1. Эта функция подсчитывает делит количество пропущенных значений на общее количество значений. 
Другими словами --- функция возвращает долю пропущенных значений.

```{r}
t <- c(NA, NA, NA, NA, 1:6)
i <- c(NA, NA, NA, 1:7)

is.na(x)
mean(is.na(x))
```

Я бы назвал эту функцию missing_value_rate, или ещё лучше --- `NA_rate`

```{r}
NA_rate <- function(x) {
  mean(is.na(x))
}

NA_rate(t)
NA_rate(i)
```

2. Эта функция нормирует выборку относительно единицы или другими словами возвращает вес каждого значения в векторе, при этом пропущенные значения не берутся в расчёт.

```{r}
x <- c(2, 10000)
x
x / sum(x, na.rm = TRUE)
```

Я бы назвал эту функцию `weight_to_one` поскольку она показывает вес каждого значения относительно единицы

```{r}
weight_to_one <- function(x) {
  x / sum(x, na.rm = TRUE)
}

weight_to_one(x)
```

Будет выглядеть хорошо, ну по крайне мере однообразно с базовыми функциями, если вынести `na.rm` (по аналогии с `mean` и `median`) со значением по умолчанию `FALSE` как параметр функции. То есть указать его в круглых скобочках после слова `function()`

```{r}
weight_to_one <- function(x, na.rm = FALSE) {
  x / sum(x)
}

weight_to_one(x)
```

3. Стандартное отклонение делённое на среднеарифметическое --- это [коэффициент вариации](http://statistica.ru/glossary/general/koeffitsient-variatsii/). 
Поэтому я назову эту функцию `coefficient_of_variation`.

```{r}
gti <- c(1:1000)

coefficient_of_variation <- function(x) {
  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
}

coefficient_of_variation(gti)
```

Будет ещё лучше, если я, как в предыдущем примере, вынесу `na.rm = FALSE` в параметр функции. Тогда можно будет управлять выводом функции, не изменяя её код.

```{r}
coefficient_of_variation <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}
```

#### Упражнение 19.2.1.4
<div class="question">
Follow <http://nicercode.github.io/intro/writing-functions.html> to write your own functions to compute the variance and skew of a numeric vector.
</div>

Первая функция, которую многие люди, похоже, должны написать, --- это вычислить стандартную ошибку среднего для некоторой переменной, потому что, как ни странно, эта функция не поставляется с базовым пакетом R. Она вычисляется следующим образом $\sqrt{\mathrm{var}(x)/n}$

```{r}
x <- c(1:169)

var(x)
```

`var` --- подсчитывает дисперсию (`variance`). Это то что нам нужно написать самим. 

Но для начала мы напишем функцию для определения стандартной ошибки:

```{r}
standart.error <- function(x) {
  sqrt(var(x)/length(x))
}
```

Но вот таким образом, на самом деле она выглядит "некрасиво" и слабочитаемо. Понятнее будет, если каждую опцию внести в отдельную внутреннюю переменную

```{r}
standart.error <- function(x) {
  v <- var(x)
  n <- length(x)
  sqrt(v/n)
}
```

Правда же так гораздо приятнее? Теперь возьмёмся за функцию дисперсии

По определению, дисперсия --- это среднеквадратическое отклонение от среднего или 
$$
D = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \bar{x}) ^2 \text{,}
$$
Отлично. Теперь переведём это в функцию. $n$ в формуле это длина вектора или `length(x)`. $\bar{x}$ --- это математическое ожидание или среднее `mean(x)`. Тогда вся формула будет иметь вид

```{r}
variance <- function(x, na.rm = FALSE) {
    n <- length(x)
    m <- mean(x, na.rm = na.rm)
    sum((x - m)^2) * (1/(n - 1))
}
```

И теперь проверим нашу функцию

```{r}
x <- c(1:169)

var(x)
variance(x)
```

Отлично!

Возьмёмся за коэффициент асимметрии числового вектора. 
Неформально говоря, коэффициент асимметрии положителен, если правый хвост распределения длиннее левого, и отрицателен в противном случае.
Если распределение симметрично относительно математического ожидания, то его коэффициент асимметрии равен нулю.

![alt text](img/skew.png)

Этот коэффициент считается следующим образом

$$
\gamma_1 = \frac{\frac{1}{n - 2}\left(\sum_{i=1}^{n}(x_{i} - \bar x)^3\right)}{D^{3 / 2}}
$$

Или переводя в функцию, получим
```{r}
skewness <- function(x, na.rm = FALSE) {
  v <- var(x, na.rm = na.rm)
  n <- length(x)
  m <- mean(x, na.rm = na.rm)
  (sum(x - m)^3 / (n - 2)) / v^(3 / 2)
}
```

#### Упражнение 19.2.1.5
<div class="question">
Write `both_na()`, a function that takes two vectors of the same length and returns the number of positions that have an NA in both vectors.
</div>

Сначала разберёмся, как нам считать пропуски.
Чтобы определить пропущенное значение воспользуемся функцией `is.na()`

```{r}
t <- c(1, 2, NA)
y <- c(NA, NA, NA)
is.na(t)
```

А количество значений `TRUE` в векторе, нам поможет посчитать функция `sum()`

```{r}
sum(is.na(t))
sum(is.na(y))
```

Итак, теперь нам надо посмотреть в скольких местах в обоих векторах встречаются пропуски.
В нашем случае это один раз

Такое выражение не верно, оно даёт сумму всех пропущенных значений в обоих векторах
```{r}
sum(is.na(t)) + sum(is.na(y))

```


Такое выражение тоже не подходит, поскольку это логическое `ИЛИ` и оно сравнивает оба вектора и считает за единицу, случай если хотя бы в одном векторе был пропуск.
```{r}
sum(is.na(t) | is.na(y))
```

Тогда наше решение --- это логический оператор `И`. Функция ниже возвращает сумму случаев когда оба значения вектора есть пропущенные значения
```{r}
sum(is.na(t) & is.na(y))
```

Теперь определим это в функцию

```{r}
both_na <- function(x, y) {
  sum(is.na(x) & is.na(y))
}
both_na(t, y)
```

Вуаля

#### Упражнение 19.2.1.6
<div class="question">
What do the following functions do? Why are they useful even though they are so short?

```{r}
is_directory <- function(x) file.info(x)$isdir
is_readable <- function(x) file.access(x, 4) == 0
```
</div>

Функция `is_directory()` проверяет, является ли путь в `x` каталогом. 
Функция `is_readable()` проверяет, является ли путь в `x` доступный для чтения. 
Что означает, что файл существует и у пользователя есть разрешение на его открытие. 
Эти функции полезны даже при том, что они короткие, потому что их имена значительно упрощают работу кода.


#### Упражнение 19.2.1.6
<div class="question">
Read the complete lyrics to “Little Bunny Foo Foo”. There’s a lot of duplication in this song. Extend the initial piping example to recreate the complete song, and use functions to reduce the duplication.
</div>

Пожалуй я скипну это упражнение и вернусь к нему однажды


### Функции создаются для компьютеров и людей

Делай читабельные функции с внятным названием

Будь последовательным --- используй один стиль именования функций.

Семейство аналогичных функций называй согласованно.

Избегай перекрывания имен функций и переменных.

Комментируй свой код отвечая на вопрос `зачем?`. Избегай комментов отвечающих на вопрос `что?` и `как?`

Делай понятный код.

Подумай о добавлении промежуточных переменных.


#### Упражнение 19.3.1.1
<div class="question">
Read the source code for each of the following three functions, puzzle out what they do, and then brainstorm better names.
</div>

1. Пойдём по порядку. 

```{r}
f1 <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}
```


В `f1` используются следующие функции:
  
  `substr()` извлекает подстроки в символьном векторе с заданными параметрами начала извлечения и конца
  
```{r}
substr(c("abc77777", "abd77777", "qwe77777"), 1, 5)
```
  
  `nchar()` считает количество символов в каждом члене символьного вектора
  
```{r}
x <- c("abc77777", "abd77777", "qwe77777")
y <- "ab"

# Всё вместе это работает так
substr(x, 1, nchar(y)) == y
```

```{r}
f1(c("resdfj", "rejsdj-", "eradsf,", "resdfj"), "re")
```
  
  Теперь как работает эта функция. `substr()` принимает первым значением параметр `string` (это на самом деле немного путает вначале, потому что `string` не название функции, а название параметра).
  
  Дальше указана единица --- т.е. из вектора будут извлекаться значения с первой позиции. 
  
  Далее следует функция `nchar(prefix)` --- которая считает количество символов во втором заданном в функцию векторе. Полученное число будет третьим параметром для функции `substr()`, т.е. он задаёт конечное значение извлекаемого вектора. 
  
  Таким образом выражение `substr(string, 1, nchar(prefix))` всегда будет брать из заданных символьных векторов количество символов с первого по длинну префикса.
  
  И наконец операция `== prefix` сравнивает извлечённые символы с заданным префиксом. И возвращает булево значение `TRUE` если вектор содержит префикс и `FALSE`
  
  Исходя из выше описанного я бы назвал функцию `f1` `имеет_префикс()` или по-английски `has_prefix()`
  
```{r}
has_prefix <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}
```

2. Функция `f2` отбрасывает последний элемент вектора `x`

```{r}
f2 <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}
```

Но тут добавлено условие --- если длинна заданного вектора равна или меньше единице, то возвращается `NULL`. И это логично, потому что отбросить последнее значение от единичного вектора всё равно что взять ноль.
```{r}
f2(1)
```

Я бы назваль эту функцию `пни последнего` или `kick_last`

```{r}
kick_last <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}
```

3. В функции `f3` 

```{r}
f3 <- function(x, y) {
  rep(y, length.out = length(x))
}
```
 
  используется функция `rep()` --- она копирует  значения в `x` с заданным параметром `length.out` который указывает желаемую длинy выходного вектора, т.е. длине вектора `x`. Другие входные данные будут приведены к двойному вектору, и первый элемент будет взят. Игнорируется, если NA или недействительным.


```{r}
x <- c("ab", "c77", "c777", "abd77777", "qwe77777")
length(x)
y <- c(1:2)
f3(x, y)

rep(1:4, length.out = 9)
```

Получается, функция `f3` берёт параметр `y` и повторяет его столько раз, какая длина у `x`.

```{r}
f3(c(1:4), "cv")
```

Эту функцию можно назвать `расширение()` или `recycle()`

#### Упражнение 19.3.1.2
<div class="question">
Take a function that you’ve written recently and spend 5 minutes brainstorming a better name for it and its arguments.
</div>

Вернусь сюда когда начну писать свои функции

#### Упражнение 19.3.1.3
<div class="question">
Compare and contrast `rnorm()` and `MASS::mvrnorm()`. How could you make them more consistent?
</div>

```{r}
?rnorm
```


`rnorm()` производит выборки из одномерного нормального распределения, а `MASS::mvrnorm` - из многомерного нормального распределения. 
Основными аргументами в `rnorm()` являются

* `n` --- кол-во наблюдений

* `mean` --- мат.ожидание

* `sd` --- стандартное отклонение.

Основными аргументами `MASS::mvrnorm` являются 

* `n`  --- необходимое кол-во образцов

* `mu` --- вектор, дающий средние значения переменных.

* `Sigma` --- положительно определенная симметричная матрица, определяющая ковариационную матрицу переменных.

Чтобы быть последовательными, они должны иметь одинаковые имена. Однако это сложно. В общем случае лучше соответствовать более широко используемым функциям, например, `rmvnorm()` должен следовать соглашениям `rnorm()`. Однако, хотя среднее значение является правильным в многомерном случае, `sd` не имеет смысла в многомерном случае. Однако обе функции внутренне согласованы. Не было бы хорошей практикой иметь в качестве аргументов аргументы `mu` и `sd`, а в качестве аргументов - Sigma.


#### Упражнение 19.3.1.4
<div class="question">
Make a case for why `norm_r()`, `norm_d()` etc would be better than `rnorm()`, `dnorm()`. Make a case for the opposite.
</div>


Если функции названы `norm_r()` и `norm_d()`, группы соглашений об именах функционируют по их распределению.

Если они названы `rnorm()` и `dnorm()`, соглашение об именовании группирует функции по действию, которое они выполняют.

* Функции r * всегда выбирают из распределений: например, `rnorm()`, `rbinom()`, `runif()` и `rexp()`.

* Функции d * вычисляют плотность вероятности или массу распределения: например, `dnorm()`, `dbinom()`, `dunif()` и `dexp()`.

В дистрибутивах `R` используется это последнее соглашение об именах.

### Условное выполнение

Инструкция `if` позволяет организовать условное выполнение кода. Она имеет следующий синтаксис

```{r}
if (условие) {
  # код выполняемый если условие TRUE
} else {
  # код выполняемый если условие FALSE
}
```

Чтобы получить справку нужно заключить инструкцию в апострофы `?`if``

Рассмотрим пример простой функции, которая возвращает логический вектор, указывающий на то, именован или не именован каждый из элементов вектора

```{r}
has_name <- function(x) {
  nms <- names(x)
  if (is.null(nms)) {
    rep(FALSE, length(x))
  } else {
    !is.na(nms) & nms != ""
  }
}
```

Стандартное для функций правило --- функция возвращает последнее вычисленное значение. В случае функции выше, это может быть результат вычисления любой из двух ветвей оператора `if`

#### Условия

Результатом вычисления условия должно быть логическое значение --- либо `TRUE` либо `FALSE`.

Если это вектор --- будет предупреждение.

Если `NA` --- будет ошибка.

Несколько условий можно объединять при помощи логических векторов `||` (ИЛИ) `&&` (И). 
Они используют короткий цикл вычислений --- как только для оператора обнаруживается, что первое условие равно `TRUE`, остальные условия не обрабатываются.
Аналогично для `&&` --- Если первое условие `FALSE`, остальные не обрабатываются.

Важно --- никогда не использовать операторы `|` `&` в инструкции `if` потому что эти операции векторизованы и применяются к нескольким значениям. Если имеется логический вектор, можно свернуть его в одиночное значение с помощью функции `any()` или `all()`.

Будь внимателен при проверке на равенство. Оператор `==` векторизован, это означает что может быть получено более чем одно выходное значение. В током случае можно проверить, что длина переменной уже равна 1, свернуть вектор с помощью функции `any()` или `all()` или использовать не векторизованную функцию `identical()`.

Функция `identical()` строгая --- она всегда возвращает одиночное значение `TRUE`, либо одиночное значение `FALSE` и не выполняет прпиведение типов. Это означает, что нужно быть аккуратным при сравнении целых чисел с числами двойной точности.

```{r}
identical(0L, 0)
```

Так же будь осторожен при проверке вещественных чисел.

```{r}
x <- sqrt(2) ^ 2
x
x == 2
x - 2
```

вместо этого используй для сравнения функцию `dplyr::near()`

И ещё --- не сравнивай `x == NA`, оно не принесет никакой пользы.

#### Множественные условия

Несколько инструкций можно объединить в цепочки

```{r}
if (this) {
  # сделай это
} else if (that) {
  # сделай ещё что-то
} else {
  # 
}
```

Если цепочка получается длинной, подумай как её переписать. Одна полезная методика предпологает использование функции `switch()`. Эта функция позволяет выбирать ветвь кода на основании заданной позиции или имени.

```{r}
foo <- function(x, y, op) {
 switch(op,
  plus = x + y,
  minus = x - y,
  times = x * y,
  divide = x / y,
  stop("Unknown op!")
)
}
```

Работает она таким образом --- в аргументах функции указываем тег триггер. В теле `switch`-а указываем условия наступления триггера.

вызывается триггер вот таким образом:

```{r}
foo(2, 5, "plus")
foo(2, 5, "divide")
foo(2, 5, "plва")
```

Ещё есть функция `cut()`. Разберём её работу в упражнениях

#### Стиль кода

За инструкцией `if` должны следовать курвы `{}`. Содержимое внутри скобочек должно отделяться двумя пробелами.
Так легче отслеживать иерархию в коде, скользя взглядом вдоль левого края.

Открывающаяся скобка не должна стоять на отдельной строке.

За ней всегда должен следовать переход на новую строка.

Закрывающаяюся курва всегда должна распологаться на отдельной строке, если за ней не следует блок `else`.

Код в фигурных скобках следует всегда отделять пробелами.

```{r}
# Good
if (y < 0 && debug) {
  message("Y is negative")
}

if (y == 0) {
  log(x)
} else {
  y ^ x
}
```

В случае коротких конструкций, умещающихся в одной строке, фигурные скобки можно опустить.

```{r}
y <- 10
x <- if (y < 20) "Too low" else "Too high"
```

Но так лучше не делать, лучше повысить чтение кода курвами

```{r}
if (y < 20) {
  x <- "Too low" 
} else {
  x <- "Too high"
}
```

#### Упражнение 19.4.4.1
<div class="question">
What’s the difference between `if` and `ifelse()`? 
Carefully read the help and construct three examples that illustrate the key differences.
</div>

У `ifelse()` следующие аргументы `ifelse(test, yes, no)`. 

`test` --- логическая проверка. Объект.

`yes`	--- return values for true elements of `test`.

`no`	--- return values for false elements of `test`.

```{r}
x <- c(6:-4)

sqrt(ifelse(x >= 0, x, NA))
if(x >= 0) sqrt(x)
```

Ключевое слово `if` проверяет одно условие, тогда как `ifelse()` проверяет каждый элемент.

```{r}
y <- 10
if (y < 20) {
  "Too low" 
}

if (y < 0) {
  "Too low" 
}
```

В то время как `ifelse()`

```{r}
ifelse(y < 20, "Too high", "Too low")
ifelse(y < 0, "Too high", "Too low")
```

#### Упражнение 19.4.4.2
<div class="question">
Write a greeting function that says “good morning”, “good afternoon”, or “good evening”, depending on the time of day. (Hint: use a time argument that defaults to `lubridate::now()`. That will make it easier to test your function.)
</div>

Итак функция должна работать следующим образом.
Если текущее время меньше либо равно 12:00 --- то выведи «good morning»,
Если текущее время меньше либо равно 18:00 --- то выведи «good afternoon»,
Для всего оставшегося времени выведи «good evening».


```{r}
greeting <- function(time = now()) {
  hour <- hour(time)
  if (hour <= 12) {
    print("good morning")
  } else if (hour <= 18) {
    print("good afternoon")
  } else {
    print("good evening")
  }
}

greeting(now())

hour(ymd_h("2017-01-08:05"))

greeting((ymd_h("2017-01-08:05")))
```

#### Упражнение 19.4.4.3
<div class="question">
Implement a `fizzbuzz` function. It takes a single number as input. If the number is divisible by three, it returns “fizz”. If it’s divisible by five it returns “buzz”. If it’s divisible by three and five, it returns “fizzbuzz”. Otherwise, it returns the number. Make sure you first write working code before you create the function.
</div>

Если остаток от деления на 3 равен нулю и остаток от деления на 5 равен нулю верни «fizzbuzz»,
Если остаток от деления на 3 равен нулю, то верни «fizz»,
Если остаток от деления на 5 равен нулю, то верни «buzz»,
В любом другом случае верни само число

```{r}
fizzbuzz <- function(x) {
  if (x %% 3 == 0 && x %% 5 == 0) {
    print("fizzbuzz")
  } else if (x %% 3 == 0) {
    print("fizz")
  } else if (x %% 5 == 0) {
    print("buzz")
  } else {
    print(x)
  }
}
```

```{r}
fizzbuzz(6)
fizzbuzz(5)
fizzbuzz(15)
fizzbuzz(4)
```

#### Упражнение 19.4.4.4
<div class="question">
How could you use `cut()` to simplify this set of nested if-else statements?

How would you change the call to `cut()` if I’d used `<` instead of `<=`? What is the other chief advantage of `cut()` for this problem? (Hint: what happens if you have many values in temp?)
</div>

```{r}
temp <- seq(-20, 40, by = 5)
temp
```

```{r}
if (temp <= 0) {
  "freezing"
} else if (temp <= 10) {
  "cold"
} else if (temp <= 20) {
  "cool"
} else if (temp <= 30) {
  "warm"
} else {
  "hot"
}
```

Функция `cut()` делит диапазон `x` на интервалы и кодирует значения в `x` в зависимости от того, на какой интервал они попадают. Крайний левый интервал соответствует первому уровню, следующий левый - второму уровню и так далее.

У функции есть аргумент `breaks` --- числовой вектор из двух или более уникальных точек разреза, либо одно число (больше или равное 2), дающее число интервалов, на которые должен быть вырезан x. Число интервалов 

У функции есть логический аргумент `right`, по умолчанию заданный `right = TRUE` указывающий, должны ли интервалы быть закрыты справа (и открыты слева) или наоборот.

```{r}
Z <- stats::rnorm(10000)
table(cut(Z, breaks = -6:6))
```

```{r}
aaa <- c(1,2,3,4,5,2,3,4,5,6,7)
table(cut(aaa, 11))
```

Если посмотреть на скобочки, когда параметр `right = TRUE`, то они являются включающим множеством т.е. неравенством `<=` что подходит для первого условия нашей задачи. Тогда для оптимизации функции нужно проделать следующее:

1. Указать диапазоны --- от минус бесконечности, 0, 10, 20, 30, до плюс бесконечности.

2. Указать параметр --- `right = TRUE`,

3. Указать подписи --- "freezing", "cold", "cool", "warm", "hot" в параметре `labels()`

Итого получаем:

```{r}
temp
table(cut(temp, c(-Inf, 0, 10, 20, 30, Inf),
  right = TRUE,
  labels = c("freezing", "cold", "cool", "warm", "hot")
))
```

Если неравенство станет строгим, то есть сменится `<=` на `<`, тогда нам нужно будет поменять параметр на противоположное значение `right = FALSE`

```{r}
table(cut(temp, c(-Inf, 0, 10, 20, 30, Inf),
  right = FALSE,
  labels = c("freezing", "cold", "cool", "warm", "hot")
))
```

Двумя преимуществами использования `cut()` является:

1. `cut()` работает с векторами, тогда как, `if` работает только с одним значением, 

1. для изменения условия сравнения нужно было только изменить аргумент `right`, в то время как в инструкции `if`  пришлось бы изменить четыре оператора.
