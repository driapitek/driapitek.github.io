---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Функции

### Введение

Написание хороших функций --- это путешествие длинною в жизнь, и да начнётся оно сейчас.

#### Используемые ресурсы

Здесь работаем с базовым функционалом, дополнительные пакеты, не потребуются

### Когда следует писать функции

Когда есть необходимость повторять фрагмент кода более чем два раза.

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Код выше масштабирует значения в каждом столбцу таким образом, чтобы они изменялись в пределах от 0 до 1. Но если присмотреться к выводу `df$b` можно увидеть значения больше единицы. Почему так произошло? Потому что в коде ошибка --- `(max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)` в минимуме вместо `df$b`, стоит `df$a`. 

Не так-то просто обнаружить ошибку в коде, среди однообразных выводов. Внесение повторяющегося кода в функцию --- неплохая идея, поскольку это избавит от ошибок подобного кода.

Чтобы написать фукнцию, нужно сначала проанализировать код. Сколько в нём имеется входных переменных.

В этом коде:

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

Есть лишь одна входная переменная `df$a`. Чтобы облегчить понимание кода вынесем повторяющийся числовой вектор во временную переменную с простым именем

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

Теперь можно заметить, что и тут код дублируется --- диапазон данных вычислется три раза. Хотя это можно сделать только один раз. В этом нам поможет базовая функция `range()`. 

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

На сколько проще и читабельнее стал код. Но и это ещё не всё. Теперь на авансцену выходит --- создание функции

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Итак, как видно из кода выше, создание новой функции включает три ключевых момента

1. Необходимо выбрать *имя* функции. Здесь мы используем имя `rescale01`, поскольку функция масштабирует вектор таким образом, чтобы его значения изменялись в пределах от 0 до 1.

2. Необходимо перечислить входные значения, или *аргументы* функции, после ключевого слова `function`, заключив их в круглые скобки. В данном случае имеется всего один аргумент --- это `(x)`, но если бы их было больше, вызов функции выглядел примерно так `function(x, y, z)`.

3. Разработанный код помещается в тело *функции* --- заключенный в фигурные скобки блок кода, следующий непосредственно за названием функции со списком аргументов.

Если взглянуть на ситуацию в целом, то мы сначала создали простой код, а затем превратили её в функцию. Так следует поступать и в остальных ситуациях. 

На этой стадии целесообразно проверить как работает функция с разными значениями

```{r}
rescale01(c(1, 2, 3, NA, 0.2))
```

Со временем --- очень захочется превратить эти неформальные интерактивные проверки в формальные автоматизированные тесты. Этот процесс называют блочным тестированием. 

Об этом можно узнать больше по адресу <http://r-pkgs.had.co.nz/tests.html>.

Теперь, когда у нас есть функция, мы можем заменить исходный пример.

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

И для сравнения, рядом первоначальный код

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Тут есть ещё над чем работать, например очень хочется избавиться от дублирования и сделать это всё "одной строкой", но об этом мы узнаем чуть позже. 

Большим преимуществом функций, является то, что при изменении требований коду изменение нужно вносить в одном месте. Например, можно обнаружить, что некоторые значения приводят к аварийной работе функции.

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Поскольку мы внесли код в функцию, правку нужно врести в одном месте

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

Это важная составляющая принципа --- НЕ ПОВТОРЯЙСЯ ("Do not repeat yourself", DRY). Чем больше повторений, тем сложнее держать в голове все места, которые будут нуждаться в обновлении.
