---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Функции

### Введение

Написание хороших функций --- это путешествие длинною в жизнь, и да начнётся оно сейчас.

#### Используемые ресурсы

Здесь работаем с базовым функционалом, дополнительные пакеты, не потребуются

### Когда следует писать функции

Когда есть необходимость повторять фрагмент кода более чем два раза.

```{r}
df <- tibble::tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Код выше масштабирует значения в каждом столбцу таким образом, чтобы они изменялись в пределах от 0 до 1. Но если присмотреться к выводу `df$b` можно увидеть значения больше единицы. Почему так произошло? Потому что в коде ошибка --- `(max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)` в минимуме вместо `df$b`, стоит `df$a`. 

Не так-то просто обнаружить ошибку в коде, среди однообразных выводов. Внесение повторяющегося кода в функцию --- неплохая идея, поскольку это избавит от ошибок подобного кода.

Чтобы написать фукнцию, нужно сначала проанализировать код. Сколько в нём имеется входных переменных.

В этом коде:

```{r}
(df$a - min(df$a, na.rm = TRUE)) /
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
```

Есть лишь одна входная переменная `df$a`. Чтобы облегчить понимание кода вынесем повторяющийся числовой вектор во временную переменную с простым именем

```{r}
x <- df$a
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
```

Теперь можно заметить, что и тут код дублируется --- диапазон данных вычислется три раза. Хотя это можно сделать только один раз. В этом нам поможет базовая функция `range()`. 

```{r}
rng <- range(x, na.rm = TRUE)
(x - rng[1]) / (rng[2] - rng[1])
```

На сколько проще и читабельнее стал код. Но и это ещё не всё. Теперь на авансцену выходит --- создание функции

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(c(0, 5, 10))
```

Итак, как видно из кода выше, создание новой функции включает три ключевых момента

1. Необходимо выбрать *имя* функции. Здесь мы используем имя `rescale01`, поскольку функция масштабирует вектор таким образом, чтобы его значения изменялись в пределах от 0 до 1.

2. Необходимо перечислить входные значения, или *аргументы* функции, после ключевого слова `function`, заключив их в круглые скобки. В данном случае имеется всего один аргумент --- это `(x)`, но если бы их было больше, вызов функции выглядел примерно так `function(x, y, z)`.

3. Разработанный код помещается в тело *функции* --- заключенный в фигурные скобки блок кода, следующий непосредственно за названием функции со списком аргументов.

Если взглянуть на ситуацию в целом, то мы сначала создали простой код, а затем превратили её в функцию. Так следует поступать и в остальных ситуациях. 

На этой стадии целесообразно проверить как работает функция с разными значениями

```{r}
rescale01(c(1, 2, 3, NA, 0.2))
```

Со временем --- очень захочется превратить эти неформальные интерактивные проверки в формальные автоматизированные тесты. Этот процесс называют блочным тестированием. 

Об этом можно узнать больше по адресу <http://r-pkgs.had.co.nz/tests.html>.

Теперь, когда у нас есть функция, мы можем заменить исходный пример.

```{r}
df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```

И для сравнения, рядом первоначальный код

```{r}
df$a <- (df$a - min(df$a, na.rm = TRUE)) / 
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$b <- (df$b - min(df$b, na.rm = TRUE)) / 
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))
df$c <- (df$c - min(df$c, na.rm = TRUE)) / 
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))
df$d <- (df$d - min(df$d, na.rm = TRUE)) / 
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))
df
```

Тут есть ещё над чем работать, например очень хочется избавиться от дублирования и сделать это всё "одной строкой", но об этом мы узнаем чуть позже. 

Большим преимуществом функций, является то, что при изменении требований коду изменение нужно вносить в одном месте. Например, можно обнаружить, что некоторые значения приводят к аварийной работе функции.

```{r}
x <- c(1:10, Inf)
rescale01(x)
```

Поскольку мы внесли код в функцию, правку нужно врести в одном месте

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01(x)
```

Это важная составляющая принципа --- НЕ ПОВТОРЯЙСЯ ("Do not repeat yourself", DRY). Чем больше повторений, тем сложнее держать в голове все места, которые будут нуждаться в обновлении.


#### Упражнение 19.2.1.1
<div class="question">
Why is `TRUE` not a parameter to `rescale01()`? What would happen if `x` contained a single missing value, and `na.rm` was `FALSE`?
</div>


Напомню функцию `rescale01()`

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
```

`TRUE` не является параметром функции, поскольку он не указан в круглых скобках после слова тэга `function`

Если `x` содержит единственное пропущенное значение и `na.rm = FALSE`, то эта функция по-прежнему возвращает не пропущенное значение.

```{r}
rescale01_alt <- function(x, na.rm = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt(c(NA, 1:5), na.rm = FALSE)

rescale01_alt(c(NA, 1:5), na.rm = TRUE)
```

Опция `finite = TRUE` у параметра `range()` удалит все неконечные элементы, а NA - неконечный элемент.

Однако, если и `finite = FALSE` и `na.rm = FALSE`, то эта функция будет возвращать вектор значений `NA`. 
Напомним, арифметические операции со значениями NA возвращают NA.

```{r}
rescale01_alt2 <- function(x, na.rm = FALSE, finite = FALSE) {
  rng <- range(x, na.rm = na.rm, finite = finite)
  (x - rng[1]) / (rng[2] - rng[1])
}
rescale01_alt2(c(NA, 1:5), na.rm = FALSE, finite = FALSE)
```

#### Упражнение 19.2.1.2
<div class="question">
In the second variant of `rescale01()`, infinite values are left unchanged. Rewrite `rescale01()` so that `-Inf` is mapped to 0, and `Inf` is mapped to 1.
</div>

Для решения хочется использовать конструкцию если `y == -Inf`, то верни 0, если `y == Inf` то верни 1.
Но так как с работой с условиями я ещё не знаком, то внесу эти в явном виде.

```{r}
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE, finite = TRUE)
  y <- (x - rng[1]) / (rng[2] - rng[1])
  y[y == -Inf] <- 0
  y[y == Inf] <- 1
  y
}

rescale01(c(0:3, -Inf, Inf, NA))
```

#### Упражнение 19.2.1.3
<div class="question">
Practice turning the following code snippets into functions. Think about what each function does. What would you call it? How many arguments does it need? Can you rewrite it to be more expressive or less duplicative?
</div>

```{r}
x <- c(0:10)

mean(is.na(x))

x / sum(x, na.rm = TRUE)

sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
```


1. Эта функция подсчитывает делит количество пропущенных значений на общее количество значений. 
Другими словами --- функция возвращает долю пропущенных значений.

```{r}
t <- c(NA, NA, NA, NA, 1:6)
i <- c(NA, NA, NA, 1:7)

is.na(x)
mean(is.na(x))
```

Я бы назвал эту функцию missing_value_rate, или ещё лучше --- `NA_rate`

```{r}
NA_rate <- function(x) {
  mean(is.na(x))
}

NA_rate(t)
NA_rate(i)
```

2. Эта функция нормирует выборку относительно единицы или другими словами возвращает вес каждого значения в векторе, при этом пропущенные значения не берутся в расчёт.

```{r}
x <- c(2, 10000)
x
x / sum(x, na.rm = TRUE)
```

Я бы назвал эту функцию `weight_to_one` поскольку она показывает вес каждого значения относительно единицы

```{r}
weight_to_one <- function(x) {
  x / sum(x, na.rm = TRUE)
}

weight_to_one(x)
```

Будет выглядеть хорошо, ну по крайне мере однообразно с базовыми функциями, если вынести `na.rm` (по аналогии с `mean` и `median`) со значением по умолчанию `FALSE` как параметр функции. То есть указать его в круглых скобочках после слова `function()`

```{r}
weight_to_one <- function(x, na.rm = FALSE) {
  x / sum(x)
}

weight_to_one(x)
```

3. Стандартное отклонение делённое на среднеарифметическое --- это [коэффициент вариации](http://statistica.ru/glossary/general/koeffitsient-variatsii/). 
Поэтому я назову эту функцию `coefficient_of_variation`.

```{r}
gti <- c(1:1000)

coefficient_of_variation <- function(x) {
  sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)
}

coefficient_of_variation(gti)
```

Будет ещё лучше, если я, как в предыдущем примере, вынесу `na.rm = FALSE` в параметр функции. Тогда можно будет управлять выводом функции, не изменяя её код.

```{r}
coefficient_of_variation <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}
```

#### Упражнение 19.2.1.4
<div class="question">
Follow <http://nicercode.github.io/intro/writing-functions.html> to write your own functions to compute the variance and skew of a numeric vector.
</div>
Первая функция, которую многие люди, похоже, должны написать, --- это вычислить стандартную ошибку среднего для некоторой переменной, потому что, как ни странно, эта функция не поставляется с базовым пакетом R. Она вычисляется следующим образом $\sqrt{\mathrm{var}(x)/n}$

```{r}
x <- c(1:169)
x

var(x)
```

`var` --- подсчитывает дисперсию (`variance`). Это то что нам нужно написать самим. Но для начала мы напишем функцию для определения стандартной ошибки:

```{r}
standart.error <- function(x) {
  sqrt(var(x)/length(x))
}
```


```{r}
variance <- function(x) {
    n <- length(x)
    m <- mean(x)
    (1/(n - 1)) * sum((x - m)^2)
}
```

