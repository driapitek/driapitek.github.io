---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Программирование
## Введение
Запомни --- код это средство коммуникации.
Коммуницируем мы с компьютером и человеком.
Поэтому он должен быть понятен и тому и другому.

## Узнайте больше

Две книги, которые предстоит изучить

* Первая это [Hands on Programming with R](https://www.amazon.com/dp/1449359019/ref=cm_sw_su_dp) by Garrett Grolemund.

* Вторая это [Advanced R](http://adv-r.had.co.nz) by Hadley Wickham

## Работа с каналами с помощью пакета `magrittr`

### Введение

Каналы мощный инструмент. В этой главе познакомимся как с ними работать, когда следует и когда не следует использовать.

#### Необходимые ресурсы

```{r}
library(magrittr)
```

### Альтернативы каналам

Смысл использования каналов -- помочь писать код, который легко читать и понимать. Рассмотрим на шуточном примере:

<div class="question">
Little bunny Foo Foo
Went hopping through the forest
Scooping up the field mice
And bopping them on the head
</div>

```{r}
# foo_foo <- little_bunny()
```


#### Промежуточные объекты

Простейший подход --- итеративно заменять каждый шаг.

```{r}
# foo_foo_1 <- hop(foo_foo, through = forest)
# foo_foo_2 <- scoop(foo_foo_1, up = field_mice)
# foo_foo_3 <- bop(foo_foo_2, on = head)
```

Минусы --- нужно запоминать и тщательно следить за нумерацией функций, повышается вероятность ошибок.
Но вариант имеет право на жизнь.

#### Замена исходного объекта

```{r}
# foo_foo <- hop(foo_foo, through = forest)
# foo_foo <- scoop(foo_foo, up = field_mice)
# foo_foo <- bop(foo_foo, on = head)
```

Здесь повышается читабельность, однако

* ослажняется отладка --- если допустить ошибку, то придется выполнять заново весь канал

* повторение преобразуемого объекта затрудняет понимание смысла изменений в каждой строке

#### Композиция функций

```{r}
# bop(
#  scoop(
#     hop(foo_foo, through = forest),
#     up = field_mice
#   ), 
#   on = head
# )
```

Минус --- код приходится читать снизу вверх и слева направо, а аргументы и соответствующие им функции оказываются разнесёнными.
Такой код воспринимать человеку очень непросто.

#### Использование канала

```{r}
# foo_foo %>%
#   hop(through = forest) %>%
#   scoop(up = field_mice) %>%
#   bop(on = head)
```

Использование канала проще для понимания --- поскольку он фокусирует внимание на глаголах а не на существительных.

Канал работает, выполняя "лексическое преобразование": `magrittr` за кулисами переассемблирует код в канале, преобразуя его в форму, которая работает путём замены промежуточного объекта. Когда вы выполняете канал наподобие предыдущего, `magrittr` делает примерно следующее

```{r}
# y_pipe <- function(.) {
#   . <- hop(., through = forest)
#   . <- scoop(., up = field_mice)
#   bop(., on = head)
# }
# my_pipe(foo_foo)
```

Отсюда следует, что канал не работает для следующих двух классов функций

* Функции использующие текущее окружение. Например функции `load()`, `get()`, `assign()`

```{r}
assign("x", c(10, 20, 30))

y <- c(10, 20, 30)
```

* Функции использующие ленивые вычисления. `try()`, `suppressMessages()`, `suppressWarnings()` и многие другие.

### Когда канал не следует использовать

* Длина канала превышает 10 шагов. Это облегчит отладку.

* Имеется несколько входных или выходных значений. Если преобразуемых объектов не один, а два или более и все они взаимосвязаны, не используйте канал.

* Вы начинаете задумываться об использовании направленного графа со сложной структурой зависимостей. Каналу в силу своей природы линейны, и выражение сложных отношений с их помощью обычно приводит к запутанному коду

### Другие инструменты

Все пакеты `tidyverse` автоматически делают доступным оператор `%>%`, однако понадобится явно указать пакет `magrittr` если возникнет одна из следующих ситуаций

* В процессе работы с более сложными каналами иногда удобно вызывть функцию ради её побочных эффектов. Во многих случаях такие функции ничего не возвращают, фактически закрывая канал. 

В качестве обходного пути, можно использовать Т-канал. Оператор `%T>%` работает подобно `%>%`, за исключением того, что возвращает не правую, а левую часть.

```{r}
rnorm(100) %>%
  matrix(ncol = 2) %>%
  plot() %>%
  str()
```

```{r}
rnorm(100) %>%
  matrix(ncol = 2) %T>%
  plot() %>%
  str()
```

* Если вы работаете с функциями, не имеющими программного интерфейса, для работы с фреймами данных, то есть передаете им индивидуальные векторы, а не фрейм данных и вычисляемые в его контексте выражения, вам может быть полезен оператор `%$%`. Он вырывает переменные из фрейма данных, чтобы на них можно было явно ссылаться. Это может пригодиться, при работе со многими функциями, входящими в базовый комплект R

```{r}
mtcars %$%
  cor(disp, mpg)
```

* Оператор присваивания `%<>%`.

```{r}
mtcars <- mtcars %>% 
  transform(cyl = cyl * 2)

mtcars %<>% transform(cyl = cyl * 2)
```

Но операция присваивания на столько специфичная, что для большей читаемости кода рекомендуется делать всё же так `mtcars <- mtcars`


