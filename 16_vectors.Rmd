---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Векторы

### Введение

Векторы в R --- наше всё. Надо быть готовыми к работе с ними.

#### Используемые ресурсы

Нам понадятся ряд функций из пакета `purrr`

```{r}
library(tidyverse)
```

### Основные сведения о векторах

Есть два основных типа векторов: атомарные вектора и списки

1. *Атомарные векторы* :

  - логический (`logical`)
  
  - целочисленный (`integer`)
  
  - вещественный (`double`)
  
  - символьный (`character`)
  
  - комплексный (`complex`)
  
  - двоичные ("сырые") данные (`raw`)
  
2. *Списки*, их иногда называют рекурсивными векторами --- потому что они могут содержать другие списки.

Главное различие между атомарными векторами и списками заключается в том, что первые однородны, тогда как вторые могут быть неоднородными, т.е. могут содержать элементы разных типов.
Существует еще один родственный им объект `NULL` --- его часто используют для представления отсутствия вектора (в отличае от значения `NA`, используемого для представления отсутствия значения в векторе!).

Обычно `NULL` ведёт себя как вектор нулевой длины. Взаимосвязь различных векторов показана на рисунке

![alt text](img/vectors.png)

Каждый вектор зарактеризуется двумя основными свойствами.

* *Тип* Для определениея типа вектора служит функция `typeof()`

```{r}
typeof("letters")

typeof(1:10)
```

* *Длина* Для определения длины вектора служит функция `length()`

```{r}
x <- list("a", "b", 1:10)
length(x)
```

Кроме того, векторы могут содержать произвольные дополнительные метаданные в форме атрибутов, которые используются для создания *расширенных* векторово, обладающих дополнительными аспектами поведения. Существуют четыре важных типа расширенных векторов:

* *факторы* --- строятся поверх целочисленных векторов

* векторы *даты* и *даты/времени* --- строятся поверх числовых векторов

* *фрейм данные* и *tibble-фреймы* --- строятся поверх списков

### Важные типы атомарных векторов

#### Логический тип

Простейший тип, могут содержать только три возможных значения `FALSE`, `TRUE`, и `NA`

```{r}
c(TRUE, TRUE, FALSE, NA)
```

#### Числовой тип

Целочисленные и вещественные векторы совокупно называются числовыми. Число обозначается как целое следующей за ним большой буквой `L`

```{r}
typeof(1)

typeof(1L)

```

В R числа являются вещественными по умолчанию, за исключением следующих случаев

* Вещественные числа являются приближенными. Это значения, представляющие числа с плавающей точкой.
Например,

```{r}
x <- sqrt(2) ^ 2
x

x - 2
```

Поэтому вещественные числа лучше сравнивать при помощи `dplyr::near()`. Это безопасный способ сравнения, если два вектора чисел с плавающей запятой (попарно) равны. Это безопаснее, чем использовать `==`, потому что он имеет встроенный допуск

1.  Целые числа включают одно специальное значение --- `NA`, тогда как среди вещественных чисел таких щначений четыре: `NA`, `NaN`, `Inf` и`-Inf`. Все огни могу появится при делении чисел

```{r}
c(-1, 0, 1) / 0
```

  Избегай использования оператора `==` для тестирования указанных специальных значений. Вместо этого используй вспомогательные функции
`is.finite()`, `is.infinite()` и `is.nan()`

    
    |                  |  0  | Inf | NA  | NaN |
    |------------------|-----|-----|-----|-----|
    | `is.finite()`    |  x  |     |     |     |
    | `is.infinite()`  |     |  x  |     |     |
    | `is.na()`        |     |     |  x  |  x  |
    | `is.nan()`       |     |     |     |  x  |

#### Символьный тип




Разберись с пурир!


Самый сложный, поскольку каждый элемент --- строка, а строка может содержать произвольное количество данных.

R использует глобальный пул строк.

```{r}
x <- "This is a reasonably long string."
pryr::object_size(x)

y <- rep(x, 1000)
pryr::object_size(y)
```

