---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Векторы

### Введение

Векторы в R --- наше всё. Надо быть готовыми к работе с ними.

#### Используемые ресурсы

Нам понадятся ряд функций из пакета `purrr`

```{r}
library(tidyverse)
library(pryr)
```

### Основные сведения о векторах

Есть два основных типа векторов: атомарные вектора и списки

1. *Атомарные векторы* :

  - логический (`logical`)
  
  - целочисленный (`integer`)
  
  - вещественный (`double`)
  
  - символьный (`character`)
  
  - комплексный (`complex`)
  
  - двоичные ("сырые") данные (`raw`)
  
2. *Списки*, их иногда называют рекурсивными векторами --- потому что они могут содержать другие списки.

Главное различие между атомарными векторами и списками заключается в том, что первые однородны, тогда как вторые могут быть неоднородными, т.е. могут содержать элементы разных типов.
Существует еще один родственный им объект `NULL` --- его часто используют для представления отсутствия вектора (в отличае от значения `NA`, используемого для представления отсутствия значения в векторе!).

Обычно `NULL` ведёт себя как вектор нулевой длины. Взаимосвязь различных векторов показана на рисунке

![alt text](img/vectors.png)

Каждый вектор зарактеризуется двумя основными свойствами.

* *Тип* Для определениея типа вектора служит функция `typeof()`

```{r}
typeof("letters")

typeof(1:10)
```

* *Длина* Для определения длины вектора служит функция `length()`

```{r}
x <- list("a", "b", 1:10)
length(x)
```

Кроме того, векторы могут содержать произвольные дополнительные метаданные в форме атрибутов, которые используются для создания *расширенных* векторово, обладающих дополнительными аспектами поведения. Существуют четыре важных типа расширенных векторов:

* *факторы* --- строятся поверх целочисленных векторов

* векторы *даты* и *даты/времени* --- строятся поверх числовых векторов

* *фрейм данные* и *tibble-фреймы* --- строятся поверх списков

### Важные типы атомарных векторов

#### Логический тип

Простейший тип, могут содержать только три возможных значения `FALSE`, `TRUE`, и `NA`

```{r}
c(TRUE, TRUE, FALSE, NA)
```

#### Числовой тип

Целочисленные и вещественные векторы совокупно называются числовыми. Число обозначается как целое следующей за ним большой буквой `L`

```{r}
typeof(1)

typeof(1L)

```

В R числа являются вещественными по умолчанию, за исключением следующих случаев

* Вещественные числа являются приближенными. Это значения, представляющие числа с плавающей точкой.
Например,

```{r}
x <- sqrt(2) ^ 2
x

x - 2
```

Поэтому вещественные числа лучше сравнивать при помощи `dplyr::near()`. Это безопасный способ сравнения, если два вектора чисел с плавающей запятой (попарно) равны. Это безопаснее, чем использовать `==`, потому что он имеет встроенный допуск

1.  Целые числа включают одно специальное значение --- `NA`, тогда как среди вещественных чисел таких щначений четыре: `NA`, `NaN`, `Inf` и`-Inf`. Все огни могу появится при делении чисел

```{r}
c(-1, 0, 1) / 0
```

  Избегай использования оператора `==` для тестирования указанных специальных значений. Вместо этого используй вспомогательные функции
`is.finite()`, `is.infinite()` и `is.nan()`

    
    |                  |  0  | Inf | NA  | NaN |
    |------------------|-----|-----|-----|-----|
    | `is.finite()`    |  x  |     |     |     |
    | `is.infinite()`  |     |  x  |     |     |
    | `is.na()`        |     |     |  x  |  x  |
    | `is.nan()`       |     |     |     |  x  |

#### Символьный тип

Самый сложный, поскольку каждый элемент --- строка, а строка может содержать произвольное количество данных.

R использует глобальный пул строк --- каждая уникальная строка сохраняется в памяти всего один раз. И всякий раз когда оа используется, фактически используется указательна представление строка.
Это позволяет снизить расход памяти при дублировании строк, в чем можно непосредственно убедиться с помощью функции `pryr::object_size()`

```{r}
x <- "This is a reasonably long string."
pryr::object_size(x)

y <- rep(x, 1000)
pryr::object_size(y)
```

Переменная `y` не занимает в 1000 раз больше памяти по сравнению с `x`, поскольку каждый элемент `y` всего лишь указатель на одну и ту же строчку. Указатель занимает 8 байт, поэтому для 1000 указателей на строку, занимающую 136 байт, требуется память объёмом 8 * 1000 + 136 = 8,13 Кбайт.

#### Отсутствующие значения

Для каждого типа атомарных векторов предусмотрено своё отсутствующее значение.

```{r}
NA            # logical

NA_integer_   # integer

NA_real_      # double

NA_character_ # character
```

#### Упражнение 20.3.5.1
<div class="question">
Describe the difference between `is.finite(x)` and `!is.infinite(x)`.
</div>

```{r}
x <- c(0, 1, NA, NaN, Inf, -Inf)
is.finite(x)

!is.infinite(x)
```

Функция `is.finite()` считает, что не пропущенные числовые `(0, 1)` значения являются конечными, а пропущенные `(NA)`, не число `(NaN)` и положительная-отрицательная бесконечность `(Inf, -Inf)` не являются конечными. 
Функция `is.infinite()` ведет себя немного по-другому. Она считает, что `Inf` и `-Inf` бесконечны, а все остальное, включая не пропущенные числа, `NA` и `NaN`, не бесконечно.

#### Упражнение 20.3.5.2
<div class="question">
Read the source code for `dplyr::near()` (Hint: to see the source code, drop the ()). How does it work?
</div>

```{r}
dplyr::near
```

Вместо проверки на точное равенство, функция `dplyr::near()` проверяет, что два числа находятся в пределах определенного допуска, `tol`. По умолчанию для допуска установлен квадратный корень из `.Machine$double.eps`, который является наименьшим числом с плавающей запятой, которое может представить компьютер.

```{r}
.Machine$double.eps
```

#### Упражнение 20.3.5.3
<div class="question">
A logical vector can take 3 possible values. How many possible values can an integer vector take? How many possible values can a double take? Use google to do some research.
</div>

Для целочисленных векторов, R использует a 32-битное представление. Это означает что вектор может быть представлен $2^{32}$ различными значениями с целыми числами. Одно из этих значений отложено для `NA_integer_`. Из справки для целых чисел.

> Note that current implementations of R use 32-bit integers for integer vectors,
> so the range of representable integers is restricted to about +/-2*10^9: doubles
> can hold much larger integers exactly.

Диапазон значений целых чисел, которые R может представлять в целочисленном векторе, равен $\pm 2^{31} - 1$,

```{r}
.Machine$integer.max
```

Самое большое целое число это $2^{31} - 1$ меньше чем $2^{32}$ потому что 1 bit используется для записи ($+$, $-$) и одно значение используется для записи `NA_integer_`.

Если вы попытаетесь представить целое число больше этого значения, R вернет значения `NA`.

```{r warning}
.Machine$integer.max + 1L
```

Тем не менее, вы можете представить это значение (точно) с помощью числового вектора, затратив примерно в два раза больше памяти.

```{r}
as.numeric(.Machine$integer.max) + 1
```

Тоже самое верно для самого большого отрицательного числа

```{r}
-.Machine$integer.max - 1L
```

Для вещественных векторов R использует 64-битное представление. Это означает, что они могут держать
до $2^{64}$ значений точно. Однако некоторые из этих значений присваиваются специальным значениям.
такие как `-Inf`,` Inf`, `NA_real_` и` NaN`. Из справки для `double`:

> All R platforms are required to work with values conforming to the IEC 60559
> (also known as IEEE 754) standard. This basically works with a precision of
> 53 bits, and represents to that precision a range of absolute values from
> about 2e-308 to 2e+308. It also has special values `NaN` (many of them),
> plus and minus infinity
> and plus and minus zero (although R acts as if these are the same). There are
> also denormal(ized) (or subnormal) numbers with absolute values above or below
> the range given above but represented to less precision.

Детали представления с плавающей точкой и арифметики сложны, выходят за рамки этого вопроса и лучше обсуждаются в ссылках, представленных ниже.
Вещественное число может представлять числа в диапазоне около $\pm 2 \times 10 ^ {308} $, что
предоставляется в

```{r}
.Machine$double.xmax
```

Многие другие подробности реализации двойных векторов приведены в переменной `.Machine` (и ее документации).

```{r}
.Machine$double.base
```

количество бит, используемых для значимого (мантисса),

```{r}
.Machine$double.digits
```

количество битов, использованных в показателе степени,

```{r}
.Machine$double.exponent
```

и самые маленькие положительные и отрицательные числа не равные нулю,

```{r}
.Machine$double.eps
.Machine$double.neg.eps
```

-   Computerphile, "[Floating Point Numbers](https://www.youtube.com/watch?v=PZRI1IfStY0)"
-   <https://en.wikipedia.org/wiki/IEEE_754>
-   <https://en.wikipedia.org/wiki/Double-precision_floating-point_format>
-   "[Floating Point Numbers: Why floating-point numbers are needed](https://floating-point-gui.de/formats/fp/)"
-   Fabien Sanglard, "[Floating Point Numbers: Visually Explained](http://fabiensanglard.net/floating_point_visually_explained/)"
-   James Howard, "[How Many Floating Point Numbers are There?](https://jameshoward.us/2015/09/09/how-many-floating-point-numbers-are-there/)"
-   GeeksforGeeks, "[Floating Point Representation Basics](https://www.geeksforgeeks.org/floating-point-representation-basics/)"
-   Chris Hecker, "[Lets Go to the (Floating) Point](http://chrishecker.com/images/f/fb/Gdmfp.pdf)", *Game Developer*
-   Chua Hock-Chuan, [A Tutorial on Data Representation Integers, Floating-point Numbers, and Characters](http://www.ntu.edu.sg/home/ehchua/programming/java/datarepresentation.html)
-   John D. Cook, "[Anatomy of a floating point number](https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/)"
-   John D. Cook, "[Five Tips for Floating Point Programming](https://www.codeproject.com/Articles/29637/Five-Tips-for-Floating-Point-Programming)"


#### Упражнение 20.3.5.4
<div class="question">
Brainstorm at least four functions that allow you to convert a double to an integer. How do they differ? Be precise.
</div>

Для тестирования функций округления будем использовать тестовый набор:

```{r}
test <- seq(-3, 3, by = 0.5)
test
```

Стандарт [IEEE 754-2008](https://ru.wikipedia.org/wiki/IEEE_754-2008#Правила_округления) определяет пять правил округления. Первые два правила округляют к ближайшему значению, другие называются направленными округлениями.

* Округление к ближайшему (привязка к четному). Если два ближайших числа с плавающей точкой одинаково близки, то должно быть получено число с     чётной самой младшей цифрой. Это вариант по умолчанию для двоичной плавающей запятой и рекомендованный вариант по умолчанию для десятичного     числа.

* Округление к ближайшему (привязка к бесконечности). Если два ближайших числа с плавающей точкой одинаково близки, то должно быть получено       число с большим модулем.

* Округление к 0 --- направленное округление к нулю (также известное как усечение).

* Округление к $+\infty$ --- направленное округление к положительной бесконечности (также известное как округление вверх или потолок).

* Округление к $-\infty$ --- направленное округление к отрицательной бесконечности (также известное как округление вниз или пол).


| methods        | 0.5  | -0.5  | 1.5  | -1.5  |
| -------------- | ---- | ----- | ---- | ----- |
| к нулю         | 0    | 0     | 1    | -1    |
| от нуля        | 1    | -1    | 2    | -2    |
| к $+\infty$    | 1    | 0     | 2    | -1    |
| к $-\infty$    | 0    | -1    | 1    | -2    |
| чётное         | 0    | 0     | 2    | -2    |
| нечётное       | 1    | -1    | 1    | -1    |


Для округления, в R как и во многих других языках программирования используется стандарт IEEE. Это «округление до ближайшего, с привязкой к четному».

```{r}
round2 <- function(x, to_even = TRUE) {
  q <- x %/% 1    # Деление нацело
  r <- x %% 1     # Остаток отделения
  q + (r >= 0.5)  # Если r больше 0.5, то `TRUE` и соответственно прибавление единицы
}
test
round2(test)
round2(test, to_even = FALSE)
```

#### Упражнение 20.3.5.5
<div class="question">
What functions from the readr package allow you to turn a string into logical, integer, and double vector?
</div>

1. Функция `parse_logical()` анализирует логические значения, которые могут отображаться как варианты `ИСТИНА/ЛОЖЬ` или `1/0`.

```{r}
parse_logical(c("TRUE", "FALSE", "1", "0", "true", "t", "NA", "false", "f"))
```

2. Функция `parse_integer()` анализирует целочисленные значения

```{r}
parse_integer(c("1234", "000845", "NA", "345"))
```

Однако если в строке есть нечисловые символы, функция вызовет ошибку

```{r}
parse_integer(c("1000", "$1,000", "10.00"))
```

В таких случаях выручит функция `parse_number`

```{r}
parse_number(c("1.0", "3.5", "$1,000.00", "NA"))
```

3. И для анализа вещественных значений в векторе используется функция `parse_double()`

```{r}
parse_double(c("1.23", "23.646"))
```


### Использование атомарных векторов

#### Приведение типов

Существует два типа преобразования или __приведения__ одного вектора в другой

* Явное приведение --- при помощи функций `as.logical()`, `as.integer()`, `as.double()`, или `as.character()`

* Неявное преобразование происходит когда вектор используется в контексте, ожидающем вектор определённого типа. Например когда используется логический вектор с функцией суммирования.

`TRUE` конвертируется в `1` и соответственно `FALSE` в `0`. Это означает что суммирование логического вектора даёт количество истинных значений, а среднее логического вектора даёт долю таких значений.

```{r}
x <- sample(20, 100, replace = TRUE)
x
y <- x > 10
sum(y) 

mean(y)
```

Бывает и обратное использование --- от целочисленного типа к логическому.

```{r}
if (length(x)) {
  # do something
}
```

В данном случае 0 преобращуется в `FALSE`, а все остальные значения преобразуются в `TRUE`.
Такой подход усложняет чтение кода, лучше так не делать. 
Вместо этого лучше в явном виде выразить намерения `length(x) > 0`

Важно понимать что происходит, когда вектор создаётся при помощи функции `с()`.
Верх одерживает наиболее сложный тип.

```{r}
typeof(c(TRUE, 1L))

typeof(c(1L, 1.5))

typeof(c(1.5, "a"))
```

Атомарный вектор не может содержать смесь типов --- тип это семейство вектора в целом, а не его отдельных элементов.

#### Функции проверки типов

Для проверки типов вектора лучше использовать семейство векторов, которое приведено в таблице ниже

|                  | lgl | int | dbl | chr | list |
|------------------|-----|-----|-----|-----|------|
| `is_logical()`   |  x  |     |     |     |      |
| `is_integer()`   |     |  x  |     |     |      |
| `is_double()`    |     |     |  x  |     |      |
| `is_numeric()`   |     |  x  |  x  |     |      |
| `is_character()` |     |     |     |  x  |      |
| `is_atomic()`    |  x  |  x  |  x  |  x  |      |
| `is_list()`      |     |     |     |     |  x   |
| `is_vector()`    |  x  |  x  |  x  |  x  |  x   |

#### Скаляры и правила зацикливания

Более короткий вектор повторяется, или зацикливается, для достижения той же длины, что и более длинный.

В R основные математические операции работают с векторами.
Это означает, что при формировании простых математических вычислений никогда не придётся итерировать по элементам.

```{r}
sample(10) + 100
runif(10) > 0.5
```

В случае сложения векторов разной длинны, R расширяет, или как говорят __зацикливает__ --- многократно повторяет короткий вектор для достижения длинны более длинного.

```{r}
1:10 + 1:2
```

Этот процесс будет происходить без вывода дополнительных сообщений, за исключением случаев, когда короткий вектор не кратен длинному.

```{r}
1:10 + 1:3
```

НА самом деле это может привести к ошибке, поэтому в `tidyverse` для того чтобы зациклить, нужно указать это в явном виде

```{r, error = TRUE}
tibble(x = 1:4, y = 1:2)

tibble(x = 1:4, y = rep(1:2, 2))

tibble(x = 1:4, y = rep(1:2, each = 2))
```

#### Именование векторов

Векторам можно присваивать имена.

Можно в процессе создания вектора

```{r}
c(x = 1, y = 2, z = 4)
```

Можно постфактум при помощи `purrr::set_names()`:

```{r}
set_names(1:3, c("a", "b", "c"))
```

Именованные векторы удобнее всего использовать для извлечения элементов векторов

#### Извлечение элементов

До сих пор, для фильтрации строк мы использовали функцию `dplyr::filter()`.
Она работает только с tibble-фреймами, поэтому для векторов необходимо использовать новый инструмент.
Этим инструментом является `[]`, которая вызывается примерно так `x[a]`.
Для управления извлечением жлементов можно использовать одну из четырех структур

* Числовой вектор, содержащий только целые числа. Целые числа должны быть либо все положительны, либо все отрицательны, либо нулём.
Извлекаются элементы вектора, соответствующие указанным позициям

```{r}
x <- c("one", "two", "three", "four", "five")
x[c(3, 2, 5)]
```


В действительности, повторяя некоторые позиции, можно получить выходной вектор большей длины, чем входной.

```{r}
x[c(1, 1, 5, 5, 5, 2)]
```