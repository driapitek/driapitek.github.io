---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Подготовка данных

В этой части я узнаю о подготовке данных --- искусстве приведения исходных данных к виде, обеспечивающему возможность их визуализации и моделировании в среде R.

Без подготовки нельзя работать с данными. Это огромный пласт, который необходимо освоить

## Создание tibble-фреймов с помощью пакета `tibble`

### Введение
На протяжении всей книги, мы будем работать не с традиционными фреймами данных R (`data.frame`), а с так называемыми tibble-фреймами.

Так как R старенький язык, в нём многое устарело, но чтобы революционно что-то менять нужно потрать много времени, поэтому большая часть полезных функций реализуется пакетами. Это касается и фреймов данных, встроенный стандартный `data.frame` как говорят, не всегда удобный. Поэто при помощи пакета `tibble` реализовали возможность работать с упрощённой формой фреймов данных.

Получить более подробную информацию можно по команде `vignette("tibble")`

#### Необходимые ресурсы

Пакет `tibble` является частью ядра библиотеки `tidyverse`.

```{r}
library("tidyverse")
library("viridis")
library("forcats")
library("nycflights13")
library("Lahman")
library("dplyr")
```

### Создание tibble-фреймов 

Многие пакеты на выходе создают стандартный `data.frame`, частенько нужно будет приводить такие данные к виду тиббл. Это можно делать при помощи функции `as_tibble()`

```{r}
as_tibble(iris)
```

Можно создавать тиббл формат самому при помощи функции `tibble()`

```{r}
tibble(
  x = 1:5,
  y = 1,
  z = x ^ 2 + y
)
```

Тиббл не изменяет тип входных данных, не преобразует строки в факторы, не изменяет имена переменных и не создаёт имена строк.

Можно создавать  "несистемные" имена столбцов --- начинать с символов, пробелов, знаков.

```{r}
(tb <- tibble(
  `:)` = "smile", 
  ` ` = "space",
  `2000` = "number"
)) 
```

Чтобы задать непростое имя, следует, как видно выше, воспользоваться обратными апострофами. Точно такими же, которые открывают/закрывают чанк. 

Еще один способ задавать тиббл-фреймы. Пока не понятно зачем, но можно задавать следующим образом

```{r}
tribble(
  ~x, ~y, ~z,
  #--|--|----
  "a", 2, 3.6,
  "b", 1, 8.5
)
```

### Сравнение tibble-фреймов с фреймами `data.frame`

Различия двух типов касаются двух, описанных ниже операций

#### Вывод на печать

Tibble-фреймы спроектированы таким образом, чтобы случайно не перезагрузить консоль выводом данных. Они выводят на экран первые десять строк таблицы и столько столбцов, сколько поместится на экран. Это великое благо.

```{r}
tibble(
  a = lubridate::now() + runif(1e3) * 86400,
  b = lubridate::today() + runif(1e3) * 30,
  c = 1:1e3,
  d = runif(1e3),
  e = sample(letters, 1e3, replace = TRUE)
)
```

Полезной фичей иногда бывает указать напрямую сколько нужно отображать строк.

```{r}
nycflights13::flights %>% 
  print(n = 10, width = Inf) # Параметр width = Inf указывает что выводить нужно все столбцы
```

КРоме того можно управлять поведением при печати заданным по умолчанию, с помощью группы настроек `options`

* `options(tibble.print_max = n, tibble.print_min = m)`: если количество строк больше `m` вывести на печать лишь `n` строк. Чтобы всегда отображались все строки, используй вариант `ooptions(dplyr.print_min = Inf)`

* Чтобы всегда выводить на печать все столбцы, независимо от ширины экрана, используй `options(tibble.width = Inf)`

полный список возможных опций `packege?tibble`.

МОжно воспользоваться встроенным средством просмотра

```{r}
nycflights13::flights %>% 
  View()
```

#### Извлечение поднаборов

Если требуется извлечь одну переменную необходимо использовать операторы `$` и `[[`. Последний обеспечивает доступ к элементам по имени и по индексу, `$` --- только по имени, но требует ввода меньше символов.

```{r}
df <- tibble(
  x = runif(5),
  y = rnorm(5)
)
```

```{r}
# Извлечение элемента по имени
df$x

df[["x"]]
```

```{r}
# Извлечение элемента по индексу
df[[1]]
```

Применение этих операций в канале требует специального заместитеоя (`.`)

```{r}
df %>% .$x

df %>% .[[1]]
```

По сравнению с `data.frame` tibble-фреймы обладают большей строгостью --- они никогда не удовлетворяют частичным соответствиям и генерируют сообщение об ошибке, если столбец, к которому пробуют получить доступ не существует.

### Взаимодействие с разработанным ранее кодом

Некоторые функции не работают с tibble-фреймами, для таких функций необходимо перевести tibble обратно в `data.frame` с помощью функции `as.data.frame()`

```{r}
class(as.data.frame(tb))
```

#### Упражнение 10.6.1
<div class="question">
How can you tell if an object is a tibble? (Hint: try printing mtcars, which is a regular data frame). 
</div>

Для начала выведем привычный tibble-frame

```{r}
diamonds
```

Каждый столбец подписан типом данных --- это удобно.

Теперь выводим на печать объект `data.frame`

```{r}
mtcars
```

Вторым отличием является наличие именованных строк

```{r}
as_tibble(mtcars)
```

Такой способ узнать тип объекта, но является трудоемким. Для быстрой проверки типа объекта существует функция `class()`

```{r}
class(mtcars)

class(diamonds)
```

Если объект типа `data.frame`, то результатом запроса `class()` будет `"data.frame"`. Если объект класса tibble, то результатом будет `"tbl_df"     "tbl"        "data.frame"`

Больше информации в источнике [R для продвинутых](http://adv-r.had.co.nz/S3.html)

#### Упражнение 10.6.2
<div class="question">
Compare and contrast the following operations on a data.frame and equivalent tibble. What is different? Why might the default data frame behaviors cause you frustration?
</div>

```{r}
df <- data.frame(abc = 1, xyz = "a", yxq = 4)
df$x

df[, "xyz"]

df[, c("abc", "xyz")]
```

В первом примере, я его немного расширил --- программа возвращает содержимое столбца, который первый соответствует заданному параметру поиска. Т.е. первый столбец который содержит в названии `x`

Итак сопоставляем. Для начала меняем тип данных на тиббл
```{r}
tbl <- as.tibble(df)
```

Пример 1. Так как tibble очень требователен и имеет строгую нотацию, то в ответ на поиск заданного вектора, он ответит что не знает такого. С одной стороны это помогает экономить несколько нажатий клавиш, но с другой стороны это может стать причиной ошибки --- потому что могла иметься в виду другая переменная
```{r}
tbl$x
```

Пример 2. `data.frame`возвращает толькол значение указанношго аргумента. В то время как tibble возвращает полностью столбец.
```{r}
tbl[, "xyz"]
```

Пример 3. С больше чем с одной колонкой при использовании  `data.frame`, программа возвращает `data.frame`, но если колонка одна, то возвращается вектор. Вроде бы это прекрасно, но с другой стороны нужно предусматривать в случае чего такие ситуации в своём коде, а это чревато ошибкой.

```{r}
tbl[, c("abc", "xyz")]
```

#### Упражнение 10.6.3
<div class="question">
If you have the name of a variable stored in an object, e.g. `var <- "mpg"`, how can you extract the reference variable from a tibble?
</div>

```{r}
var <- "mpg"

# Используем двойные скобки, чтобы вытащить содержимое переменной
df[[var]]

# Не используем знак доллара $, потому что он будет искать
df$var
```


#### Упражнение 10.6.4
<div class="question">
Practice referring to non-syntactic names in the following data frame by:

1. Extracting the variable called 1.

1. Plotting a scatterplot of 1 vs 2.

1. Creating a new column called 3 which is 2 divided by 1.

1. Renaming the columns to one, two and three.
</div>

Итак попрактикуемся с вытаскиванием

```{r}
annoying <- tibble(
  `1` = 1:10,
  `2` = `1` * 2 + rnorm(length(`1`))
)
```

Извлекаем переменную
```{r}
# Извлекаем переменную 1 как вектор
annoying$"1"

# Эта запись возвращает тиббл-столбец
annoying[1]

# А эта запись возвращает вектор
annoying[[1]]
```

Строим точечный график для переменных `1` и `2`
```{r}
# Создаём точечный график либо вот так
ggplot(annoying, aes(x = annoying[[1]], y = annoying[[2]])) + 
  geom_point()

# Либо вот так
ggplot(annoying, aes(x = annoying$"1", y = annoying$"2")) + 
  geom_point()
```


