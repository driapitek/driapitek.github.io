---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Аккуратизация данных с помощью пакета `tidyr`

### Введение

Основное внимание в этой главе будет уделено регулярным выражениям

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(stringr)
```

### Основы работы со строками

Чтобы создать строку достаточно использовать кавычки

```{r}
string1 <- "Это уже строка"
string2 <- 'Это тоже строка, но внутри неё есть "кавычки"'
```

Если в строке есть спецсимволы их нужно "экранировать" апострофом или кавычками:

```{r}
double_qoute <- "\""
single_qoute <- '\''
ap_qoute <- "\\"
```

Со строками всё очень похоже на маркдаун --- печатное отображение строки, не то же самое что сама строка. Чтобы увидеть содержание строки можно использовать функцию `writeLines()`

```{r}
x <- c("\"", "\\")
x
writeLines(x)
```

Вот ещё частоиспользуемые спец.символы

* `"\n"` перевод строки

* `"\t"` табуляция

* остальные ищутся по справке `?'"'`

Чтобы создать символьный вектор, достаточно использовать функцию `с()`

```{r}
c("one", "two", "three")
```

#### Длина строки

В пакете `stringr` интуитивно понятные названия функций, все они начинаются с префикса `str_`. Например для проверки длины строки используется функция `str_length()`

```{r}
str_length(c("Я", "обожаю", "анализ", "данных", NA))
```

#### Объединение строк

Чтобы объединить две и больше строк используется `str_c()`, по аналогии с объединением символов в вектор

```{r}
str_c("x", "y")
```

Аргумент `sep` позволяет задать разделитель 

```{r}
str_c("x", "y", sep = "____,)))))")
```

Для вывода пропущенных значений использется функция `str_replace_na()`

```{r}
x <- c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

Интересное свойство --- зацикливание длинного вектора по длине короткого:

```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

Объекты длинной 0 опускаются. Этой возможностью особенно удобно пользоваться в сочетании с оператором `if`

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- FALSE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

Тут можно поиграться с выдачей, задавая значения дня. Для нуля и `NA` в выдаче не будет поздравления с днём рождения. Для всего остального соответственно будет

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- 8

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

Для свёртывания строк в одну используется `collapse()`

```{r}
str_c(c("x", "y", "z"), collapse = ", ")
```


#### Извлечение подстрок

Для этого используется `str_sub()`, у неё есть аргументы `start` и `end`

```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

# отрицательным числам соответствует отсчет с конца строки
str_sub(x, -3, -1)
```

А `str_sub()` можно использовать в форме присваивания для изменения строк

```{r}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```

#### Локали

* `str_to_lower()` --- делает все буквы прописными. 

* `str_to_upper()` --- переводит все буквы в верхний регистр.

* `str_to_title()` --- делает первую букву каждого слова прописной.

Не всё так просто с изменением регистров. Для разных языков действуют разные правила. Будь осторожен работая с преобразованием строк в разных языках.

#### Упражнение 14.2.5.1

<div class="question">
In code that doesn’t use stringr, you’ll often see `paste()` and `paste0()`. What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of `NA`?
</div>

Функция `paste()` по-умолчанию имеет разделитель пробел, а функция `paste0()` по умолчанию не имеет разделителя

```{r}
paste("агф", "фыуr")
paste0("fф34", "фыу")
```

В пакете `stringr()` на базовые функции похожа `str_c()`, она соответствует функции `paste0()`

```{r}
str_c("fф34", "фыу")
```

Однако `str_c()` и функции вставки обрабатывают NA по-разному. Функция `str_c()` распространяет NA, если какой-либо аргумент является пропущенным значением, он возвращает пропущенное значение. Это соответствует тому, как работает числовой R, например, `sum()`, `mean()`, обрабатывать пропущенные значения. Однако функции вставки преобразуют NA в строку «NA», а затем обрабатывают ее как любой другой символьный вектор --- жутко неудобно.

```{r}
paste0("fф34", "фыу", NA)
```


#### Упражнение 14.2.5.2

<div class="question">
In your own words, describe the difference between the sep and collapse arguments to str_c().
</div>

```{r}
i <- c("x", "y", "z")
str_c(i, collapse = ", ")
str_c("x", "y", "z", sep = ", ")
```

* `sep` --- это строка, вставленная между аргументами функции `str_c()`. Не работает с векторами

* `collapse` --- строка, используемая для разделения любых элементов символьного вектора на символьный вектор длины один. Работает с векторами

#### Упражнение 14.2.5.3

<div class="question">
Use `str_length()` and `str_sub()` to extract the middle character from a string. What will you do if the string has an even number of characters?
</div>

Если количество элементов нечётное, то чтобы найти средний элемент, нужно к максимальной длине строки прибавить единицу и разделить результат по полам --- ответ индекс среднего элемента.

Для того чтобы изъять один элемент не с конца, нужно началом и концом изъятия сделать одно и тоже число
```{r}
(x <- "1234567")
str_sub(x, (str_length(x)+1)/2, (str_length(x)+1)/2)
```

Если количество элементов чётное, то будем брать два значения, которые делят длину строки пополам. 
```{r}
(x <- "1234567")
str_sub(x, (str_length(x)+1)/2, (str_length(x)+2)/2)
```

Если такой вариант не подходит и нужно только одно значение, то в зависимости от задачи нужно выбрать либо большее либо меньшее значение


#### Упражнение 14.2.5.4
<div class="question">
What does `str_wrap()` do? When might you want to use it?
</div>

Функция `str_wrap()` переносит текст так, чтобы он умещался в пределах определенной ширины. Это полезно для переноса длинных строк текста для набора текста.

```{r}
x <- c("one, two, tree", "foo, bar")
str_wrap(x, indent = 5)
```

#### Упражнение 14.2.5.5
<div class="question">
What does `str_trim()` do? What’s the opposite of `str_trim()`?
</div>

Функция`str_trim()` удаляет пробел из строки.

```{r}
str_trim(" abc ")
str_trim(" abc ", side = "left")
str_trim(" abc ", side = "right")
```

Противоположностью `str_trim()` является `str_pad()`, которая добавляет символы с каждой стороны.

```{r}
str_pad("abc", 5, side = "both")
str_pad("abc", 4, side = "right")
str_pad("abc", 4, side = "left")
```

#### Упражнение 14.2.5.6
<div class="question">
Write a function that turns (e.g.) a vector `c("a", "b", "c")` into the string `"a, b, and c"`. 
Think carefully about what it should do if given a vector of length 0, 1, or 2.
</div>

На этом этапе я решаю задачу без знания функции --- то есть я решу в лоб, это будет не функция. 

Я вернусь сюда, когда научусь делать функции (привет Стас из будущего)

```{r}
foo <- c("a", "b", "c")

str_c(foo[[1]], ", ", foo[[2]], ", ", "and", " ", foo[[3]])
```

Функция должна работать следующим образом

* Если функции будет передаваться нулевой вектор, она должна возвращать пустую строку

* Если функции будет передаваться вектор длинной `1`, то функция должна возвращать строку с одни этим же элементом

* Если функции будет передаваться вектор длинной `2`, то функция должна вставлять между этими двумя элементами `" and "`

* Если функции будет передаваться вектор длинной больше чем `2`, то функция должна перечислять все элементы вектора через запятую, и перед последним элементом вставить `" and "`

























### Поиск соответствия шаблонам с помощью регулярных выражений

Регулярные выражения это просто и лаконично, нужно только понять принцип. Итак начнём

#### Базовые соответствия

Простейшие шаблоны в точности соответствуют строкам.

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "")  # Покажет любой первый символ
str_view(x, "a") # Покажет соответсвия
str_view(x, ".a.") # Покажет заданную букву в окружении любых символов
```

Дальше по тексту будем следовать правилу

* регулярные выражения будут записываться `\.` 

* Строки представляющие эти выражения будут записываться как `"\\."`

Экранируем символ `\` вот так `\\\\`
```{r}
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
```

##### Упражнение 14.3.1.1.1
<div class="question">
Explain why each of these strings don’t match a `\`: `"\"`, `"\\"`, `"\\\"`.
</div>

* `"\"` --- Это будет экранировать следующий символ в строке R.

* `"\\"` --- Это разрешит \ в регулярном выражении, что будет экранировать следующий символ в регулярном выражении.

* `"\\\"` --- первые две обратные косые черты будут преобразованы в буквальную обратную косую черту в регулярном выражении, третья будет экранирована следующим символом. Таким образом, в регулярном выражении это будет экранированный символ

##### Упражнение 14.3.1.1.2
<div class="question">
How would you match the sequence `"'\`?
</div>

```{r}
x <- "\"'\\"
writeLines(x)
str_view(x, "\"'\\\\", match = TRUE)
```

Экранируем символ двойной кавычки. Экранировать одинарную кавычку не нужно. Чтобы показать одинарный слэш, нужно ввести четыры.

##### Упражнение 14.3.1.1.2
<div class="question">
What patterns will the regular expression `\..\..\..` match? 
How would you represent it as a string?
</div>

```{r}
x <- "\\..\\..\\.."
writeLines(x)
str_view(x, "\\\\\\.\\.\\\\\\.\\.\\\\\\.\\.", match = TRUE)
```


##### Якоря

Якорь --- позиционная привязка

* `^` ---  совпадает с началом строки

* `$` --- совпадает с концом строки

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
```

Мнемоническое првавило: ВЫсокое положение `^` в иерархии всегда приводит к деньгам `$`

Чтобы принудить регулярное выражение к совпадениям только с целой строкой необходимо использовать оба якоря 

```{r}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
```

Для нахождения совпадений на границе слов можно использовать `\b`

##### Упражнение 14.3.2.1.1
<div class="question">
How would you match the literal string `"$^$"`?
</div>

```{r}
x <- "\"$^$\""
writeLines(x)
str_view(x, "\"\\$\\^\\$\"")
```

##### Упражнение 14.3.2.1.2
<div class="question">
Given the corpus of common words in `stringr::words`, create regular expressions that find all words that:

* Start with “y”.

* End with “x”

* Are exactly three letters long. (Don’t cheat by using `str_length()`!)

* Have seven letters or more.

Since this list is long, you might want to use the match argument to `str_view()` to show only the matching or non-matching words.
</div>

* начинаются с `y`

```{r}
str_view(stringr::words, "^y", match = TRUE)
```

* оканчиваются на `x`

```{r}
str_view(stringr::words, "x$", match = TRUE)
```

* состоят ровно из трёх букв
  
```{r}
str_view(stringr::words, "^...$", match = TRUE)
```

* состоят из семи или более букв
  
```{r}
str_view(stringr::words, "^.......", match = TRUE)
```


##### Символьные классы и чередования

* `.` --- совпадает с любым символом

* `\d` --- совпадает с любой цифрой. ЧТобы экранировать нужно использовать двойной слэш `\\d`

* `\s` --- совпадает с любым пробельным символом (пробел, табуляция, перевод строки) `\\s`

* `[abc]` --- совпадает с `a`, `b` или `c`

* `[^abc]` --- совпадает с любыми символами кроме `a`, `b` или `c`

Чередование обеспечивает возможность выбора альтернативов шаблона.

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

##### Упражнение 14.3.3.1.1
<div class="question">
Create regular expressions to find all words that:

* Start with a vowel.

* That only contain consonants. (Hint: thinking about matching “not”-vowels.)

* End with ed, but not with eed.

* End with ing or ise.
</div>

* Начинается с гласной
```{r}
str_view(stringr::words, "^[aeiou]", match = TRUE)
```

* Сoдержат только согласные
```{r}
str_view(stringr::words, "^[^aeiou]+$", match = TRUE)
```

* Оканчивается на `ed`, но не на `eed`.
```{r}
str_view(stringr::words, "[^e]ed$", match = TRUE)
```

* Оканчивается на `ing` или `ize`.
```{r}
str_view(stringr::words, "i(ng|ze)$", match = TRUE)
```

##### Упражнение 14.3.3.1.2
<div class="question">
Empirically verify the rule “i before e except after c”.
</div>

Правило гласит --- “i” пишется перед “e” (исключение — после “c”). Сначала проверяем слова, которые удовлетворяют правилу:

```{r}
str_view(stringr::words, "(cei|[^c]ie)", match = TRUE)
```

Теперь поищем слова, которые не соответствуют правилу:
```{r}
str_view(stringr::words, "(cie|[^c]ei)", match = TRUE)
```

##### Упражнение 14.3.3.1.3
<div class="question">
Is “q” always followed by a “u”?
</div>

В представленных словах других комбинаций не найдено
```{r}
str_view(stringr::words, "q[^u]", match = TRUE)
```

##### Упражнение 14.3.3.1.4
<div class="question">
Write a regular expression that matches a word if it’s probably written in British English, not American English.
</div>

С такими упраджнениями заодно и английский подтянешь. 
В общем случае сложно выполнить это упражнение, и может потребоваться словарь. 
Немного погуглив, появилось несколько эвристических соображений, которые должны учитывать некоторые распространенные случаи. 

Британский английский имеет тенденцию использовать следующее:

* “ou” в отличае от американского “o”

* “ae” и “oe” в отличае от американского  “a” и “o”

* слова заканчиваются на `ise` в отличае от американского `ize`

* слова заканчиваются на `yse`

Учитывая это, можно получить следующее регулярное выражение `ou|ise$|ae|oe|yse$` (или или или или)

##### Упражнение 14.3.3.1.5
<div class="question">
Create a regular expression that will match telephone numbers as commonly written in your country.
</div>

В России нет четко регламентированного стандарта, но есть общие правила, которых придерживаюсь и я. Подробно о рекомендуемых правилах записи телефонных номеров рассказал дизайнер Василий Никоноров в [своей статье](http://steinebel.ru/?go=all/phone-numbers/)

![alt text](img/phone-nums-rule.png)

Для записи телефонного номера, подойдёт следующее регулярное выражение: `+`

В представленных словах других комбинаций не найдено
```{r}
x <- c("+7 987 654-32-10", "+7(987)654-32-10", "8 (987) 654-32-10")
str_view(x, "\\+\\d\\s\\d\\d\\d\\s\\d\\d\\d-\\d\\d-\\d\\d")
```

##### Повторения

Сколько раз может встречаться *предшествующий* символ или выражение, чтобы совпадение считалось достигнутым 

* `?`: 0 или 1

* `+`: 1 или больше

* `*`: 0 или больше

```{r}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, 'C[LX]+')
```

Кроме того можно определить точное количество совпадений 

* `{n}`: точно n раз

* `{n,}`: n или больше раз

* `{,m}`: самое большее m раз

* `{n,m}`: между n и m раз

```{r}
str_view(x, "C{2}")

str_view(x, "C{2,}")

str_view(x, "C{2,3}")
```

Полезно знать, что алгоритм поиска жадный, чтобы сделать его ленивым нужно добавить в конец выражения символ `?`

##### Упражнение 14.3.3.1.1
<div class="question">
Describe the equivalents of `?`, `+`, `*` in `{m,n}` form.
</div>

* `?`: 0 или 1 `{0,1}`

* `+`: 1 или больше `{1,}`

* `*`: 0 или больше `{0,}`


##### Упражнение 14.3.3.1.2
<div class="question">
Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.)

* `^.*$`

* `"\\{.+\\}"`

* `\d{4}-\d{2}-\d{2}`

* `"\\\\{4}"`
</div>

* Любой символ встречается один или более раз --- регулярное выражение 

```{r}
str_view(c("dog", "$1.23", "lorem ipsum"), "^.*$")
```


* 