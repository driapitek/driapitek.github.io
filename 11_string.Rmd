---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Аккуратизация данных с помощью пакета `tidyr`

### Введение

Основное внимание в этой главе будет уделено регулярным выражениям

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(stringr)
```

### Основы работы со строками

Чтобы создать строку достаточно использовать кавычки

```{r}
string1 <- "Это уже строка"
string2 <- 'Это тоже строка, но внутри неё есть "кавычки"'
```

Если в строке есть спецсимволы их нужно "экранировать" апострофом или кавычками:

```{r}
double_qoute <- "\""
single_qoute <- '\''
ap_qoute <- "\\"
```

Со строками всё очень похоже на маркдаун --- печатное отображение строки, не то же самое что сама строка. Чтобы увидеть содержание строки можно использовать функцию `writeLines()`

```{r}
x <- c("\"", "\\")
x
writeLines(x)
```

Вот ещё частоиспользуемые спец.символы

* `"\n"` перевод строки

* `"\t"` табуляция

* остальные ищутся по справке `?'"'`

Чтобы создать символьный вектор, достаточно использовать функцию `с()`

```{r}
c("one", "two", "three")
```

#### Длина строки

В пакете `stringr` интуитивно понятные названия функций, все они начинаются с префикса `str_`. Например для проверки длины строки используется функция `str_length()`

```{r}
str_length(c("Я", "обожаю", "анализ", "данных", NA))
```

#### Объединение строк

Чтобы объединить две и больше строк используется `str_c()`, по аналогии с объединением символов в вектор

```{r}
str_c("x", "y")
```

Аргумент `sep` позволяет задать разделитель 

```{r}
str_c("x", "y", sep = "____,)))))")
```

Для вывода пропущенных значений использется функция `str_replace_na()`

```{r}
x <- c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

Интересное свойство --- зацикливание длинного вектора по длине короткого:

```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

Объекты длинной 0 опускаются. Этой возможностью особенно удобно пользоваться в сочетании с оператором `if`

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- FALSE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

Тут можно поиграться с выдачей, задавая значения дня. Для нуля и `NA` в выдаче не будет поздравления с днём рождения. Для всего остального соответственно будет

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- 8

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

Для свёртывания строк в одну используется `collapse()`

```{r}
str_c(c("x", "y", "z"), collapse = ", ")
```


#### Извлечение подстрок

Для этого используется `str_sub()`, у неё есть аргументы `start` и `end`

```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

# отрицательным числам соответствует отсчет с конца строки
str_sub(x, -3, -1)
```

А `str_sub()` можно использовать в форме присваивания для изменения строк

```{r}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```

#### Локали

* `str_to_lower()` --- делает все буквы прописными. 

* `str_to_upper()` --- переводит все буквы в верхний регистр.

* `str_to_title()` --- делает первую букву каждого слова прописной.

Не всё так просто с изменением регистров. Для разных языков действуют разные правила. Будь осторожен работая с преобразованием строк в разных языках.

#### Упражнение 14.2.5.1

<div class="question">
In code that doesn’t use stringr, you’ll often see `paste()` and `paste0()`. What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of `NA`?
</div>

Функция `paste()` по-умолчанию имеет разделитель пробел, а функция `paste0()` по умолчанию не имеет разделителя

```{r}
paste("агф", "фыуr")
paste0("fф34", "фыу")
```

В пакете `stringr()` на базовые функции похожа `str_c()`, она соответствует функции `paste0()`

```{r}
str_c("fф34", "фыу")
```

Однако `str_c()` и функции вставки обрабатывают NA по-разному. Функция `str_c()` распространяет NA, если какой-либо аргумент является пропущенным значением, он возвращает пропущенное значение. Это соответствует тому, как работает числовой R, например, `sum()`, `mean()`, обрабатывать пропущенные значения. Однако функции вставки преобразуют NA в строку «NA», а затем обрабатывают ее как любой другой символьный вектор --- жутко неудобно.

```{r}
paste0("fф34", "фыу", NA)
```


#### Упражнение 14.2.5.2

<div class="question">
In your own words, describe the difference between the sep and collapse arguments to str_c().
</div>

```{r}
i <- c("x", "y", "z")
str_c(i, collapse = ", ")
str_c("x", "y", "z", sep = ", ")
```

* `sep` --- это строка, вставленная между аргументами функции `str_c()`. Не работает с векторами

* `collapse` --- строка, используемая для разделения любых элементов символьного вектора на символьный вектор длины один. Работает с векторами

#### Упражнение 14.2.5.3

<div class="question">
Use `str_length()` and `str_sub()` to extract the middle character from a string. What will you do if the string has an even number of characters?
</div>

Если количество элементов нечётное, то чтобы найти средний элемент, нужно к максимальной длине строки прибавить единицу и разделить результат по полам --- ответ индекс среднего элемента.

Для того чтобы изъять один элемент не с конца, нужно началом и концом изъятия сделать одно и тоже число
```{r}
(x <- "1234567")
str_sub(x, (str_length(x)+1)/2, (str_length(x)+1)/2)
```

Если количество элементов чётное, то будем брать два значения, которые делят длину строки пополам. 
```{r}
(x <- "1234567")
str_sub(x, (str_length(x)+1)/2, (str_length(x)+2)/2)
```

Если такой вариант не подходит и нужно только одно значение, то в зависимости от задачи нужно выбрать либо большее либо меньшее значение


#### Упражнение 14.2.5.4
<div class="question">
What does `str_wrap()` do? When might you want to use it?
</div>

Функция `str_wrap()` переносит текст так, чтобы он умещался в пределах определенной ширины. Это полезно для переноса длинных строк текста для набора текста.

```{r}
x <- c("one, two, tree", "foo, bar")
str_wrap(x, indent = 5)
```

#### Упражнение 14.2.5.5
<div class="question">
What does `str_trim()` do? What’s the opposite of `str_trim()`?
</div>

Функция`str_trim()` удаляет пробел из строки.

```{r}
str_trim(" abc ")
str_trim(" abc ", side = "left")
str_trim(" abc ", side = "right")
```

Противоположностью `str_trim()` является `str_pad()`, которая добавляет символы с каждой стороны.

```{r}
str_pad("abc", 5, side = "both")
str_pad("abc", 4, side = "right")
str_pad("abc", 4, side = "left")
```

#### Упражнение 14.2.5.6
<div class="question">
Write a function that turns (e.g.) a vector `c("a", "b", "c")` into the string `"a, b, and c"`. 
Think carefully about what it should do if given a vector of length 0, 1, or 2.
</div>

```{r}
foo <- c("a", "b", "c")
```
















### Поиск соответствия шаблонам с помощью регулярных выражений

Регулярные выражения это просто и лаконично, нужно только понять принцип. Итак начнём

#### Базовые соответствия

Простейшие шаблоны в точности соответствуют строкам.

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "")  # Покажет любой первый символ
str_view(x, "a") # Покажет соответсвия
str_view(x, ".a.") # Покажет заданную букву в окружении любых символов
```

Дальше по тексту будем следовать правилу

* регулярные выражения будут записываться `\.` 

* Строки представляющие эти выражения будут записываться как `"\\."`

Экранируем символ `\` вот так `\\\\`
```{r}
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
```

#### Упражнение 14.3.1.1
<div class="question">
Explain why each of these strings don’t match a `\`: `"\"`, `"\\"`, `"\\\"`.
</div>

* `"\"` --- Это будет экранировать следующий символ в строке R.

* `"\\"` --- Это разрешит \ в регулярном выражении, что будет экранировать следующий символ в регулярном выражении.

* `"\\\"` --- первые две обратные косые черты будут преобразованы в буквальную обратную косую черту в регулярном выражении, третья будет экранирована следующим символом. Таким образом, в регулярном выражении это будет экранированный символ
