---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Аккуратизация данных с помощью пакета `tidyr`

### Введение

Основное внимание в этой главе будет уделено регулярным выражениям

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(stringr)
```

### Основы работы со строками

Чтобы создать строку достаточно использовать кавычки

```{r}
string1 <- "Это уже строка"
string2 <- 'Это тоже строка, но внутри неё есть "кавычки"'
```

Если в строке есть спецсимволы их нужно "экранировать" апострофом или кавычками:

```{r}
double_qoute <- "\""
single_qoute <- '\''
ap_qoute <- "\\"
```

Со строками всё очень похоже на маркдаун --- печатное отображение строки, не то же самое что сама строка. Чтобы увидеть содержание строки можно использовать функцию `writeLines()`

```{r}
x <- c("\"", "\\")
x
writeLines(x)
```

Вот ещё частоиспользуемые спец.символы

* `"\n"` перевод строки

* `"\t"` табуляция

* остальные ищутся по справке `?'"'`

Чтобы создать символьный вектор, достаточно использовать функцию `с()`

```{r}
c("one", "two", "three")
```

#### Длина строки

В пакете `stringr` интуитивно понятные названия функций, все они начинаются с префикса `str_`. Например для проверки длины строки используется функция `str_length()`

```{r}
str_length(c("Я", "обожаю", "анализ", "данных", NA))
```

#### Объединение строк

Чтобы объединить две и больше строк используется `str_c()`, по аналогии с объединением символов в вектор

```{r}
str_c("x", "y")
```

Аргумент `sep` позволяет задать разделитель 

```{r}
str_c("x", "y", sep = "____,)))))")
```

Для вывода пропущенных значений использется функция `str_replace_na()`

```{r}
x <- c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

Интересное свойство --- зацикливание длинного вектора по длине короткого:

```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

Объекты длинной 0 опускаются. Этой возможностью особенно удобно пользоваться в сочетании с оператором `if`

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- FALSE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

Тут можно поиграться с выдачей, задавая значения дня. Для нуля и `NA` в выдаче не будет поздравления с днём рождения. Для всего остального соответственно будет

```{r}
name <- "Hadley"
time_of_day <- "morning"
birthday <- 8

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
```

Для свёртывания строк в одну используется `collapse()`

```{r}
str_c(c("x", "y", "z"), collapse = ", ")
```


#### Извлечение подстрок

Для этого используется `str_sub()`, у неё есть аргументы `start` и `end`

```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

# отрицательным числам соответствует отсчет с конца строки
str_sub(x, -3, -1)
```

А `str_sub()` можно использовать в форме присваивания для изменения строк

```{r}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```

#### Локали

* `str_to_lower()` --- делает все буквы прописными. 

* `str_to_upper()` --- переводит все буквы в верхний регистр.

* `str_to_title()` --- делает первую букву каждого слова прописной.

Не всё так просто с изменением регистров. Для разных языков действуют разные правила. Будь осторожен работая с преобразованием строк в разных языках.

#### Упражнение 14.2.5.1

<div class="question">
In code that doesn’t use stringr, you’ll often see `paste()` and `paste0()`. What’s the difference between the two functions? What stringr function are they equivalent to? How do the functions differ in their handling of `NA`?
</div>

Функция `paste()` по-умолчанию имеет разделитель пробел, а функция `paste0()` по умолчанию не имеет разделителя

```{r}
paste("агф", "фыуr")
paste0("fф34", "фыу")
```

В пакете `stringr()` на базовые функции похожа `str_c()`, она соответствует функции `paste0()`

```{r}
str_c("fф34", "фыу")
```

Однако `str_c()` и функции вставки обрабатывают NA по-разному. Функция `str_c()` распространяет NA, если какой-либо аргумент является пропущенным значением, он возвращает пропущенное значение. Это соответствует тому, как работает числовой R, например, `sum()`, `mean()`, обрабатывать пропущенные значения. Однако функции вставки преобразуют NA в строку «NA», а затем обрабатывают ее как любой другой символьный вектор --- жутко неудобно.

```{r}
paste0("fф34", "фыу", NA)
```


#### Упражнение 14.2.5.2

<div class="question">
In your own words, describe the difference between the sep and collapse arguments to str_c().
</div>

```{r}
i <- c("x", "y", "z")
str_c(i, collapse = ", ")
str_c("x", "y", "z", sep = ", ")
```

* `sep` --- это строка, вставленная между аргументами функции `str_c()`. Не работает с векторами

* `collapse` --- строка, используемая для разделения любых элементов символьного вектора на символьный вектор длины один. Работает с векторами

#### Упражнение 14.2.5.3

<div class="question">
Use `str_length()` and `str_sub()` to extract the middle character from a string. What will you do if the string has an even number of characters?
</div>

Если количество элементов нечётное, то чтобы найти средний элемент, нужно к максимальной длине строки прибавить единицу и разделить результат по полам --- ответ индекс среднего элемента.

Для того чтобы изъять один элемент не с конца, нужно началом и концом изъятия сделать одно и тоже число
```{r}
(x <- "1234567")
str_sub(x, (str_length(x)+1)/2, (str_length(x)+1)/2)
```

Если количество элементов чётное, то будем брать два значения, которые делят длину строки пополам. 
```{r}
(x <- "1234567")
str_sub(x, (str_length(x)+1)/2, (str_length(x)+2)/2)
```

Если такой вариант не подходит и нужно только одно значение, то в зависимости от задачи нужно выбрать либо большее либо меньшее значение


#### Упражнение 14.2.5.4
<div class="question">
What does `str_wrap()` do? When might you want to use it?
</div>

Функция `str_wrap()` переносит текст так, чтобы он умещался в пределах определенной ширины. Это полезно для переноса длинных строк текста для набора текста.

```{r}
x <- c("one, two, tree", "foo, bar")
str_wrap(x, indent = 5)
```

#### Упражнение 14.2.5.5
<div class="question">
What does `str_trim()` do? What’s the opposite of `str_trim()`?
</div>

Функция`str_trim()` удаляет пробел из строки.

```{r}
str_trim(" abc ")
str_trim(" abc ", side = "left")
str_trim(" abc ", side = "right")
```

Противоположностью `str_trim()` является `str_pad()`, которая добавляет символы с каждой стороны.

```{r}
str_pad("abc", 5, side = "both")
str_pad("abc", 4, side = "right")
str_pad("abc", 4, side = "left")
```

#### Упражнение 14.2.5.6
<div class="question">
Write a function that turns (e.g.) a vector `c("a", "b", "c")` into the string `"a, b, and c"`. 
Think carefully about what it should do if given a vector of length 0, 1, or 2.
</div>

На этом этапе я решаю задачу без знания функции --- то есть я решу в лоб, это будет не функция. 

Я вернусь сюда, когда научусь делать функции (привет Стас из будущего)

```{r}
foo <- c("a", "b", "c")

str_c(foo[[1]], ", ", foo[[2]], ", ", "and", " ", foo[[3]])
```

Функция должна работать следующим образом

* Если функции будет передаваться нулевой вектор, она должна возвращать пустую строку

* Если функции будет передаваться вектор длинной `1`, то функция должна возвращать строку с одни этим же элементом

* Если функции будет передаваться вектор длинной `2`, то функция должна вставлять между этими двумя элементами `" and "`

* Если функции будет передаваться вектор длинной больше чем `2`, то функция должна перечислять все элементы вектора через запятую, и перед последним элементом вставить `" and "`

























### Поиск соответствия шаблонам с помощью регулярных выражений

Регулярные выражения это просто и лаконично, нужно только понять принцип. Итак начнём

#### Базовые соответствия

Простейшие шаблоны в точности соответствуют строкам.

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "")  # Покажет любой первый символ
str_view(x, "a") # Покажет соответсвия
str_view(x, ".a.") # Покажет заданную букву в окружении любых символов
```

Дальше по тексту будем следовать правилу

* регулярные выражения будут записываться `\.` 

* Строки представляющие эти выражения будут записываться как `"\\."`

Экранируем символ `\` вот так `\\\\`
```{r}
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
```

##### Упражнение 14.3.1.1.1
<div class="question">
Explain why each of these strings don’t match a `\`: `"\"`, `"\\"`, `"\\\"`.
</div>

* `"\"` --- Это будет экранировать следующий символ в строке R.

* `"\\"` --- Это разрешит \ в регулярном выражении, что будет экранировать следующий символ в регулярном выражении.

* `"\\\"` --- первые две обратные косые черты будут преобразованы в буквальную обратную косую черту в регулярном выражении, третья будет экранирована следующим символом. Таким образом, в регулярном выражении это будет экранированный символ

##### Упражнение 14.3.1.1.2
<div class="question">
How would you match the sequence `"'\`?
</div>

```{r}
x <- "\"'\\"
writeLines(x)
str_view(x, "\"'\\\\", match = TRUE)
```

Экранируем символ двойной кавычки. Экранировать одинарную кавычку не нужно. Чтобы показать одинарный слэш, нужно ввести четыры.

##### Упражнение 14.3.1.1.2
<div class="question">
What patterns will the regular expression `\..\..\..` match? 
How would you represent it as a string?
</div>

```{r}
x <- "\\..\\..\\.."
writeLines(x)
str_view(x, "\\\\\\.\\.\\\\\\.\\.\\\\\\.\\.", match = TRUE)
```


##### Якоря

Якорь --- позиционная привязка

* `^` ---  совпадает с началом строки

* `$` --- совпадает с концом строки

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
```

Мнемоническое првавило: ВЫсокое положение `^` в иерархии всегда приводит к деньгам `$`

Чтобы принудить регулярное выражение к совпадениям только с целой строкой необходимо использовать оба якоря 

```{r}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
```

Для нахождения совпадений на границе слов можно использовать `\b`

##### Упражнение 14.3.2.1.1
<div class="question">
How would you match the literal string `"$^$"`?
</div>

```{r}
x <- "\"$^$\""
writeLines(x)
str_view(x, "\"\\$\\^\\$\"")
```

##### Упражнение 14.3.2.1.2
<div class="question">
Given the corpus of common words in `stringr::words`, create regular expressions that find all words that:

* Start with “y”.

* End with “x”

* Are exactly three letters long. (Don’t cheat by using `str_length()`!)

* Have seven letters or more.

Since this list is long, you might want to use the match argument to `str_view()` to show only the matching or non-matching words.
</div>

* начинаются с `y`

```{r}
str_view(stringr::words, "^y", match = TRUE)
```

* оканчиваются на `x`

```{r}
str_view(stringr::words, "x$", match = TRUE)
```

* состоят ровно из трёх букв
  
```{r}
str_view(stringr::words, "^...$", match = TRUE)
```

* состоят из семи или более букв
  
```{r}
str_view(stringr::words, "^.......", match = TRUE)
```


##### Символьные классы и чередования

* `.` --- совпадает с любым символом

* `\d` --- совпадает с любой цифрой. ЧТобы экранировать нужно использовать двойной слэш `\\d`

* `\s` --- совпадает с любым пробельным символом (пробел, табуляция, перевод строки) `\\s`

* `[abc]` --- совпадает с `a`, `b` или `c`

* `[^abc]` --- совпадает с любыми символами кроме `a`, `b` или `c`

Чередование обеспечивает возможность выбора альтернативов шаблона.

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

##### Упражнение 14.3.3.1.1
<div class="question">
Create regular expressions to find all words that:

* Start with a vowel.

* That only contain consonants. (Hint: thinking about matching “not”-vowels.)

* End with ed, but not with eed.

* End with ing or ise.
</div>

* Начинается с гласной
```{r}
str_view(stringr::words, "^[aeiou]", match = TRUE)
```

* Сoдержат только согласные
```{r}
str_view(stringr::words, "^[^aeiou]+$", match = TRUE)
```

* Оканчивается на `ed`, но не на `eed`.
```{r}
str_view(stringr::words, "[^e]ed$", match = TRUE)
```

* Оканчивается на `ing` или `ize`.
```{r}
str_view(stringr::words, "i(ng|ze)$", match = TRUE)
```

##### Упражнение 14.3.3.1.2
<div class="question">
Empirically verify the rule “i before e except after c”.
</div>

Правило гласит --- “i” пишется перед “e” (исключение — после “c”). Сначала проверяем слова, которые удовлетворяют правилу:

```{r}
str_view(stringr::words, "(cei|[^c]ie)", match = TRUE)
```

Теперь поищем слова, которые не соответствуют правилу:
```{r}
str_view(stringr::words, "(cie|[^c]ei)", match = TRUE)
```

##### Упражнение 14.3.3.1.3
<div class="question">
Is “q” always followed by a “u”?
</div>

В представленных словах других комбинаций не найдено
```{r}
str_view(stringr::words, "q[^u]", match = TRUE)
```

##### Упражнение 14.3.3.1.4
<div class="question">
Write a regular expression that matches a word if it’s probably written in British English, not American English.
</div>

С такими упраджнениями заодно и английский подтянешь. 
В общем случае сложно выполнить это упражнение, и может потребоваться словарь. 
Немного погуглив, появилось несколько эвристических соображений, которые должны учитывать некоторые распространенные случаи. 

Британский английский имеет тенденцию использовать следующее:

* “ou” в отличае от американского “o”

* “ae” и “oe” в отличае от американского  “a” и “o”

* слова заканчиваются на `ise` в отличае от американского `ize`

* слова заканчиваются на `yse`

Учитывая это, можно получить следующее регулярное выражение `ou|ise$|ae|oe|yse$` (или или или или)

##### Упражнение 14.3.3.1.5
<div class="question">
Create a regular expression that will match telephone numbers as commonly written in your country.
</div>

В России нет четко регламентированного стандарта, но есть общие правила, которых придерживаюсь и я. Подробно о рекомендуемых правилах записи телефонных номеров рассказал дизайнер Василий Никоноров в [своей статье](http://steinebel.ru/?go=all/phone-numbers/)

![alt text](img/phone-nums-rule.png)

Для записи телефонного номера, подойдёт следующее регулярное выражение: `+`

В представленных словах других комбинаций не найдено
```{r}
x <- c("+7 987 654-32-10", "+7(987)654-32-10", "8 (987) 654-32-10")
str_view(x, "\\+\\d\\s\\d\\d\\d\\s\\d\\d\\d-\\d\\d-\\d\\d")
```

##### Повторения

Сколько раз может встречаться *предшествующий* символ или выражение, чтобы совпадение считалось достигнутым 

* `?`: 0 или 1

* `+`: 1 или больше

* `*`: 0 или больше

```{r}
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, 'C[LX]+')
```

Кроме того можно определить точное количество совпадений 

* `{n}`: точно n раз

* `{n,}`: n или больше раз

* `{,m}`: самое большее m раз

* `{n,m}`: между n и m раз

```{r}
str_view(x, "C{2}")

str_view(x, "C{2,}")

str_view(x, "C{2,3}")
```

Полезно знать, что алгоритм поиска жадный, чтобы сделать его ленивым нужно добавить в конец выражения символ `?`

##### Упражнение 14.3.3.1.1
<div class="question">
Describe the equivalents of `?`, `+`, `*` in `{m,n}` form.
</div>

* `?`: 0 или 1 `{0,1}`

* `+`: 1 или больше `{1,}`

* `*`: 0 или больше `{0,}`


##### Упражнение 14.3.3.1.2
<div class="question">
Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.)

* `^.*$`

* `"\\{.+\\}"`

* `\d{4}-\d{2}-\d{2}`

* `"\\\\{4}"`
</div>

* `^.*$` Любой символ встречается ноль или более раз, другими словами --- это регулярное выражение ищет строку любой длины. Это регулярное выражение, его нужно экранировать

```{r}
str_view(c("cat", "$3.21", "data science"), "^.*$")
```

* `"\\{.+\\}"` Любой символ в курвах который встречается один или больше раз. Это строка описывающая регулярное выражение, не нужно экранировать

```{r}
str_view(c("{cat}", "${3.21}", "data science", "{}"), "\\{.+\\}")
```

* `\d{4}-\d{2}-\d{2}` Любое 4 значное число минус двузначное минус двузначное. Это регулярное выражение, его нужно экранировать

```{r}
str_view(c("2352-34-12", "232-34-12", "2352 34 12", "22-33-1239"), "\\d{4}-\\d{2}-\\d{2}")
```

* `"\\\\{4}"` Бэкслэш который встречается 4 раза. Это строка описывающая регулярное выражение, не нужно экранировать

```{r}
str_view(c("2352-34-12", "\\\\\\\\", "2352 34 12", " "), "\\\\{4}")
```

##### Упражнение 14.3.3.1.3
<div class="question">
Create regular expressions to find all words that:

* Start with three consonants.

* Have three or more vowels in a row.

* Have two or more vowel-consonant pairs in a row.
</div>


##### Упражнение 14.3.3.1.4
<div class="question">
Solve the beginner regexp crosswords at <https://regexcrossword.com/challenges/beginner>
</div>

Продолжаем постигать науку регулярных выражений. Идет со скрипом.

Решения я выкладываю в [репозиторий](https://github.com/driapitek/regex-crossword-solver) на гитхабе


##### Группирование и обратные ссылки

Круглые скобки определяют группы, на которые можно ссылаться с помощью обратных ссылок. Это регулярное выражение находит все фрукты, которые содержат повторяющиеся пары букв.

```{r}
str_view(fruit, "(..)\\1", match = TRUE)
```

##### Упражнение 14.3.5.1.1

<div class="question">
Describe, in words, what these expressions will match:

* `(.)\1\1`

* `"(.)(.)\\2\\1"`

* `(..)\1`

* `"(.).\\1.\\1"`

* `"(.)(.)(.).*\\3\\2\\1"`
</div>

Регулярные выражения --- это целое искусство. Чтобы их освоить нужно время. Больше информации о регулярных выражениях можно найти [на хабре](https://habr.com/post/115825/)

* `(.)\1\1` --- один и тот же символ появляется три раза подряд. Только нужно экранировать запись

```{r}
str_view("fffff", "(.)\\1\\1")
```


* `"(.)(.)\\2\\1"` --- За парой символов следует одна и та же пара символов в обратном порядке.

```{r}
str_view(c("fffff", "oihoiahsodh", "arra"), "(.)(.)\\2\\1")
```

* `(..)\1` --- Два символа повторяются. Нужно экранировать

```{r}
str_view(c("fffff", "1212", "arra"), "(..)\\1")
```

* `"(.).\\1.\\1"` --- Пять символов, повторяется нечётный

```{r}
str_view(c("fffff", "2f2f2", "arra"), "(.).\\1.\\1")
```

* `"(.)(.)(.).*\\3\\2\\1"` --- Три символа, за которыми следуют ноль или более символов любого вида, за которыми следуют те же три символа, но в обратном порядке.

```{r}
str_view(c("adssda", "123 321", "are2222era"), "(.)(.)(.).*\\3\\2\\1")
```

##### Упражнение 14.3.5.1.2

<div class="question">
Construct regular expressions to match words that:

* Start and end with the same character.

* Contain a repeated pair of letters (e.g. church'' containsch’’ repeated twice.)

* Contain one letter repeated in at least three places (e.g. eleven'' contains threee’’s.)
</div>

* Начинается и заканчивается с одного и того же символа. 

```{r}
str_view(c("a", "ii;ji", "are2222era"), "^(.)((.*\\1$)|\\1?$)")
```

* СОдержит повторяющуюся пару букв

```{r}
str_view(c("a", "ii;ji", "afre2222ereaa"), "([A-Za-z][A-Za-z]).*\\1")
```

* СОдержит одну букву повторяющуюся по крайне мере в трёх местах

```{r}
str_view(c("eleven", "ii;j", "afre2222ereaa"), "([a-z]).*\\1.*\\1")
```

### Инструментарий

Разбивай сложное выражение на несколько простых

#### Обнаружение совпадений

Для обнаружения совпадений используется функция `str_detect()`
```{r}
x <- c("apple", "banana", "pear")
str_detect(x, "e")
```

Она возвращает логический вектор, благодаря этому её удобно использовать для нахождения некоторых полезных вещей. Например, количество вхождений

```{r}
# Сколько слов начинаются с буквы t?
sum(str_detect(words, "^t"))
```

Или среднее количество слов содержащих определённую комбинацию

```{r}
# Какова доля слов, оканчивающихся на гласную?
mean(str_detect(words, "[aeiou]$"))
```

Когда у вас сложные логические условия (например, соответствуют `a` или `b`, но не `c`, если не `d`), часто проще объединить несколько вызовов `str_detect()` с логическими операторами, чем пытаться создать одно регулярное выражение. Например, вот два способа найти все слова, которые не содержат гласных:

```{r}
# Найти все слова, содержащие хотя бы одну гласную и инвертировать эту операцию "!"
no_vowels_1 <- !str_detect(words, "[aeiou]")

# Найти все солова, состоящие только из согласных символов не являющихся гласными
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
```

Как говорилось ранее --- если регулярное выражение усложняется простым и логичным шагом будет такой подход: разбить на простые части, объединить простые части логическим оператором.

Есть удобная функция оболочка `str_subset()`, она используется для выбора элементов соответствующзих шаблону.

```{r}
words[str_detect(words, "x$")]
str_subset(words, "x$")
```

Однако обычно строкой будет один из столбцов фрейма данных, и вместо этого будет использоваться фильтр.

```{r}
df <- tibble(
  word = words, 
  i = seq_along(word) # используется для генерации регулярных последовательностей
)
df %>% 
  filter(str_detect(word, "x$")) # фильтрует заданный набор данных, оставляя только те слова, в которых на конце х
```

`str_count()` сообщает сколько совпадений обнаружено в строке

```{r}
x <- c("apple", "banana", "pear")
str_count(x, "a")

# сколько гласных в среднем приходится на одно слово
mean(str_count(words, "[aeiou]"))
```

`str_count()` естественно использовать с `mutate()` 

```{r}
df %>%
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]")
  )
```

Интересная особенность --- совпадения никогда не перекрываются. Сколько раз в строке `"abababa"` встречается шаблон `"aba"`? Регулярное выражение скажет что он встречается два раза, а не три

```{r}
str_count("abababa", "aba")

str_view_all("abababa", "aba")
```

Обратим внимание на последнюю функцию. В пакете `string` многие функции идут парами --- одна работает с одиночными совпадениями, другая со всеми.

##### Упражнение 14.4.1.1.1
<div class="question">
For each of the following challenges, try solving it by using both a single regular expression, and a combination of multiple `str_detect()` calls.

* Find all words that start or end with x.

* Find all words that start with a vowel and end with a consonant.

* Are there any words that contain at least one of each different vowel?

* What word has the highest number of vowels? What word has the highest proportion of vowels? (Hint: what is the denominator?)
</div>

* В общем случае

```{r}
# все слова начинающиеся или заканчивающиеся на X
str_view_all(words, "^x|x$", match = TRUE)

df %>%
  filter(str_detect(words, "^x|x$")) #  Указан порядковый номер слова
```

А теперь разберём

```{r}
# Одним регулярным выражением
words[str_detect(words, "^x|x$")]

# Двумя отдельными выражениями
start_with_x <- str_detect(words, "^x")
end_with_x <- str_detect(words, "x$")
words[start_with_x | end_with_x]
```

* В общем случае. Ругелярное выражение такое --- ищи первым символом любую гласную, после этого может быть любой символ один или больше раз, а оканчиваться слово должно на любую негласную букву.

```{r}
# все слова начинающиеся на гласную, а заканчивающиеся на согласную
str_view_all(words, "^[aeiou].*[^aeiou]$", match = TRUE)

df %>%
  filter(str_detect(words, "^[aeiou].*[^aeiou]$")) #  Указан порядковый номер слова
```

А теперь разобьём

```{r}
# Одним регулярным выражением
words[str_detect(words, "^[aeiou].*[^aeiou]$")]

# Двумя отдельными выражениями
start_with_x <- str_detect(words, "^[aeiou]")
end_with_x <- str_detect(words, "[^aeiou]$")
words[start_with_x & end_with_x]
```

* В общем случае, cлова, в которых гласная содержится хотя бы один раз -- не придумал способ реализации. 

```{r}
# Сочетание нескольких регулярных выражений
words[str_detect(words, "a") &
      str_detect(words, "e") &
      str_detect(words, "i") &
      str_detect(words, "o") &
      str_detect(words, "u")]
```

* Доля гласных это отношение количества гласных букв в слове, к длине всего слова. Я предполагаю, что самым длинным будет какое-то особое слово, в котором кол-во букв, совпадает с кол-вом гласных. 

```{r}
(vowels <- str_count(words, "[aeiou]")) # Считаем кол-во гласных в слове
max(vowels) # Максимальное кол-во гласных в слове 5 штук
words[which(vowels == max(vowels))] # Берём слова, с максимальным количеством гласных
prop_vowels <- str_count(words, "[aeiou]") / str_length(words) # Считаем долю гласных букв от всего слова.
words[which(prop_vowels == max(prop_vowels))] # Берём словам, с максимальной долей гласных
```

##### Извлечение совпадений

Для извлечение фактического текста совпадегния используется функция `str_extract()`. Для демонстрации воспользуемся текстом  [Harvard senteces](https://en.wikipedia.org/wiki/Harvard_sentences).

Предложения, составляющие этот текст предоставляются пакетом `stringr::sentences`

```{r}
length(sentences)
head(sentences)
```

Предположим мы хотим найти все предложения, в которых упоминается цвет. Сначала мы создаем вектор названий цветов:

```{r}
colors <- c("red", "orange", "yellow", "green", "blue", "purple")
```

А затем превращаем его в одиночное регулярное выражение:

```{r}
(color_match <- str_c(colors, collapse = "|"))
```

После этого можно выбрать все предложения, в которых упоминается какой-либо цвет:

```{r}
has_color <- str_subset(sentences, color_match)
```

А затем извлечь каждый цвет, чтобы увидеть, что это за цвета:

```{r}
(matches <- str_extract(has_color, color_match))
```

*Функция `sub_extract()` извлекает лишь первое совпадение*. Это легче всего увидеть, если выбрать сначала все предложения, в которых имеется более одного совпадения

```{r}
more <- sentences[str_count(sentences, color_match) > 1]
str_view_all(more, color_match)
str_extract(more, color_match)
```

Это обычная схема при работе с пакетом `stringr`, поскольку одиночные структуры проще. Для получения всех совпадений используем функцию `str_extract_all()`. Но она уже возвращает список, с которым несколько затруднительнее работать.

```{r}
str_extract_all(more, color_match)
```

Если передать функции `str_extract_all()` аргумент `simplify = TRUE`, она вернёт матрицу, в которой короткие совпадения расширены до той же длины, что и самое длинное.

В разобранном выше примере это сложно понять, посколько в каждом предложение указанный цвет встречается по два раза:

```{r}
str_extract_all(more, color_match, simplify = TRUE)
```

Легче понять по искусственному примеру:

```{r}
# Вводим переменную, с кол-вом букв в каждом векторе 1,2,3 соответственно
x <- c("a", "a b", "a b c")
# Ищем совпадение любой буквы в переменной x, с расширением недостающих совпадений
str_extract_all(x, "[a-z]", simplify = TRUE)
```

##### Упражнение 14.4.3.1.1
<div class="question">
In the previous example, you might have noticed that the regular expression matched “flickered”, which is not a color. Modify the regex to fix the problem.
</div>

Выдача результата проводится при любом найденном совпадении. Для того чтобы искать только слова обозначающие цвет, а не любое найденное совпадение символов, достаточно чтобы искалось слово целиком.

```{r}
colors <- c("red", "orange", "yellow", "green", "blue", "purple")
color_match <- str_c(colors, collapse = "|")
more <- sentences[str_count(sentences, color_match) > 1]
str_view_all(more, color_match)
```

Для этого удобно использовать оператор: `\b` --- он ищет совпадение в начале или конце. Нам нужно чтобы найденные символы были началом и концом слова, иными словами чтобы это было слово целиком

```{r}
colors <- c("red", "orange", "yellow", "green", "blue", "purple")
color_match2 <- str_c("\\b(", str_c(colors, collapse = "|"), ")\\b")
more <- sentences[str_count(sentences, color_match) > 1]
str_view_all(more, color_match2)
```

##### Упражнение 14.4.3.1.2
<div class="question">
From the Harvard sentences data, extract:

* The first word from each sentence.

* All words ending in ing.

* All plurals.
</div>

* Я сразу буду пытаться упрощать и стараться не лепить огромные регулярные выражения. 
Поэтому я буду часто использовать некоторые сокращенные записи для классов символов. 
Вот их неполный перечень

| Обозначение| Описание      |
| -----------|:------------------:|
|`\w`|	Word (a-z, A-Z, 0-9, including _ (underscore))|
|`\W`|	Non-word|
|`\d`|	Digit (0-9)|
|`\D`|	Non-digit|
|`\s`|	Whitespace|
|`\S`|	Not whitespace|
|`\b`|	Match at beginning or end|
|`\B`|	Do not match at beginning or end|
|`\0`|	NULL character|
|`\n`|	New line|

Сначала я подумал, что идеально для цели "извлечь первое слово" подходит оператор `\w` --- любое слово:

```{r}
str_view(sentences, "\\w+") # найти один или более буквенный символ
```

Но у меня возникли сомнения по поводу конструкции `It's` --- это одно слово или два? Кроме того бывают слова написанные через дефис, например название города `Baden-Baden`. Поэтому я решил действовать навярняка --- я буду брать конструкцию целиком до первого пробела.

```{r}
str_view(sentences, "\\S+") # найти один или более не пробельных символов
```

тогда итоговое решение будет выглядеть следующим образом:

```{r}
str_extract(sentences, "\\S+") %>%
  head()
```

Мне показалось ошибочным моё решение, поскольку я нашёл предложение, которое начинается со слова `ii`.
```{r}
sentences[284]
```

Однако, действительно, это предложение начинается с двух гласных, первая из которых строчная.

* Как и в первом упражнении, нужно найти слово целиком, для этого нужно использовать оператор `\b`.


```{r}
str_view_all(sentences, "\\b[A-Za-z]+ing\\b", match = TRUE) # Найти слова первые один или более буквенных символов и оканчивающиеся на `ing`
```

```{r}
(ing <- str_detect(sentences, "\\b[A-Za-z]+ing\\b"))  # Содержит ли предложение слово с инг-овым окончанием
sentences[ing]                                        # предложения с инговым окончанием
str_extract_all(sentences[ing], "\\b[A-Za-z]+ing\\b") # Используем extract_all, потому что в предложении может быть несколько инг-овых слов.
```

С такой структурой полученного набора неудобно работать. Для того чтобы упростить полученный набор до вектора используем функцию `unlist()`. Учитывая структуру списка на входе, `unlist()` упрощает его для создания вектора, который содержит все атомарные компоненты, которые встречаются во входном списке.

```{r}
unlist(str_extract_all(sentences[ing], "\\b[A-Za-z]+ing\\b"))
```

С полученным вектором уже удобнее работать, к примеру можно извлечь уникальные слова оканчивающиеся на -ing, встречающиеся в исходном наборе:

```{r}
unique(
  unlist(
    str_extract_all(
      sentences[ing], "\\b[A-Za-z]+ing\\b")
    )
  )
```


* Поиск всех слов во множественном числе только регулярными выражениями будет трудной задачей, если соблюдать все правила языка. Потому что помимо добавления к слову окончания `s` есть ещё ряд условий такие как:

  * если существительное заканчивается на: -o, -ch, -sh, -ss или -x, множественное число образуется путем добавления окончания `-es`.

  * если существительное оканчивается на -y и перед -y стоит согласная буква, мы "y" меняем на "i" и добавляем `-es`.
  
  * 12 существительных оканчивающихся на - f или - fe, при образовании множественно числа "теряют" - f или - fe, но приобретают - ves.
Вот они: calf (теленок), half (половина), knife (нож), leaf (лист дерева), life (жизнь), loaf (буханка, каравай), self (сам, себя), sheaf (сноп, вязанка), shelf (полка), thief (вор), wife (жена), wolf (волк).

  * ряд существительных, у которых множественное число образуется за счет изменения гласной (а в некоторых случаях, за счет добавления окончания - en / - ren). foot (нога, ступня) - feet, tooth (зуб) - teeth, man (мужчина, человек) - men, woman (женщина) - women, mouse (мышь) - mice, goose (гусь) - geese, louse (вошь) - lice, child (ребенок) - children, ox (бык, вол) - oxen.

  *  Существительные deer (олень) и sheep (овца) имеют одинаковую форму, как для единственного, так и для множественно числа. sheep - sheep, deer - deer.

Мне кажется, проще на данном этапе решить задачу в общей форме --- искать все слова у которых не менее трёх букв перед `s`. Три для того чтобы отсечь слова наподобие `as, is, gas`. Итого имеем:

```{r}
unique(
  unlist(
    str_extract_all(sentences, "\\b[A-Za-z]{3,}s\\b")
    )
  )
```

##### Разбиение совпадений на группы

Круглые скобки можно использовать 

* для расстановки приоритетов, 

* для обеспечения возможности обратных ссылокв процессе обнаружения совпадений,

* для извлечения частей сложных совпадений

Предположим, есть необходимость извлечь существительное из предлдожений. Приближением приближенным к реальности (или эвристикой) будет поиск любого слова следующего за артиклем `a` или `the`. Определение "слова" в регулярном выражение не совсем простая штука, поэтому мы воспользуемся приближением --- слово это последовательность, состоящая по крайне мере из одного символа, не являющегося пробелом.

```{r}
noun <- "(a|the) ([^ ]+)"

has_noun <- sentences %>%
  str_subset(noun) %>%
  head(10)

has_noun %>% 
  str_extract(noun)
```

Функция `str_extract` даёт нам полное совпадение, функция `str_match` --- каждый отдельный его компонент. Вместо символьного вектора она возвразает матрицу с одним столбцом для полного совпадения, за которым следуют столбцы, по одному для каждой группы.

```{r}
has_noun %>% 
  str_match(noun)
```

*Важно!* 

Если данные содержатся в tibble-фрейме, зачастую проще использовать функцию `tidyr::extract()`. Она работает подобно `str_match()`, но требует чтобы мы именовали совпадения, которые затем помещаются в новые столбцы

```{r}
tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", 
    remove = FALSE
  )
```


##### Упражнение 14.4.3.1.1
<div class="question">
Find all words that come after a “number” like “one”, “two”, “three” etc. Pull out both the number and the word.
</div>

Это задание очень похоже на пример разобранный в книге, с той лишь разницей, что в задаче необходимо перечислить все числительные.



```{r}
numbers <- "(one|two|three|four|five|six|seven|eight|nine|ten) +(\\S+)"

has_numbers <- sentences %>%
  str_subset(numbers) %>%    # str_subset() используется для выбора элементов, соответствующих шаблону
  head(10)

has_numbers %>%              # Выводим все совпадения в красивую матрицу
  str_match(numbers)
```

##### Упражнение 14.4.3.1.2
<div class="question">
Find all contractions. Separate out the pieces before and after the apostrophe.
</div>

Необходимо найти все сокращения.
Напомню, что в английском языке можно сокращать некоторые слова. В таких случаях ставится апостроф `'` на место пропуска букв.

```{r}
contractions <- sentences %>%
  str_subset("(\\S+)'(\\S+)")

contractions %>%
  str_match("(\\S+)'(\\S+)")
```

