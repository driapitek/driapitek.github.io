---
editor_options:
  chunk_output_type: console
output:
  html_document: default
  pdf_document: default
---

## Трансформация данных
Поменять уровень вложенности главы когда разберусь как это делать

## Введение
### Используемые ресурсы

```{r, eval = FALSE}
library(nycflights13)
library(tidyverse)
library(dplyr)
```

Некоторые имена функций в разных библиотеках дублируются. Когда в `R` подключается несколько пакетов, в которых названия функций дублируются, программа выдает сообщение об ошибке

```{r, eval = FALSE}
── Conflicts ─────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
```

Для того чтобы обратится к необходимой функции, нужно использовать полное имя `stats::filter()`, `stats::lag()`

### Пакет `nycflights13`

|Переменная      | Описание       |
| ------------- |:-------------:|
| `int` | целые числа    |
| `dbl` | числа с плавающей точкой    |
| `chr` | символьные векторы или строки    |
| `dttm` | дата + время    |
| `lgl` | булевы векторы    |
| `fctr` |факторы   |
| `date` | даты    |

### Основные сведения о пакете `dplyr`

Минимум для работы с этим пакетом:

|Функция       | Описание    |
| ------------ |:-----------:|
| `filter()`   | выбор наблюдений по их значениям |
| `arrange()`  | перестановка строк |
| `select()`   | выбор переменных по их именам|
| `mutate()`   | создание новых переменных с использованием существующих|
| `summarize()`| сведение нескольких значений в одно итоговое |
| `group_by()` | изменяет область действия функции от всего набора данных до отдельных участков|

Все глаголы подчиняются одному и тому же синтаксису

1. Первый аргумент $-$ это фрейм данных

1. Последующие аргументы описывают действия, которые должны быть выполнены по отношению к фрейму данных.

1. Результат $-$ это новый фрейм данных

## Фильтрация строк с помощью функции `filter()`

Функция `filter()` позволяет что бы вы думали? позволяет фильтровать! Первым аргументом указываем фрейм данных, последующие аргументы, это параметры (столбцы) которые мы желаем отфильтровать через операторы сравнения.

```{r}
filter(flights, month == 1, day != 1)
```

Функция `filter()`, как и многие другие расширения пакета `dplyr`, не изменяют исходных данных. Желаемый фильтр нужно присвоить в новую переменную

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

Если нужно выполнить присвоение и вывод на экран, нужно обнять выражение скобками.

```{r}
(jan1 <- filter(flights, month == 1, day == 1))
```


### Сравнения

Операторы сравнения стандартные `>`, `>=`, `<`, `<=`, `==`, `!=` 

Компьюьеры используют арифметику конечной точности. Поэтому

```{r}
sqrt(2) ^ 2 == 1
```

### Логические операторы

Булевы операторы: И - `&`, ИЛИ - `|`, НЕ - `!`, исключающее ИЛИ - `xor()`.
Полный набор булевых операций показан на рисунке.

![alt text](img/transform-logical.png)

Что следует помнить. Добавляя булевы операторы в функцию `filter()` необходимо помнить, что сравнивать нужно программно, а не так как это звучит лексически. То есть, если мы хотим все авиарейсы отправленные в декабре и ноябре, нужно писать так.

```{r}
(filter(flights, month == 11 | month == 12))
```

Что дословно произносится как "отфильтровать все полёты из набора данных `flights`, вылетавших в месяце ноябре или в месяце декабре". Можно следовать лексическому соответствию, но для этого нужно использовать оператор `%in%`

```{r}
(filter(flights, month %in% c(11, 12)))
```

**Закон Моргана:**

* `!(x & y) == !x | !y`

* `!(x | y) == !x & !y`

Проверь на рисунке выше.

### Отсутствующие значения

Функция `filter()` включает в вывод лишь те строки, для которых условие имеет значение `TRUE`. `FALSE` и `NA` исключаются.

Для того чтобы проверить является ли используемое значением отсутствующим можно использовать функцию `is.na()`

### Упражнение 5.2.4.1 {.unnumbered} 
<div class="question">
Найдите все авиарейсы, которые
</div>

* а) задержались с прилётом на два и более часа

```{r}
(arr_delay <- filter(flights, arr_delay >= 120))
```

* б) вылетали в Хьюстон (аэропорты IAH и HOU)

```{r}
(hou_flight <- filter(flights, dest == "IAH" | dest == "HOU"))
```

* в) Обслуживались авиакомпаниями United, American or Delta

Для того чтобы узнать аббревиатуры перевозчиков, смотрим `airlanes`

```{r}
airlanes
```

Получается: United - это `UA`, American - `AA`, Delta - `DL`. Тогда искомые данные это:

```{r}
(three_carriers <- filter(flights, carrier %in% c("UA", "AA", "DL")))
```

* г) Вылетали в летнее время (июль, август, сентябрь). Странное у них летнее время

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

* д) Прилетали с опозданием более чем на два часа но не задерживались с вылетом

```{r}
(dep_arr_delay <- filter(flights, arr_delay > 120, dep_delay <= 0))
```

* е) Вылетали с задержкое не менее чем на час, но наверстывали более 30 минут во время полёта. Если полёт проходит ровно, то задержка отправления равна задержке прибытия. `Или dep_delay - arr_delay == 0`. Так как самолёт наверстал в пути, значит разница равна не нулю, она больше 30.

```{r}
(speedy_flights <- filter(flights, dep_delay >= 60, dep_delay - arr_delay > 30 ))
```

* ж) Вылетали между полуночью и 6 часами утра включительно

```{r}
(moon <- filter(flights, dep_time == 2400 | dep_time <= 600))
```

### Упражнение 5.2.4.2 {.unnumbered} 
<div class="question">
Another useful `dplyr` filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?
</div>

Из описания в хэлпе, функция `between()` это короткая запись для `>= left & x <= right`. Или если быть точным: `between(x, left, right)`. Конечно её гораздо удобнее использовать. Эту функцию можно применить к упражнению  *г*. Сравним:

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

```{r}
(sum_flights <- filter(flights, between(month, 7, 9)))
```

### Упражнение 5.2.4.3 {.unnumbered} 
<div class="question">
How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?
</div>

```{r}
(filter(flights, is.na(dep_time)))
```

Ответ 8255 рейсов. Так же отсутствуют: `dep_delay`, `arr_time`, `arr_delay`. Вероятно это отменённые рейсы.

### Упражнение 5.2.4.4 {.unnumbered} 
<div class="question">
Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing? Why is `FALSE & NA` not missing? Can you figure out the general rule? (`NA * 0` is a tricky counterexample!)
</div>

1. `NA ^ 0 == 1`. Всё в точности с математикой, которая говорит, что любое значение в степени 0 == 1 или точнее $x^0=1$

1. `NA | TRUE`. Всё или ПРАВДА всегда правда :

| $a$ | $b$ | $a\lor b$ |
| - |:-:||:-:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

1. `FALSE & NA`. Всё и ЛОЖЬ всегда Ложь.

| $a$ | $b$ | $a\land b$ |
| - |:-:||:-:|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

1. `NA * 0`. Причина по которой значение неопределено. Это то что умножение чего угодна на бесконечность, равно бесконечности, или правильнее - неопределённое значение. [нечисло](https://ru.wikipedia.org/wiki/NaN)


## Перестановка строк с помощью функции `arange()`

Синтаксис у этой функции такой же как у фильтра. `arranga()` сортирует по убыванию, а не фильтрует список. При этом отсутствующие значения всегда остаются в конце. При этом для сортировки по возрастанию используется функция `desc()`

### Упражнение 5.3.1.1 {.unnumbered} 
<div class="question">
How could you use `arrange()` to sort all missing values to the start? (Hint: use `is.na()`).
</div>

Берём пример из учебника.

```{r}
arrange(flights, desc(arr_delay))
```

Добавляем как подсказывают, функцию `is.na()`

```{r}
arrange(flights, desc(is.na(arr_delay)))
```

### Упражнение 5.3.1.2 {.unnumbered}
<div class="question">
Sort `flights` to find the most delayed flights. Find the flights that left earliest.
</div>

Чтобы найти рейсы с самыми большими задержками, сортируем по возрастанию соответствующий столбец `dep_delay`

```{r}
arrange(flights, desc(dep_delay))
```

Первые десять рейсов задерживались на время от 896 минут до 1301, это почти сутки (21 час) в аэропорте. Уффф.

Чтобы найти рейсы с самым ранним временем вылета, сортируем по убыванию соответствующий столбец `dep_time`

```{r}
arrange(flights, dep_time)
```

Ожидаемо, это время вылетов в полночь и минутой позднее.

### Упражнение 5.3.1.3 {.unnumbered}
<div class="question">
Sort `flights` to find the fastest flights.
</div>

Чтобы найти самые быстрые полёты, отсортируем все полёты по времени проведённому в воздухе. Это столбец `air_time` отсортированный по возрастанию.

```{r}
arrange(flights, air_time)
```

### Упражнение 5.3.1.4 {.unnumbered}
<div class="question">
Which flights traveled the longest? Which traveled the shortest?
</div>

Сделаем так, сначала отсортируем по расстоянию, а потом по времени проведённому в воздухе

```{r}
arrange(flights, desc(distance))
```

Самые длинные полёты из `JFK` в `HNL`. Из Нью-Йорка в Гонолулу - 4983 мили.

```{r}
arrange(flights, desc(distance))
```

[Полёт длится 691 минуту](https://www.google.com/maps/dir/Гонолулу+(HNL),+300+Rodgers+Blvd,+Honolulu,+HI+96819,+США/JFK+International+Airport,+New+York,+NY,+USA/@27.4344347,-126.6384014,4.03z/data=!4m14!4m13!1m5!1m1!1s0x7c006f943168f55f:0x7ed111b1cbf331df!2m2!1d-157.9250736!2d21.3245132!1m5!1m1!1s0x89c26650d5404947:0xec4fb213489f11f0!2m2!1d-73.7781391!2d40.6413111!3e4)


```{r}
arrange(flights, distance)
```

Самый короткий из `EWR` в `LGA`. Перелёт в пределах Нью-Йорка, который по всей видимости не состоялся, так как у него нету времени полёта. Следующий за ним это полёт из Нью-Арка в Филадельфию - 80 миль. Посмотрим ещё и по времени, проведённому в воздухе:

```{r}
arrange(flights, distance, air_time)
```

## Выбор столбцов с помощью функции `select()`

Функция `select()` помогает отобрать из фрейма данных необходимые столбцы. Синтаксис простой и привычный

* Указать конкретные столбцы можно через запятую 
```{r}
select(flights, year, month, day)
```

* Указать столбцы в промежутке
```{r}
select(flights, year:day)
```

* Выбрать всех столбцов за исключением тех, которые находятся между столбцами включая последние
```{r}
select(flights, -(year:day))
```

* `start_with("abc")` - соответствует именам, начинающимся с последовательности символов "abc"

* `end_with("abc")` - соответствует именам, заканчивающимся последовательностью символов "abc"

* `contains("abc")` - соответствует именам, содержащим последовательности символов "abc"

* `matches("(.)\\1")` - выбирает переменные, соответствующие регулярному выражению.

* `num_range("x", 1:3)` - соответствует `x1`, `x2`, `x3`

* Переименовать переменные, сохраняя все переменные не указанные в явном виде
```{r}
rename(flights, tail_num = tailnum)
```

* Переместить в начало переменные.
```{r}
select(flights, time_hour, air_time, everything())
```

### Упражнение 5.4.1.1 {.unnumbered}
<div class="question">
Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.
</div>


1. Указать конкретные столбцы через запятую
```{r}
select(flights, dep_time, dep_delay, arr_time, arr_delay)
```

1. Указать столбцы в промежутке и исключить лишние
```{r}
select(flights, dep_time:arr_delay, -sched_dep_time, -sched_arr_time)
```

1. Изощренный способ. Перенесём в начало нужные столбцы, отбросим лишние в промежутке
```{r}
new_flights <- select(flights, dep_time, dep_delay, arr_time, arr_delay, everything())
select(new_flights, -(year:time_hour))
```

1. Укажем номера столбцов
```{r}
select(flights, 4, 5, 6, 9)
```

1. Столбцы начинающиеся на `dep_` и `arr_`
```{r}
select(flights, starts_with("dep_"), starts_with("arr_"))
```

1. Столбцы содержащие и не содержащие
```{r}
select(flights, contains("_time"), contains("_delay"), -contains("sched"), -contains("air"))
```

### Упражнение 5.4.1.2 {.unnumbered}
<div class="question">
What happens if you include the name of a variable multiple times in a `select()` call?
</div>

Если одна и та же переменная указана несколько раз, она всё равно отобразится один раз
```{r}
select(flights, dep_time, dep_time, dep_time)
```

### Упражнение 5.4.1.3 {.unnumbered}
<div class="question">
What does the `one_of()` function do? Why might it be helpful in conjunction with this vector?
</div>

Функция `one_of()` берёт переменные в символьном векторе. Это может быть полезно, если как в примере у нас есть символьный вектор значений, которые необходимо взять

```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, one_of(vars))
```

### Упражнение 5.4.1.4 {.unnumbered}
<div class="question">
Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?
</div>

```{r}
select(flights, contains("TIME"))
```

Удивительно, что `contains()` невосприимчив к регистру:

```{r}
select(flights, contains("time"))
```

Оказывается, это регшулируется параметром `ignore.case` который по умолчанию `TRUE`:

```{r}
select(flights, contains("TIME", ignore.case = FALSE))
```


Вот список всех функций, согласно хэлпу, невосприимчивых по умолчанию к регистру:

* `starts_with(match, ignore.case = TRUE, vars = peek_vars())`

* `ends_with(match, ignore.case = TRUE, vars = peek_vars())`

* `contains(match, ignore.case = TRUE, vars = peek_vars())`

* `matches(match, ignore.case = TRUE, vars = peek_vars())`

## Добавление столбцов с помощью функции `mutate()`

Функция `mutate()` позволяет добавлять в конец исходного фрейма данных столбцы. 

Сделаем чуть более показательный набор данных:
```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
```


Теперь добавим в конец этого набора дополнительные вычисления
```{r}
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)
```

Чтобы сохранить только вычисления, без указания дополнительных столбцов, используется функция `transmute()`

```{r}
transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

### Полезные функции создания объектов

* Арифметические операторы `+`, `-`, `*`, `/`, `^`

* Модулярная арифметика. Целочисленное деление - `%/%`. Взятие остатка - `%%`. Показательный пример:

```{r}
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

* Логарифмические функции `log()`, `log2`, `log10()`

* Смещения. Вперёд - `lag()`. Назад - `lead()`

* Кумулятивные и скользящие агрегаты. `cumsum()`, `cummin()`, `cumprod()`, `cummax()`, `cummean()`

* Логические операторы `<`, `>`, `>=`, `<=`, `!=`

* Ранжирование. Функции ранжирования `row_number(x)`, `ntile(x, n)`, `min_rank(x)`, `dense_rank(x)`,`percent_rank(x)`, `cume_dist(x)`. В этих функциях `desc()` меняет направление.

### Упражнение 5.5.2.1 {.unnumbered}
<div class="question">
Currently `dep_time` and `sched_dep_time` are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.
</div>

Заданные параметры `dep_time` and `sched_dep_time` записаны в формате HHMM. Чтобы получить из исходных данных последовательный формат, необходимо произвести целочисленное деление на 100, и к результату добавить остаток от деления.

```{r}
transmute(flights,
  dep_time,
  sched_dep_time,
  dep_time_minute = ((dep_time %/% 100) * 60) + dep_time %% 100,
  sched_dep_time_minute = ((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100
)
```

Можно добавить эти значения в исходную выборку:
```{r}
mutate(flights,
  dep_time_minute = ((dep_time %/% 100) * 60) + dep_time %% 100,
  sched_dep_time_minute = ((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100
)
```

### Упражнение 5.5.2.2 {.unnumbered}
<div class="question">
Compare `air_time` with `arr_time - dep_time`. What do you expect to see? What do you see? What do you need to do to fix it?
</div>

Значения данных `dep_time` и `arr_time` это время отправления и время прибытия соответственно записанные в формате HHMM. `air_time` - это время полёта, записанное в минутах. Естественно, если мы просто вычтем из времени прибытия время отправления в текущем формате, мы не получим `air_time`.

Таким образом, моё предположение сводится к следующему - чтобы разность `arr_time - dep_time` и `air_time` совпадали, необходимо:

1. для начала привести их к общей форме записи в минутах.

```{r}
transmute(flights,
  air_time,
  arr_minus_dep = (((arr_time %/% 100) * 60) + arr_time %% 100) - (((dep_time %/% 100) * 60) + dep_time %% 100)
)
```

1. затем необходимо учесть прилёт на другой день

1. и ещё необходимо учитывать разное время часовых поясов отлёта и прибытия, так как время в данных указано локальное

Так как два последних предположения текущим набором данных мне проверить не предвидится возможным, я заглядываю в подсказку

В имеющимся в сети [решении](https://jrnold.github.io/r4ds-exercise-solutions/data-transformation.html) заданий от пользователя jrnold я нашёл что, в своём предположении я не учёл особенность сбора данных. Особенность заключается в том, что время отправления и время прибытия считаются от момента когда самолёт оторвал шасси и коснулся земли соответсвенно. В это время не входит время проведённое при посадке и прохождении регистрации, которое учитано в `air_time`.

### Упражнение 5.5.2.3 {.unnumbered}
<div class="question">
Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?
</div>

Разберёмся в том, что каждый столбец данных представляет.

* `sched_dep_time` - это запланированное время вылета в формате HHMM по местному времени

* `dep_time` - это актуальное время вылета в формате HHMM по местному времени

* `dep_delay` - это время задержки вылета в минутах. Отрицательное время будет показывать ранний вылет.

То есть по сути `dep_delay` это разность между актуальным временем вылета и запланированным временем. Чтобы разность `dep_time - sched_dep_time` соотносилась с `dep_delay`, формат HHMM необходимо перевести в минуты.

```{r}
flights_new_dep <- mutate(flights,
  dep_delay_ng = dep_time - sched_dep_time,
  dep_delay_ok = (((dep_time %/% 100) * 60) + dep_time %% 100) - 
    (((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100))
```

Однако подобный формат записи приводит к тому, что если вылет фактический и вылет планируемый находятся по разную сторону от полуночи, то разница будет большой либо в отрицательную, либо в положительную сторону. Что конечно же не соответствует фактическому времени задержки. 
Тут вроде бы `dep_delay` и полученный в результате приведения к одному формату и разности планируемого и фактического времени `dep_delay_ok` сходятся. Однако уже даже при обратной сортировке видно, что есть большие различия, связанные, как я уже сказал, с особенностью внесения этих данных:

```{r}
new_delay <- select(flights_new_dep, dep_delay_ok, dep_delay, dep_delay_ng)
arrange(new_delay, desc(dep_delay))
```

### Упражнение 5.5.2.4 {.unnumbered}
<div class="question">
Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for `min_rank()`.
</div>

Задрежка вылета `dep_delay`. Найти 10 авиарейсов, можно функцией `arrange()`

```{r}
(arrange(flights, desc(dep_delay)))
```

Но так мы возьмём все связанные данные.
Чтобы ограничить выдачу, можно использовать функцию `min_rank()`.
Я воспользуюсь этой функцией чтобы взять первые 10 авиарейсов по рангу.
Сначала посмотрим что делает `min_rank()`:

```{r}
(transmute(flights, dep_delay_rank = min_rank(-dep_delay)))
```

Теперь добавим к имеющемуся набору данных новых столбуц с обратным ранжированным столбцом `dep_delay()`

```{r}
(flights_delayed <- mutate(flights, dep_delay_rank = min_rank(-dep_delay)))
```

Затем возьмём первые 10 значений:
```{r}
(filter(flights_delayed, dep_delay_rank <= 10))
```

### Упражнение 5.5.2.5 {.unnumbered}
<div class="question">
What does `1:3 + 1:10` return? Why?
</div>

```{r}
1:3 + 1:10
```

Это возвращает такой странный результат, потому что при складывании двух векторов разной длинны, происходит "дополнение" длинного вектора, повторением сначала значениями короткого. Проще говоря: `c(1 + 1, 2 + 2, 3 + 3, 1 + 4, 2 + 5, 3 + 6, 1 + 7, 2 + 8, 3 + 9, 1 + 10)`

### Упражнение 5.5.2.6 {.unnumbered}
<div class="question">
What trigonometric functions does R provide?
</div>

В R есть следующие тригонометрические функции.

* Простые: `cos(x)`, `sin(x)`, `tan(x)`

* Арки `acos(x)`, `asin(x)`, `atan(x)`, `atan2(y, x)`

* И ещё `cospi(x)`, `sinpi(x)`, `tanpi(x)`

## Получение групповых итогов с помощью функции `summarize()`

### Объединение нескольких операций с помощью канала
Мы хотим исследовать связь между расстоянием `distance` и средним временем задержки рейса `arr_delay` для всех пунктов приема и вылета.

Для этого необходимо.

1. Группирование рейсов по пунктам назначения

```{r}
by_dest <- group_by(flights, dest)
```

1. Получение сводных данных (суммарных), касающихся расстояний `distance`, среднего времени задержки `mean(arr_delay)` и количества авиарейсов `count()`.

```{r}
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
```

1. Фильтрация данных с целью исключения точек данных, создающих информационный шум, и аэропорта Гонолулу `NHL`, который распологется на расстоянии, почти вдвое превышающем расстояние до следующего ближайшего аэропорта.

```{r}
delay <- filter(delay, count > 20, dest != "NHL")
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
    geom_point(aes(size = count), alpha = 1/3) +
    geom_smooth(se = FALSE)
```

Это решение, но такой код трудно писать, поскольку нужно присваивать каждому промежуточному фрейму данных отдельное имя.
Есть такая штука как канал `%>%`. Канал фактически позволяет говорить "затем". 

Сначала сгруппируй %>% (затем) просуммируй по количеству значений и посчитай среднее в группах по `distance` и `arr_delay` %>% (затем) отфильтруй. Получаются все те же самые блоки, только без промежуточных присваиваний имён.

```{r}
delays <- flights %>%
  group_by(dest) %>%
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>%
  filter(count > 20, dest != "NHL")
```

### Отсутствующие значения

Я предполагал, что параметр `na.rm` отвечает за нормальное распределение. Но это было неверное предположение. Разберём пример.

Если суммировать число с пропущенным значением (неизвестным), результат будет тоже неизвестным:

```{r}
1 + NA
```

Параметр `na.rm` отвечает за пропущенные значения. Точнее за игнорирование пропущенных значений. 

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay))
```

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

В последующем будет использоваться этот срез данных, так что здесь же объявим его:

```{r}
not_canceled <- flights %>%
  filter(!is.na(dep_delay), !is.na(arr_delay))
not_canceled %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay))
```

### Счетчики

Счётчик наблюдений это `n()`. Счетчик отсутствующих значений это `sum(!is.na(x))`.
Проведём лабораторную работу.

Предположим что нас интересуют самолёты с наибольшим средним временем задержки.

```{r}
delays <- not_canceled %>%
  group_by(tailnum) %>%
  summarise(delay = mean(arr_delay))
ggplot(delays, aes(x = delay)) + geom_freqpoly(binwidth = 10)
```

Такой график показывает распределение, почти как гистограммы, только  вместо столбцов тут линии. Как и в гистограммах, такие графики показывают количество наблюдений, попавших в заданный диапазон. Постройнный график имеет диапазон 10. Поиграемся немного:

Установив значение диапазона 1 - получаем "зашумлённый" график
```{r}
ggplot(delays, aes(x = delay)) + geom_freqpoly(binwidth = 1)
```

Устанавливая значение диапазона = 100, получаем график в котором потеряно много ценной информации, график получился переглаженным
```{r}
ggplot(delays, aes(x = delay)) + geom_freqpoly(binwidth = 100)
```

Соответственно 1000 не даёт понять даже общую тенденцию, потому что крайние точки выборки, находятся далеко от 1000.
```{r}
ggplot(delays, aes(x = delay)) + geom_freqpoly(binwidth = 1000)
```

Но вернёмся к нашему распределению с диапазоном в 10 точек. Можно посмотреть под другим углом на эти данные если построить диаграмму рассеяния:

```{r}
delays <- not_canceled %>%                  # Присвой значению `delays` данные `not_canceled` ЗАТЕМ
  group_by(tailnum) %>%                     # Сгруппируй эти данные по номерам самолётов ЗАТЕМ
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),  # Посчитаем среднее значение по параметру `arr_delay`, не учитывая пропуски
    n = n()                                 # Со счётчиком количества наблюдений
  )
ggplot(delays, aes(x = n, y = delay)) +     # Построим точечную диаграмму рассеяния количества наблюдений от времени задержки
  geom_point(alpha = 1/10)                  # Точки сделаем прозрачными
```

На этой диаграмме видно, что хвост у основного распределения длинный. Тоесть от основного количества точек в "районе" нуля есть единичные выбросы вплоть до 300 по оси ординат `delay`. Часто от такого хвоста, то есть выбросов, необходимо будет избавляться. 
Как советуют в книге, помогает в этом использование пакета `ggplot` в потоке `dplyr`.

```{r}
delays %>%                                   # Возьми данные `delays` ЗАТЕМ
  filter(n > 25) %>%                         # отфильтруй группы, в которых количество наблюдений меньше `25` ЗАТЕМ
  ggplot(mapping = aes(x = n, y = delay)) +  # Построй точечную диаграмму `n` от `delay`. Точки сделай прозрачными на 1/10.
  geom_point(alpha = 1/10)
```

Рассмотрим связь между средней результативностью отбивающих в бейсболе и количеством их вызовов на удар.

```{r}
batting <- as_tibble(Lahman::Batting)      # Из большого набора данных `Lahman` возьми фрейм данных `Batting`.

batters <- batting %>%                     # Присвой переменной `batters` значение `batting` ЗАТЕМ
  group_by(playerID) %>%                   # группируй данные по ID игрока ЗАТЕМ
  summarise(                               # посчитай средний коэффициент результативности
    ba = sum(H, na.rm = TRUE) / sum (AB, na.rm = TRUE),     
    ab = sum(AB, na.rm = TRUE)             # Определи суммарное количество возможностей выполнить удар `ab`. 
  )

batters %>%                                # Возьми данные `batters` ЗАТЕМ
  filter(ab > 100) %>%                     # Возьми данные с количеством возможностей на удар больше 100 ЗАТЕМ
  ggplot(mapping = aes(x = ab, y = ba)) +  # Построй диаграмму рассеяния возможностей удара от от коэффициента результативности
  geom_point() +
  geom_smooth(se = FALSE)                  # А так же сглаженную прямую без построения доверительного интервала
```

Средний коэффициент результативности - суммарное количество ударов, делённое на суммарное количество возможностей сделать удар?. 

Этот график показывает положительную зависимость коэффициент результативности от количества ударов.

Тут есть одна закономерная интересность - чем меньше количество наблюдений, тем существеннее влияет единичное наблюдение на среднее значение. Следствием этого утверждения является тот факт, что самые высокие коэффициенты у тех кому просто повезло разочек ударить по мячу и больше не вызываться к отбиванию:

```{r}
batters %>%
  arrange(desc(ba))
```

### Полезные итоговые функции

* Меры положения - `mean(x)`, `median(x)`

* Меры изменчивости - среднеквадратичное отклонение `sd()`, межквартильный размах - `IQR()`, медианное абсолютное отклонение - `mad()`

* Меры ранжирования - максимум `max(x)`, минимум`min(x)`, квантиль 25% `quantile(x, 0,25)`, квантиль 75% `quantile(x, 0,75)`

* Порядковые меры - первый `first(x)`, последний `last(x)`, точная позиция `nth(x, 2)`

* Счетчики - размер текущей группы `n()`, количество значений не являющихся отсутствующими `sum(!is.na(x))`, количество уникальных значений`n_distinct(x)`

* Подсчет количества и долей логических значений `sum(x > 10)`, `mean(y == 0)`

### Группирование по нескольким переменным
Когда мы группируем данные по нескольким переменным, каждый сформированный итог уменьшает колтчество уровней группировки на единицу. Это упрощает последовательное свёртывание.

```{r}
daily <- group_by(flights, year, month, day)
(per_day <- summarize(daily, flights = n()))
(per_month <- summarize(per_day, flights = sum(flights)))
(per_year <- summarise(per_month, flights = sum(flights)))
```

Буду аккуратен когда буду свёртывать например медианы. Сумма групповых сумм равна общей сумме, но медиана групповых медиан не равна общей медиане.

### Разгруппирование
Тут всё просто - нужно что-то разгруппировать, пользуемся функцией `ungroup()`

```{r}
daily %>%
  ungroup() %>%            # больше не группировать по дате
  summarize(flights = n()) # все рейсы
```

### Упражнение 5.6.7.1 {.unnumbered}
<div class="question">

Brainstorm at least 5 different ways to assess the typical delay characteristics of a group of flights. Consider the following scenarios:

* A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of the time.

* A flight is always 10 minutes late.

* A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of the time.

* 99% of the time a flight is on time. 1% of the time it’s 2 hours late.

Which is more important: arrival delay or departure delay?
</div>

Разобьём ответ на части.
Вначале напридумываем как минимум пять типичных характеристик времени задержки для групп авиарейсов:

1. Мера положения - *среднее время* задержки вылета/прилёта самолёта

1. Мера положения - *медиана* времени задержки вылета/прилёта самолёта

1. Мера изменчивости - *среднеквадратичное отклонение* времени задержки вылета/прилёта самолёта

1. Мера ранжирования - *максимальное* время задержки вылета/прилёта самолёта

1. Мера изменчивости - *межквартильный размах* времени задержки вылета/прилёта самолёта

Далее будем придумывать способы доступа к придуманным характеристикам. Группировать будем по направлениям.



### Упражнение 5.6.7.2 {.unnumbered}
<div class="question">
Come up with another approach that will give you the same output as not_cancelled `%>% count(dest)` and `not_cancelled %>% count(tailnum, wt = distance)` (without using `count()`).
</div>


### Упражнение 5.6.7.3 {.unnumbered}
<div class="question">
Our definition of cancelled flights (`is.na(dep_delay) | is.na(arr_delay)` ) is slightly suboptimal. Why? Which is the most important column?
</div>


### Упражнение 5.6.7.4 {.unnumbered}
<div class="question">
Look at the number of cancelled flights per day. Is there a pattern? Is the proportion of cancelled flights related to the average delay?
</div>

### Упражнение 5.6.7.5 {.unnumbered}
<div class="question">
Which `carrier` has the worst delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about `flights %>% group_by(carrier, dest) %>% summarise(n())`)
</div>

### Упражнение 5.6.7.6 {.unnumbered}
<div class="question">
Подсчитайте для каждого воздушного судна количество авиарейсов, совершенных до первой задержки более чем на 1 час.
</div>

### Упражнение 5.6.7.7 {.unnumbered}
<div class="question">
What does the `sort` argument to `count()` do. When might you use it?
</div>

## Групповое изменение (и фильтрация)

* Найти члены каждой группы имеющие наихудшие показатели

```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time)

flights_sml %>% 
  group_by(year, month, day) %>%
  filter(rank(desc(arr_delay)) < 10)
```

* Найти все группы которым соответствует превышение порогового значения

```{r}
popular_dests <- flights %>% 
  group_by(dest) %>% 
  filter(n() > 365)
popular_dests
```

* Стандартизировать для вычисоения метрик групп

```{r}
popular_dests %>% 
  filter(arr_delay > 0) %>% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% 
  select(year:day, dest, arr_delay, prop_delay)
```

### Упражнение 5.7.1.1 {.unnumbered}
<div class="question">

</div>


