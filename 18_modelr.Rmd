---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Моделирование

Знакомимся с Exploratory data analysis (EDA) --- разведочный анализ данных.

Цель моделирования --- получение простых суммарных (сводных) характеристик набора данных.

Здесь разбриаем предсказательные модели анализа данных. Есть ещё много разных, например data discovery, но их здесь не рассматриваем

Базовые принципы корректного статистического вывода:

* Каждое наблюдение можно использовать либо для разведочного анализа, либо для подтверждения гипотезы. Но не для того и другого одновременно

* В целях разведочного анализа допускается многократное использование наблюдения, но в целях подтверждения гипотез --- только однократное. Использование одного и того же наблюдения более одного раза равносильно преходу от подтверждения гипотезы к разведочному анализу.

Данные используемые для подтверждения гипотезы не должны зависеть от данных на основании которых эта гипотеза была выдвинута.

### Выдвижение гипотез и их подтверждение

Один из подходов к анализу, направленному на подтверждение гипотезы, заключается в разбиении данных на три части ещё до того, как присутпить к анализу

* $60%$ --- training set. С этим набором можноделать всё что пожелается.

* $20%$ --- query set. Набор для сравнения моделей или вариантов визуализации вручную, но их не разрешается использовать в качестве части автоматизированного процесса.

* $20%$ --- test set. Эти данные можно использовать только один раз для тестирования окончательной модели.

## Базовое моделирование при помощи пакета `modelr`
### Введение

Цель моделирования --- определение суммарных характеристик набора данных. 

Моделирование включает два аспекта

1. Прежде всего необходимо определить семейство моделей. Они определяют типичную закономерность, например линейную или квадратичную зависимость. Семейство моделей описывается уравнением наподобие `y = a_1 * x + a_2` or `y = a_1 * x ^ a_2`. Где `x` и `y` --- известные переменные, а `a_1` и `a_2` варьируемые параметры.

2. Далее вы генерируете подходяющую модель, выбирая ту из семейства моделей, которая больше всего соответствует данным. В результате этого обобщенного уравнения семейства моделей конкретизируется принимая вид наподобие `y = 3 * x + 7`

Целью моделирования является не установление окончательной истины, а нахождение простого, но тем не менее полезного приближения

есл ваопао 

#### Необходимые ресурсы

```{r}
library(tidyverse)

library(modelr)
options(na.action = na.warn)
```

### Простая модель

Демонстрационный набор данный `sim1` содержит две непрерывные переменные `x` и `y`. Отложим их на графике, чтобы увидеть, как они связаны между собой

```{r}
ggplot(sim1, aes(x, y)) +
  geom_point()
```

между переменными наблюдается сильная взаимосвязь. Коэффициент корреляции

```{r}
cor(sim1$x, sim1$y)
```

Опишем эту взаимосвязь с помощью модели и выразим ее в явном виде.

Наша задача --- предоставить базовую форму модели. В данном случае мы используем линейное соотношение между переменными `y = a_0 + a_1 * x`.
Начнем с получения общего представления о том, как выглядят модели этого семейства. Путём случайной генерации некоторых из них и наложения их на данные.

В нашем случае можно использовать `geom_abline` --- она принимает наклон (slope), и y-пересечение (intercept).

```{r}
models <- tibble(
  a1 = runif(250, -20, 40),
  a2 = runif(250, -5, 5)
)

ggplot(sim1, aes(x, y)) + 
  geom_abline(
    aes(intercept = a1, slope = a2), 
    data = models, alpha = 1/4
  ) +
  geom_point()
```

Большинство из построенных моделей совсем неудачны. Нам нужен метод обеспечивающий количественную оценку расстояния между данными и моделью.

Это расстояние --- разность между значением предоставляемым моделью --- прогноз, и фактическим значением `y` согласно данным `data` --- результат.

[расстояния от результата до прогноза](img/model.png)

Для вычисления расстояния мы прежде всего превратим семейство моделей в функцию. 
В качестве аргументов, эта функция принимает параметры модели и данные, а в качестве выходного результата предоставляет значения, предсказанные моделью

```{r}
model1 <- function(a, data) {
  a[1] + data$x * a[2]
}

model1(c(7, 1.5), sim1)
sim1
```

Чтобы найти минимальное расстояние при помощи среднеквадратического отклонения.

```{r}
measure_distance <- function(mod, data) {
  diff <- data$y - model1(mod, data)
  sqrt(mean(diff ^ 2))
}
measure_distance(c(7, 1.5), sim1)
```

Теперь используем пакет `purrr` для того чтобы вычислить это расстояние для всех ранее определённых моделей. Нам нужна вспомогательная функция, поскольку наша функция вычисляющая расстояние лжидает модель в качестве числового вектора с длиной 2

```{r}
sim1_dist <- function(a1, a2) {
  measure_distance(c(a1, a2), sim1)
}

models <- models %>% 
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))
models
```

Выделим лучшие модели

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, color = "grey30") + 
  geom_abline(
    aes(intercept = a1, slope = a2, color = -dist), 
    data = filter(models, rank(dist) <= 10)
  )
```

Мы можем рассматривать эти модели как наблюдения и визуализировать их с помощью точечной диаграмы с осями `a1` и `a2`, опять таки расцветив их в соответстсвии со значениями `-dist`. При этом мы увидим множество моделей одновременно.
Выделим 10 лучшиъ моделей кржочками

```{r}
ggplot(models, aes(a1, a2)) +
  geom_point(data = filter(models, rank(dist) <= 10), size = 4, colour = "red") +
  geom_point(aes(colour = -dist))
```

Можно так же построить сетку поиска! Где точки расположены не хаотично, а упорядоченно

```{r}
grid <- expand.grid(
  a1 = seq(-2, 10, length = 25),
  a2 = seq(0, 2, length = 25)
  ) %>% 
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))

grid %>% 
  ggplot(aes(a1, a2)) +
  geom_point(data = filter(grid, rank(dist) <= 10), size = 4, colour = "red") +
  geom_point(aes(colour = -dist)) 
```

Если наложить эти 10 наилучших моделей на исходные данные, то они будут выглядеть довольно прилично

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(
    aes(intercept = a1, slope = a2, colour = -dist), 
    data = filter(grid, rank(dist) <= 10)
  )
```

но конечно самый простой способ это воспользоваться  функцией `lm()` для построения линейных моделей

```{r}
sim_mod <- lm(y ~ x, sim1)
coef(sim_mod)
```

```{r}
ggplot(sim1, aes(x, y)) + 
  geom_point(size = 2, colour = "grey30") + 
  geom_abline(intercept = coef(sim_mod)[1], slope = coef(sim_mod)[2])
```

