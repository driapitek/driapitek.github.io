---
editor_options:
  chunk_output_type: console
output:
  html_document: default
  pdf_document: default
---

## Трансформация данных
Поменять уровень вложенности главы когда разберусь как это делать

## Введение
### Используемые ресурсы

```{r, eval = FALSE}
library(nycflights13)
library(tidyverse)
library(dplyr)
```

Некоторые имена функций в разных библиотеках дублируются. Когда в `R` подключается несколько пакетов, в которых названия функций дублируются, программа выдает сообщение об ошибке

```{r, eval = FALSE}
── Conflicts ─────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
```

Для того чтобы обратится к необходимой функции, нужно использовать полное имя `stats::filter()`, `stats::lag()`

### Пакет `nycflights13`

|Переменная      | Описание       |
| ------------- |:-------------:|
| `int` | целые числа    |
| `dbl` | числа с плавающей точкой    |
| `chr` | символьные векторы или строки    |
| `dttm` | дата + время    |
| `lgl` | булевы векторы    |
| `fctr` |факторы   |
| `date` | даты    |

### Основные сведения о пакете `dplyr`

Минимум для работы с этим пакетом:

|Функция       | Описание    |
| ------------ |:-----------:|
| `filter()`   | выбор наблюдений по их значениям |
| `arrange()`  | перестановка строк |
| `select()`   | выбор переменных по их именам|
| `mutate()`   | создание новых переменных с использованием существующих|
| `summarize()`| сведение нескольких значений в одно итоговое |
| `group_by()` | изменяет область действия функции от всего набора данных до отдельных участков|

Все глаголы подчиняются одному и тому же синтаксису

1. Первый аргумент $-$ это фрейм данных

1. Последующие аргументы описывают действия, которые должны быть выполнены по отношению к фрейму данных.

1. Результат $-$ это новый фрейм данных

## Фильтрация строк с помощью функции `filter()`

Функция `filter()` позволяет что бы вы думали? позволяет фильтровать! Первым аргументом указываем фрейм данных, последующие аргументы, это параметры (столбцы) которые мы желаем отфильтровать через операторы сравнения.

```{r}
filter(flights, month == 1, day != 1)
```

Функция `filter()`, как и многие другие расширения пакета `dplyr`, не изменяют исходных данных. Желаемый фильтр нужно присвоить в новую переменную

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

Если нужно выполнить присвоение и вывод на экран, нужно обнять выражение скобками.

```{r}
(jan1 <- filter(flights, month == 1, day == 1))
```


### Сравнения

Операторы сравнения стандартные `>`, `>=`, `<`, `<=`, `==`, `!=` 

Компьюьеры используют арифметику конечной точности. Поэтому

```{r}
sqrt(2) ^ 2 == 1
```

### Логические операторы

Булевы операторы: И - `&`, ИЛИ - `|`, НЕ - `!`, исключающее ИЛИ - `xor()`.
Полный набор булевых операций показан на рисунке.

![alt text](img/transform-logical.png)

Что следует помнить. Добавляя булевы операторы в функцию `filter()` необходимо помнить, что сравнивать нужно программно, а не так как это звучит лексически. То есть, если мы хотим все авиарейсы отправленные в декабре и ноябре, нужно писать так.

```{r}
(filter(flights, month == 11 | month == 12))
```

Что дословно произносится как "отфильтровать все полёты из набора данных `flights`, вылетавших в месяце ноябре или в месяце декабре". Можно следовать лексическому соответствию, но для этого нужно использовать оператор `%in%`

```{r}
(filter(flights, month %in% c(11, 12)))
```

**Закон Моргана:**

* `!(x & y) == !x | !y`

* `!(x | y) == !x & !y`

Проверь на рисунке выше.

### Отсутствующие значения

Функция `filter()` включает в вывод лишь те строки, для которых условие имеет значение `TRUE`. `FALSE` и `NA` исключаются.

Для того чтобы проверить является ли используемое значением отсутствующим можно использовать функцию `is.na()`

### Упражнение 5.2.4.1 {.unnumbered} 
<div class="question">
Найдите все авиарейсы, которые
</div>

* а) задержались с прилётом на два и более часа

```{r}
(arr_delay <- filter(flights, arr_delay >= 120))
```

* б) вылетали в Хьюстон (аэропорты IAH и HOU)

```{r}
(hou_flight <- filter(flights, dest == "IAH" | dest == "HOU"))
```

* в) Обслуживались авиакомпаниями United, American or Delta

Для того чтобы узнать аббревиатуры перевозчиков, смотрим `airlanes`

```{r}
airlanes
```

Получается: United - это `UA`, American - `AA`, Delta - `DL`. Тогда искомые данные это:

```{r}
(three_carriers <- filter(flights, carrier %in% c("UA", "AA", "DL")))
```

* г) Вылетали в летнее время (июль, август, сентябрь). Странное у них летнее время

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

* д) Прилетали с опозданием более чем на два часа но не задерживались с вылетом

```{r}
(dep_arr_delay <- filter(flights, arr_delay > 120, dep_delay <= 0))
```

* е) Вылетали с задержкое не менее чем на час, но наверстывали более 30 минут во время полёта. Если полёт проходит ровно, то задержка отправления равна задержке прибытия. `Или dep_delay - arr_delay == 0`. Так как самолёт наверстал в пути, значит разница равна не нулю, она больше 30.

```{r}
(speedy_flights <- filter(flights, dep_delay >= 60, dep_delay - arr_delay > 30 ))
```

* ж) Вылетали между полуночью и 6 часами утра включительно

```{r}
(moon <- filter(flights, dep_time == 2400 | dep_time <= 600))
```

### Упражнение 5.2.4.2 {.unnumbered} 
<div class="question">
Another useful `dplyr` filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?
</div>

Из описания в хэлпе, функция `between()` это короткая запись для `>= left & x <= right`. Или если быть точным: `between(x, left, right)`. Конечно её гораздо удобнее использовать. Эту функцию можно применить к упражнению  *г*. Сравним:

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

```{r}
(sum_flights <- filter(flights, between(month, 7, 9)))
```

### Упражнение 5.2.4.3 {.unnumbered} 
<div class="question">
How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?
</div>

```{r}
(filter(flights, is.na(dep_time)))
```

Ответ 8255 рейсов. Так же отсутствуют: `dep_delay`, `arr_time`, `arr_delay`. Вероятно это отменённые рейсы.

### Упражнение 5.2.4.4 {.unnumbered} 
<div class="question">
Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing? Why is `FALSE & NA` not missing? Can you figure out the general rule? (`NA * 0` is a tricky counterexample!)
</div>

1. `NA ^ 0 == 1`. Всё в точности с математикой, которая говорит, что любое значение в степени 0 == 1 или точнее $x^0=1$

1. `NA | TRUE`. Всё или ПРАВДА всегда правда :

| $a$ | $b$ | $a\lor b$ |
| - |:-:||:-:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

1. `FALSE & NA`. Всё и ЛОЖЬ всегда Ложь.

| $a$ | $b$ | $a\land b$ |
| - |:-:||:-:|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

1. `NA * 0`. Причина по которой значение неопределено. Это то что умножение чего угодна на бесконечность, равно бесконечности, или правильнее - неопределённое значение. [нечисло](https://ru.wikipedia.org/wiki/NaN)


## Перестановка строк с помощью функции `arange()`

Синтаксис у этой функции такой же как у фильтра. `arranga()` сортирует по убыванию, а не фильтрует список. При этом отсутствующие значения всегда остаются в конце. При этом для сортировки по возрастанию используется функция `desc()`

### Упражнение 5.3.1.1 {.unnumbered} 
<div class="question">
How could you use `arrange()` to sort all missing values to the start? (Hint: use `is.na()`).
</div>

Берём пример из учебника.

```{r}
arrange(flights, desc(arr_delay))
```

Добавляем как подсказывают, функцию `is.na()`

```{r}
arrange(flights, desc(is.na(arr_delay)))
```

### Упражнение 5.3.1.2 {.unnumbered}
<div class="question">
Sort `flights` to find the most delayed flights. Find the flights that left earliest.
</div>

Чтобы найти рейсы с самыми большими задержками, сортируем по возрастанию соответствующий столбец `dep_delay`

```{r}
arrange(flights, desc(dep_delay))
```

Первые десять рейсов задерживались на время от 896 минут до 1301, это почти сутки (21 час) в аэропорте. Уффф.

Чтобы найти рейсы с самым ранним временем вылета, сортируем по убыванию соответствующий столбец `dep_time`

```{r}
arrange(flights, dep_time)
```

Ожидаемо, это время вылетов в полночь и минутой позднее.

### Упражнение 5.3.1.3 {.unnumbered}
<div class="question">
Sort `flights` to find the fastest flights.
</div>

Чтобы найти самые быстрые полёты, отсортируем все полёты по времени проведённому в воздухе. Это столбец `air_time` отсортированный по возрастанию.

```{r}
arrange(flights, air_time)
```

### Упражнение 5.3.1.4 {.unnumbered}
<div class="question">
Which flights traveled the longest? Which traveled the shortest?
</div>

Сделаем так, сначала отсортируем по расстоянию, а потом по времени проведённому в воздухе

```{r}
arrange(flights, desc(distance))
```

Самые длинные полёты из `JFK` в `HNL`. Из Нью-Йорка в Гонолулу - 4983 мили.

```{r}
arrange(flights, desc(distance))
```

[Полёт длится 691 минуту](https://www.google.com/maps/dir/Гонолулу+(HNL),+300+Rodgers+Blvd,+Honolulu,+HI+96819,+США/JFK+International+Airport,+New+York,+NY,+USA/@27.4344347,-126.6384014,4.03z/data=!4m14!4m13!1m5!1m1!1s0x7c006f943168f55f:0x7ed111b1cbf331df!2m2!1d-157.9250736!2d21.3245132!1m5!1m1!1s0x89c26650d5404947:0xec4fb213489f11f0!2m2!1d-73.7781391!2d40.6413111!3e4)


```{r}
arrange(flights, distance)
```

Самый короткий из `EWR` в `LGA`. Перелёт в пределах Нью-Йорка, который по всей видимости не состоялся, так как у него нету времени полёта. Следующий за ним это полёт из Нью-Арка в Филадельфию - 80 миль. Посмотрим ещё и по времени, проведённому в воздухе:

```{r}
arrange(flights, distance, air_time)
```

## Выбор столбцов с помощью функции `select()`

Функция `select()` помогает отобрать из фрейма данных необходимые столбцы. Синтаксис простой и привычный

* Указать конкретные столбцы можно через запятую 
```{r}
select(flights, year, month, day)
```

* Указать столбцы в промежутке
```{r}
select(flights, year:day)
```

* Выбрать всех столбцов за исключением тех, которые находятся между столбцами включая последние
```{r}
select(flights, -(year:day))
```

* `start_with("abc")` - соответствует именам, начинающимся с последовательности символов "abc"

* `end_with("abc")` - соответствует именам, заканчивающимся последовательностью символов "abc"

* `contains("abc")` - соответствует именам, содержащим последовательности символов "abc"

* `matches("(.)\\1")` - выбирает переменные, соответствующие регулярному выражению.

* `num_range("x", 1:3)` - соответствует `x1`, `x2`, `x3`

* Переименовать переменные, сохраняя все переменные не указанные в явном виде
```{r}
rename(flights, tail_num = tailnum)
```

* Переместить в начало переменные.
```{r}
select(flights, time_hour, air_time, everything())
```

### Упражнение 5.4.1.1 {.unnumbered}
<div class="question">
Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.
</div>


1. Указать конкретные столбцы через запятую
```{r}
select(flights, dep_time, dep_delay, arr_time, arr_delay)
```

1. Указать столбцы в промежутке и исключить лишние
```{r}
select(flights, dep_time:arr_delay, -sched_dep_time, -sched_arr_time)
```

1. Изощренный способ. Перенесём в начало нужные столбцы, отбросим лишние в промежутке
```{r}
new_flights <- select(flights, dep_time, dep_delay, arr_time, arr_delay, everything())
select(new_flights, -(year:time_hour))
```

1. Укажем номера столбцов
```{r}
select(flights, 4, 5, 6, 9)
```

1. Столбцы начинающиеся на `dep_` и `arr_`
```{r}
select(flights, starts_with("dep_"), starts_with("arr_"))
```

1. Столбцы содержащие и не содержащие
```{r}
select(flights, contains("_time"), contains("_delay"), -contains("sched"), -contains("air"))
```

### Упражнение 5.4.1.2 {.unnumbered}
<div class="question">
What happens if you include the name of a variable multiple times in a `select()` call?
</div>

Если одна и та же переменная указана несколько раз, она всё равно отобразится один раз
```{r}
select(flights, dep_time, dep_time, dep_time)
```

### Упражнение 5.4.1.3 {.unnumbered}
<div class="question">
What does the `one_of()` function do? Why might it be helpful in conjunction with this vector?
</div>

Функция `one_of()` берёт переменные в символьном векторе. Это может быть полезно, если как в примере у нас есть символьный вектор значений, которые необходимо взять

```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, one_of(vars))
```

### Упражнение 5.4.1.4 {.unnumbered}
<div class="question">
Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?
</div>

```{r}
select(flights, contains("TIME"))
```

Удивительно, что `contains()` невосприимчив к регистру:

```{r}
select(flights, contains("time"))
```

Оказывается, это регшулируется параметром `ignore.case` который по умолчанию `TRUE`:

```{r}
select(flights, contains("TIME", ignore.case = FALSE))
```


Вот список всех функций, согласно хэлпу, невосприимчивых по умолчанию к регистру:

* `starts_with(match, ignore.case = TRUE, vars = peek_vars())`

* `ends_with(match, ignore.case = TRUE, vars = peek_vars())`

* `contains(match, ignore.case = TRUE, vars = peek_vars())`

* `matches(match, ignore.case = TRUE, vars = peek_vars())`

## Добавление столбцов с помощью функции `mutate()`
