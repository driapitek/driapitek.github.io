---
editor_options:
  chunk_output_type: console
output:
  pdf_document: default
  html_document: default
---

## Трансформация данных
Поменять уровень вложенности главы когда разберусь как это делать

## Введение
### Используемые ресурсы

```{r, eval = FALSE}
library(nycflights13)
library(tidyverse)
library(dplyr)
```

Некоторые имена функций в разных библиотеках дублируются. Когда в `R` подключается несколько пакетов, в которых названия функций дублируются, программа выдает сообщение об ошибке

```{r, eval = FALSE}
── Conflicts ─────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
```

Для того чтобы обратится к необходимой функции, нужно использовать полное имя `stats::filter()`, `stats::lag()`

### Пакет `nycflights13`

|Переменная      | Описание       |
| ------------- |:-------------:|
| `int` | целые числа    |
| `dbl` | числа с плавающей точкой    |
| `chr` | символьные векторы или строки    |
| `dttm` | дата + время    |
| `lgl` | булевы векторы    |
| `fctr` |факторы   |
| `date` | даты    |

### Основные сведения о пакете `dplyr`

Минимум для работы с этим пакетом:

|Функция       | Описание    |
| ------------ |:-----------:|
| `filter()`   | выбор наблюдений по их значениям |
| `arrange()`  | перестановка строк |
| `select()`   | выбор переменных по их именам|
| `mutate()`   | создание новых переменных с использованием существующих|
| `summarize()`| сведение нескольких значений в одно итоговое |
| `group_by()` | изменяет область действия функции от всего набора данных до отдельных участков|

Все глаголы подчиняются одному и тому же синтаксису

1. Первый аргумент $-$ это фрейм данных

1. Последующие аргументы описывают действия, которые должны быть выполнены по отношению к фрейму данных.

1. Результат $-$ это новый фрейм данных

## Фильтрация строк с помощью функции `filter()`

Функция `filter()` позволяет что бы вы думали? позволяет фильтровать! Первым аргументом указываем фрейм данных, последующие аргументы, это параметры (столбцы) которые мы желаем отфильтровать через операторы сравнения.

```{r}
filter(flights, month == 1, day != 1)
```

Функция `filter()`, как и многие другие расширения пакета `dplyr`, не изменяют исходных данных. Желаемый фильтр нужно присвоить в новую переменную

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

Если нужно выполнить присвоение и вывод на экран, нужно обнять выражение скобками.

```{r}
(jan1 <- filter(flights, month == 1, day == 1))
```


### Сравнения

Операторы сравнения стандартные `>`, `>=`, `<`, `<=`, `==`, `!=` 

Компьюьеры используют арифметику конечной точности. Поэтому

```{r}
sqrt(2) ^ 2 == 1
```

### Логические операторы

Булевы операторы: И - `&`, ИЛИ - `|`, НЕ - `!`, исключающее ИЛИ - `xor()`.
Полный набор булевых операций показан на рисунке.

![alt text](img/transform-logical.png)

Что следует помнить. Добавляя булевы операторы в функцию `filter()` необходимо помнить, что сравнивать нужно программно, а не так как это звучит лексически. То есть, если мы хотим все авиарейсы отправленные в декабре и ноябре, нужно писать так.

```{r}
(filter(flights, month == 11 | month == 12))
```

Что дословно произносится как "отфильтровать все полёты из набора данных `flights`, вылетавших в месяце ноябре или в месяце декабре". Можно следовать лексическому соответствию, но для этого нужно использовать оператор `%in%`

```{r}
(filter(flights, month %in% c(11, 12)))
```

**Закон Моргана:**

* `!(x & y) == !x | !y`

* `!(x | y) == !x & !y`

Проверь на рисунке выше.

### Отсутствующие значения

Функция `filter()` включает в вывод лишь те строки, для которых условие имеет значение `TRUE`. `FALSE` и `NA` исключаются.

### Упражнение 5.2.4.1 {.unnumbered} 
<div class="question">
Найдите все авиарейсы, которые
</div>

* а) задержались с прилётом на два и более часа

```{r}
(arr_delay <- filter(flights, arr_delay >= 120))
```

* б) вылетали в Хьюстон (аэропорты IAH и HOU)

```{r}
(hou_flight <- filter(flights, dest == "IAH" | dest == "HOU"))
```

* в) Обслуживались авиакомпаниями United, American or Delta

Для того чтобы узнать аббревиатуры перевозчиков, смотрим `airlanes`

```{r}
airlanes
```

Получается: United - это `UA`, American - `AA`, Delta - `DL`. Тогда искомые данные это:

```{r}
(three_carriers <- filter(flights, carrier %in% c("UA", "AA", "DL")))
```

* г) Вылетали в летнее время (июль, август, сентябрь). Странное у них летнее время

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

* д) Прилетали с опозданием более чем на два часа но не задерживались с вылетом

```{r}
(dep_arr_delay <- filter(flights, arr_delay > 120, dep_delay <= 0))
```

* е) Вылетали с задержкое не менее чем на час, но наверстывали более 30 минут во время полёта. Если полёт проходит ровно, то задержка отправления равна задержке прибытия. `Или dep_delay - arr_delay == 0`. Так как самолёт наверстал в пути, значит разница равна не нулю, она больше 30.

```{r}
(speedy_flights <- filter(flights, dep_delay >= 60, dep_delay - arr_delay > 30 ))
```

* ж) Вылетали между полуночью и 6 часами утра включительно

```{r}
(moon <- filter(flights, dep_time == 2400 | dep_time <= 600))
```

### Упражнение 5.2.4.2 {.unnumbered} 
<div class="question">
Another useful `dplyr` filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?
</div>

Из описания в хэлпе, функция `between()` это короткая запись для `>= left & x <= right`. Или если быть точным: `between(x, left, right)`. Конечно её гораздо удобнее использовать. Эту функцию можно применить к упражнению  *г*. Сравним:

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

```{r}
(sum_flights <- filter(flights, between(month, 7, 9)))
```
