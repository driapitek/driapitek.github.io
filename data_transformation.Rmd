---
editor_options:
  chunk_output_type: console
output:
  html_document: default
  pdf_document: default
---

## Трансформация данных
Поменять уровень вложенности главы когда разберусь как это делать

## Введение
### Используемые ресурсы

```{r, eval = FALSE}
library(nycflights13)
library(tidyverse)
library(dplyr)
```

Некоторые имена функций в разных библиотеках дублируются. Когда в `R` подключается несколько пакетов, в которых названия функций дублируются, программа выдает сообщение об ошибке

```{r, eval = FALSE}
── Conflicts ─────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
```

Для того чтобы обратится к необходимой функции, нужно использовать полное имя `stats::filter()`, `stats::lag()`

### Пакет `nycflights13`

|Переменная      | Описание       |
| ------------- |:-------------:|
| `int` | целые числа    |
| `dbl` | числа с плавающей точкой    |
| `chr` | символьные векторы или строки    |
| `dttm` | дата + время    |
| `lgl` | булевы векторы    |
| `fctr` |факторы   |
| `date` | даты    |

### Основные сведения о пакете `dplyr`

Минимум для работы с этим пакетом:

|Функция       | Описание    |
| ------------ |:-----------:|
| `filter()`   | выбор наблюдений по их значениям |
| `arrange()`  | перестановка строк |
| `select()`   | выбор переменных по их именам|
| `mutate()`   | создание новых переменных с использованием существующих|
| `summarize()`| сведение нескольких значений в одно итоговое |
| `group_by()` | изменяет область действия функции от всего набора данных до отдельных участков|

Все глаголы подчиняются одному и тому же синтаксису

1. Первый аргумент $-$ это фрейм данных

1. Последующие аргументы описывают действия, которые должны быть выполнены по отношению к фрейму данных.

1. Результат $-$ это новый фрейм данных

## Фильтрация строк с помощью функции `filter()`

Функция `filter()` позволяет что бы вы думали? позволяет фильтровать! Первым аргументом указываем фрейм данных, последующие аргументы, это параметры (столбцы) которые мы желаем отфильтровать через операторы сравнения.

```{r}
filter(flights, month == 1, day != 1)
```

Функция `filter()`, как и многие другие расширения пакета `dplyr`, не изменяют исходных данных. Желаемый фильтр нужно присвоить в новую переменную

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

Если нужно выполнить присвоение и вывод на экран, нужно обнять выражение скобками.

```{r}
(jan1 <- filter(flights, month == 1, day == 1))
```


### Сравнения

Операторы сравнения стандартные `>`, `>=`, `<`, `<=`, `==`, `!=` 

Компьюьеры используют арифметику конечной точности. Поэтому

```{r}
sqrt(2) ^ 2 == 1
```

### Логические операторы

Булевы операторы: И - `&`, ИЛИ - `|`, НЕ - `!`, исключающее ИЛИ - `xor()`.
Полный набор булевых операций показан на рисунке.

![alt text](img/transform-logical.png)

Что следует помнить. Добавляя булевы операторы в функцию `filter()` необходимо помнить, что сравнивать нужно программно, а не так как это звучит лексически. То есть, если мы хотим все авиарейсы отправленные в декабре и ноябре, нужно писать так.

```{r}
(filter(flights, month == 11 | month == 12))
```

Что дословно произносится как "отфильтровать все полёты из набора данных `flights`, вылетавших в месяце ноябре или в месяце декабре". Можно следовать лексическому соответствию, но для этого нужно использовать оператор `%in%`

```{r}
(filter(flights, month %in% c(11, 12)))
```

**Закон Моргана:**

* `!(x & y) == !x | !y`

* `!(x | y) == !x & !y`

Проверь на рисунке выше.

### Отсутствующие значения

Функция `filter()` включает в вывод лишь те строки, для которых условие имеет значение `TRUE`. `FALSE` и `NA` исключаются.

Для того чтобы проверить является ли используемое значением отсутствующим можно использовать функцию `is.na()`

### Упражнение 5.2.4.1 {.unnumbered} 
<div class="question">
Найдите все авиарейсы, которые
</div>

* а) задержались с прилётом на два и более часа

```{r}
(arr_delay <- filter(flights, arr_delay >= 120))
```

* б) вылетали в Хьюстон (аэропорты IAH и HOU)

```{r}
(hou_flight <- filter(flights, dest == "IAH" | dest == "HOU"))
```

* в) Обслуживались авиакомпаниями United, American or Delta

Для того чтобы узнать аббревиатуры перевозчиков, смотрим `airlanes`

```{r}
airlanes
```

Получается: United - это `UA`, American - `AA`, Delta - `DL`. Тогда искомые данные это:

```{r}
(three_carriers <- filter(flights, carrier %in% c("UA", "AA", "DL")))
```

* г) Вылетали в летнее время (июль, август, сентябрь). Странное у них летнее время

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

* д) Прилетали с опозданием более чем на два часа но не задерживались с вылетом

```{r}
(dep_arr_delay <- filter(flights, arr_delay > 120, dep_delay <= 0))
```

* е) Вылетали с задержкое не менее чем на час, но наверстывали более 30 минут во время полёта. Если полёт проходит ровно, то задержка отправления равна задержке прибытия. `Или dep_delay - arr_delay == 0`. Так как самолёт наверстал в пути, значит разница равна не нулю, она больше 30.

```{r}
(speedy_flights <- filter(flights, dep_delay >= 60, dep_delay - arr_delay > 30 ))
```

* ж) Вылетали между полуночью и 6 часами утра включительно

```{r}
(moon <- filter(flights, dep_time == 2400 | dep_time <= 600))
```

### Упражнение 5.2.4.2 {.unnumbered} 
<div class="question">
Another useful `dplyr` filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?
</div>

Из описания в хэлпе, функция `between()` это короткая запись для `>= left & x <= right`. Или если быть точным: `between(x, left, right)`. Конечно её гораздо удобнее использовать. Эту функцию можно применить к упражнению  *г*. Сравним:

```{r}
(sum_flights <- filter(flights, month %in% c(7, 8, 9)))
```

```{r}
(sum_flights <- filter(flights, between(month, 7, 9)))
```

### Упражнение 5.2.4.3 {.unnumbered} 
<div class="question">
How many flights have a missing `dep_time`? What other variables are missing? What might these rows represent?
</div>

```{r}
(filter(flights, is.na(dep_time)))
```

Ответ 8255 рейсов. Так же отсутствуют: `dep_delay`, `arr_time`, `arr_delay`. Вероятно это отменённые рейсы.

### Упражнение 5.2.4.4 {.unnumbered} 
<div class="question">
Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing? Why is `FALSE & NA` not missing? Can you figure out the general rule? (`NA * 0` is a tricky counterexample!)
</div>

1. `NA ^ 0 == 1`. Всё в точности с математикой, которая говорит, что любое значение в степени 0 == 1 или точнее $x^0=1$

1. `NA | TRUE`. Всё или ПРАВДА всегда правда :

| $a$ | $b$ | $a\lor b$ |
| - |:-:||:-:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

1. `FALSE & NA`. Всё и ЛОЖЬ всегда Ложь.

| $a$ | $b$ | $a\land b$ |
| - |:-:||:-:|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

1. `NA * 0`. Причина по которой значение неопределено. Это то что умножение чего угодна на бесконечность, равно бесконечности, или правильнее - неопределённое значение. [нечисло](https://ru.wikipedia.org/wiki/NaN)


## Перестановка строк с помощью функции `arange()`

Синтаксис у этой функции такой же как у фильтра. `arranga()` сортирует по убыванию, а не фильтрует список. При этом отсутствующие значения всегда остаются в конце. При этом для сортировки по возрастанию используется функция `desc()`

### Упражнение 5.3.1.1 {.unnumbered} 
<div class="question">
How could you use `arrange()` to sort all missing values to the start? (Hint: use `is.na()`).
</div>

Берём пример из учебника.

```{r}
arrange(flights, desc(arr_delay))
```

Добавляем как подсказывают, функцию `is.na()`

```{r}
arrange(flights, desc(is.na(arr_delay)))
```

### Упражнение 5.3.1.2 {.unnumbered}
<div class="question">
Sort `flights` to find the most delayed flights. Find the flights that left earliest.
</div>

Чтобы найти рейсы с самыми большими задержками, сортируем по возрастанию соответствующий столбец `dep_delay`

```{r}
arrange(flights, desc(dep_delay))
```

Первые десять рейсов задерживались на время от 896 минут до 1301, это почти сутки (21 час) в аэропорте. Уффф.

Чтобы найти рейсы с самым ранним временем вылета, сортируем по убыванию соответствующий столбец `dep_time`

```{r}
arrange(flights, dep_time)
```

Ожидаемо, это время вылетов в полночь и минутой позднее.

### Упражнение 5.3.1.3 {.unnumbered}
<div class="question">
Sort `flights` to find the fastest flights.
</div>

Чтобы найти самые быстрые полёты, отсортируем все полёты по времени проведённому в воздухе. Это столбец `air_time` отсортированный по возрастанию.

```{r}
arrange(flights, air_time)
```

### Упражнение 5.3.1.4 {.unnumbered}
<div class="question">
Which flights traveled the longest? Which traveled the shortest?
</div>

Сделаем так, сначала отсортируем по расстоянию, а потом по времени проведённому в воздухе

```{r}
arrange(flights, desc(distance))
```

Самые длинные полёты из `JFK` в `HNL`. Из Нью-Йорка в Гонолулу - 4983 мили.

```{r}
arrange(flights, desc(distance))
```

[Полёт длится 691 минуту](https://www.google.com/maps/dir/Гонолулу+(HNL),+300+Rodgers+Blvd,+Honolulu,+HI+96819,+США/JFK+International+Airport,+New+York,+NY,+USA/@27.4344347,-126.6384014,4.03z/data=!4m14!4m13!1m5!1m1!1s0x7c006f943168f55f:0x7ed111b1cbf331df!2m2!1d-157.9250736!2d21.3245132!1m5!1m1!1s0x89c26650d5404947:0xec4fb213489f11f0!2m2!1d-73.7781391!2d40.6413111!3e4)


```{r}
arrange(flights, distance)
```

Самый короткий из `EWR` в `LGA`. Перелёт в пределах Нью-Йорка, который по всей видимости не состоялся, так как у него нету времени полёта. Следующий за ним это полёт из Нью-Арка в Филадельфию - 80 миль. Посмотрим ещё и по времени, проведённому в воздухе:

```{r}
arrange(flights, distance, air_time)
```

## Выбор столбцов с помощью функции `select()`

Функция `select()` помогает отобрать из фрейма данных необходимые столбцы. Синтаксис простой и привычный

* Указать конкретные столбцы можно через запятую 
```{r}
select(flights, year, month, day)
```

* Указать столбцы в промежутке
```{r}
select(flights, year:day)
```

* Выбрать всех столбцов за исключением тех, которые находятся между столбцами включая последние
```{r}
select(flights, -(year:day))
```

* `start_with("abc")` - соответствует именам, начинающимся с последовательности символов "abc"

* `end_with("abc")` - соответствует именам, заканчивающимся последовательностью символов "abc"

* `contains("abc")` - соответствует именам, содержащим последовательности символов "abc"

* `matches("(.)\\1")` - выбирает переменные, соответствующие регулярному выражению.

* `num_range("x", 1:3)` - соответствует `x1`, `x2`, `x3`

* Переименовать переменные, сохраняя все переменные не указанные в явном виде
```{r}
rename(flights, tail_num = tailnum)
```

* Переместить в начало переменные.
```{r}
select(flights, time_hour, air_time, everything())
```

### Упражнение 5.4.1.1 {.unnumbered}
<div class="question">
Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, `arr_time`, and `arr_delay` from `flights`.
</div>


1. Указать конкретные столбцы через запятую
```{r}
select(flights, dep_time, dep_delay, arr_time, arr_delay)
```

1. Указать столбцы в промежутке и исключить лишние
```{r}
select(flights, dep_time:arr_delay, -sched_dep_time, -sched_arr_time)
```

1. Изощренный способ. Перенесём в начало нужные столбцы, отбросим лишние в промежутке
```{r}
new_flights <- select(flights, dep_time, dep_delay, arr_time, arr_delay, everything())
select(new_flights, -(year:time_hour))
```

1. Укажем номера столбцов
```{r}
select(flights, 4, 5, 6, 9)
```

1. Столбцы начинающиеся на `dep_` и `arr_`
```{r}
select(flights, starts_with("dep_"), starts_with("arr_"))
```

1. Столбцы содержащие и не содержащие
```{r}
select(flights, contains("_time"), contains("_delay"), -contains("sched"), -contains("air"))
```

### Упражнение 5.4.1.2 {.unnumbered}
<div class="question">
What happens if you include the name of a variable multiple times in a `select()` call?
</div>

Если одна и та же переменная указана несколько раз, она всё равно отобразится один раз
```{r}
select(flights, dep_time, dep_time, dep_time)
```

### Упражнение 5.4.1.3 {.unnumbered}
<div class="question">
What does the `one_of()` function do? Why might it be helpful in conjunction with this vector?
</div>

Функция `one_of()` берёт переменные в символьном векторе. Это может быть полезно, если как в примере у нас есть символьный вектор значений, которые необходимо взять

```{r}
vars <- c("year", "month", "day", "dep_delay", "arr_delay")
select(flights, one_of(vars))
```

### Упражнение 5.4.1.4 {.unnumbered}
<div class="question">
Does the result of running the following code surprise you? How do the select helpers deal with case by default? How can you change that default?
</div>

```{r}
select(flights, contains("TIME"))
```

Удивительно, что `contains()` невосприимчив к регистру:

```{r}
select(flights, contains("time"))
```

Оказывается, это регшулируется параметром `ignore.case` который по умолчанию `TRUE`:

```{r}
select(flights, contains("TIME", ignore.case = FALSE))
```


Вот список всех функций, согласно хэлпу, невосприимчивых по умолчанию к регистру:

* `starts_with(match, ignore.case = TRUE, vars = peek_vars())`

* `ends_with(match, ignore.case = TRUE, vars = peek_vars())`

* `contains(match, ignore.case = TRUE, vars = peek_vars())`

* `matches(match, ignore.case = TRUE, vars = peek_vars())`

## Добавление столбцов с помощью функции `mutate()`

Функция `mutate()` позволяет добавлять в конец исходного фрейма данных столбцы. 

Сделаем чуть более показательный набор данных:
```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
```


Теперь добавим в конец этого набора дополнительные вычисления
```{r}
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)
```

Чтобы сохранить только вычисления, без указания дополнительных столбцов, используется функция `transmute()`

```{r}
transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

### Полезные функции создания объектов

* Арифметические операторы `+`, `-`, `*`, `/`, `^`

* Модулярная арифметика. Целочисленное деление - `%/%`. Взятие остатка - `%%`. Показательный пример:

```{r}
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

* Логарифмические функции `log()`, `log2`, `log10()`

* Смещения. Вперёд - `lag()`. Назад - `lead()`

* Кумулятивные и скользящие агрегаты. `cumsum()`, `cummin()`, `cumprod()`, `cummax()`, `cummean()`

* Логические операторы `<`, `>`, `>=`, `<=`, `!=`

* Ранжирование. Функции ранжирования `row_number(x)`, `ntile(x, n)`, `min_rank(x)`, `dense_rank(x)`,`percent_rank(x)`, `cume_dist(x)`. В этих функциях `desc()` меняет направление.

### Упражнение 5.5.2.1 {.unnumbered}
<div class="question">
Currently `dep_time` and `sched_dep_time` are convenient to look at, but hard to compute with because they’re not really continuous numbers. Convert them to a more convenient representation of number of minutes since midnight.
</div>

Заданные параметры `dep_time` and `sched_dep_time` записаны в формате HHMM. Чтобы получить из исходных данных последовательный формат, необходимо произвести целочисленное деление на 100, и к результату добавить остаток от деления.

```{r}
transmute(flights,
  dep_time,
  sched_dep_time,
  dep_time_minute = ((dep_time %/% 100) * 60) + dep_time %% 100,
  sched_dep_time_minute = ((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100
)
```

Можно добавить эти значения в исходную выборку:
```{r}
mutate(flights,
  dep_time_minute = ((dep_time %/% 100) * 60) + dep_time %% 100,
  sched_dep_time_minute = ((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100
)
```

### Упражнение 5.5.2.2 {.unnumbered}
<div class="question">
Compare `air_time` with `arr_time - dep_time`. What do you expect to see? What do you see? What do you need to do to fix it?
</div>

Значения данных `dep_time` и `arr_time` это время отправления и время прибытия соответственно записанные в формате HHMM. `air_time` - это время полёта, записанное в минутах. Естественно, если мы просто вычтем из времени прибытия время отправления в текущем формате, мы не получим `air_time`.

Таким образом, моё предположение сводится к следующему - чтобы разность `arr_time - dep_time` и `air_time` совпадали, необходимо:

1. для начала привести их к общей форме записи в минутах.

```{r}
transmute(flights,
  air_time,
  arr_minus_dep = (((arr_time %/% 100) * 60) + arr_time %% 100) - (((dep_time %/% 100) * 60) + dep_time %% 100)
)
```

1. затем необходимо учесть прилёт на другой день

1. и ещё необходимо учитывать разное время часовых поясов отлёта и прибытия, так как время в данных указано локальное

Так как два последних предположения текущим набором данных мне проверить не предвидится возможным, я заглядываю в подсказку

В имеющимся в сети [решении](https://jrnold.github.io/r4ds-exercise-solutions/data-transformation.html) заданий от пользователя jrnold я нашёл что, в своём предположении я не учёл особенность сбора данных. Особенность заключается в том, что время отправления и время прибытия считаются от момента когда самолёт оторвал шасси и коснулся земли соответсвенно. В это время не входит время проведённое при посадке и прохождении регистрации, которое учитано в `air_time`.

### Упражнение 5.5.2.3 {.unnumbered}
<div class="question">
Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you expect those three numbers to be related?
</div>

Разберёмся в том, что каждый столбец данных представляет.

* `sched_dep_time` - это запланированное время вылета в формате HHMM по местному времени

* `dep_time` - это актуальное время вылета в формате HHMM по местному времени

* `dep_delay` - это время задержки вылета в минутах. Отрицательное время будет показывать ранний вылет.

То есть по сути `dep_delay` это разность между актуальным временем вылета и запланированным временем. Чтобы разность `dep_time - sched_dep_time` соотносилась с `dep_delay`, формат HHMM необходимо перевести в минуты.

```{r}
flights_new_dep <- mutate(flights,
  dep_delay_ng = dep_time - sched_dep_time,
  dep_delay_ok = (((dep_time %/% 100) * 60) + dep_time %% 100) - 
    (((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100))
```

Однако подобный формат записи приводит к тому, что если вылет фактический и вылет планируемый находятся по разную сторону от полуночи, то разница будет большой либо в отрицательную, либо в положительную сторону. Что конечно же не соответствует фактическому времени задержки. 
Тут вроде бы `dep_delay` и полученный в результате приведения к одному формату и разности планируемого и фактического времени `dep_delay_ok` сходятся. Однако уже даже при обратной сортировке видно, что есть большие различия, связанные, как я уже сказал, с особенностью внесения этих данных:

```{r}
new_delay <- select(flights_new_dep, dep_delay_ok, dep_delay, dep_delay_ng)
arrange(new_delay, desc(dep_delay))
```

### Упражнение 5.5.2.4 {.unnumbered}
<div class="question">

</div>







### Упражнение 5.5.2.5 {.unnumbered}
<div class="question">

</div>





### Упражнение 5.5.2.6 {.unnumbered}
<div class="question">
What trigonometric functions does R provide?
</div>

В R есть следующие тригонометрические функции.

* Простые: `cos(x)`, `sin(x)`, `tan(x)`

* Арки `acos(x)`, `asin(x)`, `atan(x)`, `atan2(y, x)`

* И ещё `cospi(x)`, `sinpi(x)`, `tanpi(x)`

## Получение групповых итогов с помощью функции `summarize()`