---
output: html_document
editor_options: 
  chunk_output_type: console
---


## Аккуратизация данных с помощью пакета `tidyr`

### Введение

В этой главе будем узнавать что такое аккуратные данные. Больше про это рассказал Хэдли Уикем в своей [статье](http://www.jstatsoft.org/v59/i10/paper)

#### Необходимые ресурсы

Подключаем библиотеку

```{r}
library("tidyverse")
```


### Аккуратные данные

Существует три правила, соблюдение которых делает набор данных аккуратным:

* каждая переменная должна иметь собственный столбец

* каждое наблюдение должно иметь собственную строку

* каждое значение должно иметь собственную ячейку

Все они взаимосвязаны --- без одного не может быть дву других. Всё это хорошо иллюстрирует изображение

![alt text](img/tidy-1.png)

Всё можно упростить до двух правил 

1. Помещать каждый набор данных в tibble-фрейм

1. Помещеать каждую переменную в столбец

В учебнике было не понятно почему на оси лет такое странное отображение годов.
```{r}
library("ggplot2")
ggplot(table1, aes(year, cases)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country)) 
```

Но когда построил сам врубился --- между точками построения двух годов программа просто добавила 4 промежутка по 0.25

#### Упражнения 12.2.1.1
<div class="question">
Using prose, describe how the variables and observations are organised in each of the sample tables
</div>

```{r}
table1
table2
table3
table4a
table4b
```

1. Таблица 1

Таблица состоит из четырех столбцов-переменных. 
Первый столбец --- категориальная переменная, в которую входят названия трёх стран. 
Второй столбец --- это тоже категориальная переменная, в которой содержатся года в которые происходили наблюдения их два. 
Третий столбец --- это непрерывная переменная "случаи", которая показывает количество случаев происходящих в каждой стране в указанный год
Четвёртый столбец --- тоже непрерывная переменная, которая показывает количество населения соотвтствующее комбинации страна-год-случай

Или если совсем просто:

* Одно наблюдение соответствует одной строке. 
* Одна переменная соответствует одному наблюдению. 
* Одна ячейка соответствует одному значению.

1. Таблица 2

* Одно наблюдение разбито переменной (type) на две строки. В остальном, всё хорошо:
* Одна переменная соответствует одному столбцу
* Одна ячейка соответствует одному значению.

1. Таблица 3

* Одно наблюдение соответствует одной строке. 
* Одна переменная соответствует одному наблюдению. 
* Но в одной ячейке содержится два значения --- (cases/population)

1. Таблицы 4а, 4b

В отдельности эти таблицы являются аккуратными. Но так как они описывают одно измерение, произведено неудобное разделение по переменным ---- (cases) таблица `а` и (population) таблица `b`

#### Упражнения 12.2.1.2
<div class="question">
Compute the rate for table2, and table4a + table4b. You will need to perform four operations:

a) Extract the number of TB cases per country per year.
b) Extract the matching population per country per year.
c) Divide cases by population, and multiply by 10000.
d) Store back in the appropriate place.
e) Which representation is easiest to work with? Which is hardest? Why?</div>
</div>

a) Не очень хорошо получилось. Потому что это просто один столбец значений, без указания года в котором произошло событие.

```{r}
t2_cases <- filter(table2, type == "cases")           # Извлекаем число случаев заболевания
t2_population <- filter(table2, type == "population") # Извлекаем число популяции
t2_rate <- cases$count / population$count * 10000     # Находим отношение
rate <- as.tibble(t2_rate)                            # Сохраняем куда-то
```

Поэтому немного переделаем, чтобы было по красоте

```{r}
t2_cases <- filter(table2, type == "cases") %>%            # Извлекаем число случаев заболевания
  rename(cases = count) %>%                                # Переименовываем стобец
  arrange(country, year)                                   # Сортируем, чтобы избежать ошибок
t2_population <- filter(table2, type == "population") %>%  # Действуем по аналогии и для популяции
  rename(population = count) %>%
  arrange(country, year)
t2_rate <- t2_cases %>% 
  mutate(population = t2_population$population,            # Добавляем переменную популяции
         cases_per_cap = (cases / population) * 10000) %>% # Добавляем переменную с отношением
  select(country, year, cases_per_cap)                     # Оставляем только нужное
```

b) Грязненько это вот так. Разделить отдельно каждый год, и объединить полученные вектора в одну матрицу, а её превратить в тиббл таблицу. Это решение в лоб.

```{r}
table4_1999 <- table4a$`1999` / table4b$`1999` * 10000
table4_2000 <- table4a$`2000` / table4b$`2000` * 10000
table4_rate <- as.tibble(cbind(table4_1999, table4_2000))
```

Элегантнее вот так вот:

```{r}
table4c <-
  tibble(country = table4a$country,
         `1999` = table4a[["1999"]] / table4b[["1999"]] * 10000,
         `2000` = table4a[["2000"]] / table4b[["2000"]] * 10000)
```

Я уже говорил выше, что таблицы 4а и 4b в отрыве друг от друга аккуратные tibble таблицы. Поэтому с ними проще и приятнее работать, чем с "грязной" таблицей номер 2.

#### Упражнения 12.2.1.3
<div class="question">
Recreate the plot showing change in cases over time using table2 instead of table1. What do you need to do first?
</div>

Для того чтобы построить график, нужно для начала высчитать то, что мы проделали в упражнении 2: извлечь все значения для каждого года в отдельности.

```{r}
ggplot(t2_rate, aes(year, cases_per_cap)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country))
```

### Рассредоточение и сведение столбцов

Чаще всего придётся иметь дело с неаккуратными данными, потому что

* Большинство людей не знакомы с принципами аккуратных данных

* Чаще всего данные используют таким образом чтобы упростить ввод, а не анализ

Для большинства видов практического анализа мне чаще всего предстоит приводить данные в аккуратный вид. Для это прежде всего предстоит выяснить какие переменные и наблюдения имеются --- что у нас в столбцах и что в строках. Иногда это бывает просто, но в большинстве случаев необходимо интервьюировать тех людей, которые эти данные вносили. На этом этапе как правило предстоит реашть одну из некоторых задач:

* одна перменная может быть разнесена по нескольким столбцам

* одно наблюдение может быть рассредоточено по нескольким строкам

Типичные наборы данных страдают одним из этих недостатков. Столкнувшись сразу с двумя из них надо понимать, что мне крупно неповезло. Чтобы решать эти проблемы мне пригодятся две функции `gather()` и `spread()`.

#### Сведение столбцов (gather)

На примере набора данных `table4a` покажем что часто названия столбцов являются значениями переменных

```{r}
table4a
```

Названия столбцов здесь `1999` и `2000` это значения перменной `year`, а каждая строка представляет два наблюдения, а не одно

ЧТобы привести набор данных, подобный этому к аккуратному виду, мы должны свести стобцы в новую пару переменных. Для описания этой операции нам понадобится следующие три параметра

* Набор столбцов, которые прдеставляют значения, а не переменные. В данном примере таковым являются стобцы `1999` и `2000`.

* Имя переменной, значения которой образуют имена столбцов. Этот парамер `key`, а переменная в данном примере является `year`.

* Имя переменной, значения которой рассредоточены по ячейкам. Это параметр `value`, а переменной в данном случае является количество случаев заболевания.

Все эти параметры используются при вызове функции `gather()`

```{r}
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
```

Наглядно это делается следующим образом:
![alt text](img/tidy-9.png)

Столбцы, которые необходимо светсти, указываются с использованием нотации в стиле `dplyr::select()`. В данном случае таких столбцов только два, поэтому мы задаем их по отдельности.

ТО же самое проделывается по сути и для популяции

```{r}
table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")
```

А теперь, чтобы их свести используется функция, о которой я узнаю чуть позже. Она чудесным образом (пока что)
 объединяет фреймы данных

 
```{r}
tidy4a <- table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
tidy4b <- table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")

left_join(tidy4a, tidy4b)
```
 
 Очень полезная функция для объединения столбцов.
 
#### Рассредоточение столбцов (spreading)

Это, по сути обратная операция сбору столбцов. Эту операцию используют когда наблюдения разбиты по нескольким строкам. Как в случае, например `table2` --- наблюдением является страна, в определённом году, но каждое наблюдение распределно по двум строкам

```{r}
table2
```

Чтобы привести эту таблицу к аккуратному виду, необъодимо определить ключевой столбец с названиями переменных. В данном примере это столбец `type`. И определить столбец со значениями переменных, это столбец `count`. Как только мы это определили можно использовать функцию `spread()`. 

```{r}
spread(table2, key = type, value = count)
```

Схематично это выглядит так, как показано на картинке:

![alt text](img/tidy-8.png)

Обе рассмотренные в этом параграфе функции `gather()` и `spread()` взаимодополняемые. Первая делает таблицы уже и длиннее, вторая длинные таблицы шире и короче

#### Упражнение 12.3.3.1
<div class="question">
Why are `gather()` and `spread()` not perfectly symmetrical?
Carefully consider the following example:

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %>% 
  spread(year, return) %>% 
  gather("year", "return", `2015`:`2016`)
```

(Hint: look at the variable types and think about column names.)

Both `spread()` and `gather()` have a `convert` argument. What does it do?
</div>

В объявленной переменной столбцы это численные значения с типом данных `<dbl>`. Функция `spread()` разбивает столбец `year` с числовыми значениями и делает из них названия столбцов. Затем функция `gather()` из названий столбцов делает значения для новой переменной. Новая переменная получается строковой с типом данных `<chr>`. Именно поэтому эти две функции *взаимодополняемые* а не *взаимообратные*!

Аргумент `convert()` позволяет конвертировать названия переменных при необходимости в числовой тип данных. По умолчанию у этого аргумента значение `FALSE`, поэтому не происходит конвертации при обычном вызове функции.

```{r}
stocks %>% 
  spread(year, return) %>% 
  gather("year", "return", `2015`:`2016`, convert = TRUE)
```

Забавно, однако и это не позволяет сделать эти функции идеально взаимообратными, по скольку даже в этом примере видно, что сконвертированная перменная имеет тип данных `<int>`, вместо изначального `<dbl>`.


#### Упражнение 12.3.3.2
<div class="question">
Why does this code fail?
```{r}
table4a %>% 
  gather(1999, 2000, key = "year", value = "cases")
```
</div>

Потому что названия столбцов здесь указаны числами в явном виде. Тогда как для того чтобы объявить числовые названия столбцов необходимо заключить их в апострофы

```{r}
table4a %>% 
  gather('1999', '2000', key = "year", value = "cases")
```


#### Упражнение 12.3.3.3
<div class="question">
Why does spreading this tibble fail? How could you add a new column to fix the problem?

```{r}
people <- tribble(
  ~name,             ~key,    ~value,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156
)
```
</div>

Не получается выполнить разбиение по переменным, потому что не проставлен номер измерения.

```{r}
people %>%
  mutate(observation = c(1, 1, 2, 1, 1)) %>% # Проставил номер измерения
  spread(key, value)
```

#### Упражнение 12.3.3.4
<div class="question">
Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?

```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)
```
</div>

Для того чтобы в строках были наблюдения, а в столбца параметры, нам нужно сводить этот фрейм данных. Делать более длинную таблицу.

```{r}
preg1 <-  preg %>%
  gather("male", "female", key = "sex", value = "count")
```

Тут можно пойти дальше и увидеть что два столбца принимают только два возможных знаения. Это значит, что их можно перевести в вектор логических значений

```{r}
(preg2 <- preg1 %>%
  mutate(female = sex == "female",
         pregnant = pregnant == "yes") %>%
  select(pregnant, count, female))         # Для того чтобы отсечь ненужный столбец sex
```

Тут можно ещё подумать о необходимости отбросить наблюдение беременных мужчин, но об этом узнаем чуть позже.
