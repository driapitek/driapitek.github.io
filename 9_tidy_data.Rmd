---
output: html_document
editor_options: 
  chunk_output_type: console
---


## Аккуратизация данных с помощью пакета `tidyr`

### Введение

В этой главе будем узнавать что такое аккуратные данные. Больше про это рассказал Хэдли Уикем в своей [статье](http://www.jstatsoft.org/v59/i10/paper)

#### Необходимые ресурсы

Подключаем библиотеку

```{r}
library("tidyverse")
```


### Аккуратные данные

Существует три правила, соблюдение которых делает набор данных аккуратным:

* каждая переменная должна иметь собственный столбец

* каждое наблюдение должно иметь собственную строку

* каждое значение должно иметь собственную ячейку

Все они взаимосвязаны --- без одного не может быть дву других. Всё это хорошо иллюстрирует изображение

![alt text](img/tidy-1.png)

Всё можно упростить до двух правил 

1. Помещать каждый набор данных в tibble-фрейм

1. Помещеать каждую переменную в столбец

В учебнике было не понятно почему на оси лет такое странное отображение годов.
```{r}
library("ggplot2")
ggplot(table1, aes(year, cases)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country)) 
```

Но когда построил сам врубился --- между точками построения двух годов программа просто добавила 4 промежутка по 0.25

#### Упражнения 12.2.1.1
<div class="question">
Using prose, describe how the variables and observations are organised in each of the sample tables
</div>

```{r}
table1
table2
table3
table4a
table4b
```

1. Таблица 1

Таблица состоит из четырех столбцов-переменных. 
Первый столбец --- категориальная переменная, в которую входят названия трёх стран. 
Второй столбец --- это тоже категориальная переменная, в которой содержатся года в которые происходили наблюдения их два. 
Третий столбец --- это непрерывная переменная "случаи", которая показывает количество случаев происходящих в каждой стране в указанный год
Четвёртый столбец --- тоже непрерывная переменная, которая показывает количество населения соотвтствующее комбинации страна-год-случай

Или если совсем просто:

* Одно наблюдение соответствует одной строке. 
* Одна переменная соответствует одному наблюдению. 
* Одна ячейка соответствует одному значению.

1. Таблица 2

* Одно наблюдение разбито переменной (type) на две строки. В остальном, всё хорошо:
* Одна переменная соответствует одному столбцу
* Одна ячейка соответствует одному значению.

1. Таблица 3

* Одно наблюдение соответствует одной строке. 
* Одна переменная соответствует одному наблюдению. 
* Но в одной ячейке содержится два значения --- (cases/population)

1. Таблицы 4а, 4b

В отдельности эти таблицы являются аккуратными. Но так как они описывают одно измерение, произведено неудобное разделение по переменным ---- (cases) таблица `а` и (population) таблица `b`

#### Упражнения 12.2.1.2
<div class="question">
Compute the rate for table2, and table4a + table4b. You will need to perform four operations:

a) Extract the number of TB cases per country per year.
b) Extract the matching population per country per year.
c) Divide cases by population, and multiply by 10000.
d) Store back in the appropriate place.
e) Which representation is easiest to work with? Which is hardest? Why?</div>
</div>

a) Не очень хорошо получилось. Потому что это просто один столбец значений, без указания года в котором произошло событие.

```{r}
t2_cases <- filter(table2, type == "cases")           # Извлекаем число случаев заболевания
t2_population <- filter(table2, type == "population") # Извлекаем число популяции
t2_rate <- cases$count / population$count * 10000     # Находим отношение
rate <- as.tibble(t2_rate)                            # Сохраняем куда-то
```

Поэтому немного переделаем, чтобы было по красоте

```{r}
t2_cases <- filter(table2, type == "cases") %>%            # Извлекаем число случаев заболевания
  rename(cases = count) %>%                                # Переименовываем стобец
  arrange(country, year)                                   # Сортируем, чтобы избежать ошибок
t2_population <- filter(table2, type == "population") %>%  # Действуем по аналогии и для популяции
  rename(population = count) %>%
  arrange(country, year)
t2_rate <- t2_cases %>% 
  mutate(population = t2_population$population,            # Добавляем переменную популяции
         cases_per_cap = (cases / population) * 10000) %>% # Добавляем переменную с отношением
  select(country, year, cases_per_cap)                     # Оставляем только нужное
```

b) Грязненько это вот так. Разделить отдельно каждый год, и объединить полученные вектора в одну матрицу, а её превратить в тиббл таблицу. Это решение в лоб.

```{r}
table4_1999 <- table4a$`1999` / table4b$`1999` * 10000
table4_2000 <- table4a$`2000` / table4b$`2000` * 10000
table4_rate <- as.tibble(cbind(table4_1999, table4_2000))
```

Элегантнее вот так вот:

```{r}
table4c <-
  tibble(country = table4a$country,
         `1999` = table4a[["1999"]] / table4b[["1999"]] * 10000,
         `2000` = table4a[["2000"]] / table4b[["2000"]] * 10000)
```

Я уже говорил выше, что таблицы 4а и 4b в отрыве друг от друга аккуратные tibble таблицы. Поэтому с ними проще и приятнее работать, чем с "грязной" таблицей номер 2.

#### Упражнения 12.2.1.3
<div class="question">
Recreate the plot showing change in cases over time using table2 instead of table1. What do you need to do first?
</div>

Для того чтобы построить график, нужно для начала высчитать то, что мы проделали в упражнении 2: извлечь все значения для каждого года в отдельности.

```{r}
ggplot(t2_rate, aes(year, cases_per_cap)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country))
```

### Рассредоточение и сведение столбцов

Чаще всего придётся иметь дело с неаккуратными данными, потому что

* Большинство людей не знакомы с принципами аккуратных данных

* Чаще всего данные используют таким образом чтобы упростить ввод, а не анализ

Для большинства видов практического анализа мне чаще всего предстоит приводить данные в аккуратный вид. Для это прежде всего предстоит выяснить какие переменные и наблюдения имеются --- что у нас в столбцах и что в строках. Иногда это бывает просто, но в большинстве случаев необходимо интервьюировать тех людей, которые эти данные вносили. На этом этапе как правило предстоит реашть одну из некоторых задач:

* одна перменная может быть разнесена по нескольким столбцам

* одно наблюдение может быть рассредоточено по нескольким строкам

Типичные наборы данных страдают одним из этих недостатков. Столкнувшись сразу с двумя из них надо понимать, что мне крупно неповезло. Чтобы решать эти проблемы мне пригодятся две функции `gather()` и `spread()`.

#### Сведение столбцов (gather)

На примере набора данных `table4a` покажем что часто названия столбцов являются значениями переменных

```{r}
table4a
```

Названия столбцов здесь `1999` и `2000` это значения перменной `year`, а каждая строка представляет два наблюдения, а не одно

ЧТобы привести набор данных, подобный этому к аккуратному виду, мы должны свести стобцы в новую пару переменных. Для описания этой операции нам понадобится следующие три параметра

* Набор столбцов, которые прдеставляют значения, а не переменные. В данном примере таковым являются стобцы `1999` и `2000`.

* Имя переменной, значения которой образуют имена столбцов. Этот парамер `key`, а переменная в данном примере является `year`.

* Имя переменной, значения которой рассредоточены по ячейкам. Это параметр `value`, а переменной в данном случае является количество случаев заболевания.

Все эти параметры используются при вызове функции `gather()`

```{r}
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
```

Наглядно это делается следующим образом:
![alt text](img/tidy-9.png)

Столбцы, которые необходимо светсти, указываются с использованием нотации в стиле `dplyr::select()`. В данном случае таких столбцов только два, поэтому мы задаем их по отдельности.

ТО же самое проделывается по сути и для популяции

```{r}
table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")
```

А теперь, чтобы их свести используется функция, о которой я узнаю чуть позже. Она чудесным образом (пока что)
 объединяет фреймы данных

 
```{r}
tidy4a <- table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
tidy4b <- table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")

left_join(tidy4a, tidy4b)
```
 
 Очень полезная функция для объединения столбцов.
 
#### Рассредоточение столбцов (spreading)

Это, по сути обратная операция сбору столбцов. Эту операцию используют когда наблюдения разбиты по нескольким строкам. Как в случае, например `table2` --- наблюдением является страна, в определённом году, но каждое наблюдение распределно по двум строкам

```{r}
table2
```

Чтобы привести эту таблицу к аккуратному виду, необъодимо определить ключевой столбец с названиями переменных. В данном примере это столбец `type`. И определить столбец со значениями переменных, это столбец `count`. Как только мы это определили можно использовать функцию `spread()`. 

```{r}
spread(table2, key = type, value = count)
```

Схематично это выглядит так, как показано на картинке:

![alt text](img/tidy-8.png)

Обе рассмотренные в этом параграфе функции `gather()` и `spread()` взаимодополняемые. Первая делает таблицы уже и длиннее, вторая длинные таблицы шире и короче

#### Упражнение 12.3.3.1
<div class="question">
Why are `gather()` and `spread()` not perfectly symmetrical?
Carefully consider the following example:

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2016, 2016),
  half  = c(   1,    2,     1,    2),
  return = c(1.88, 0.59, 0.92, 0.17)
)
stocks %>% 
  spread(year, return) %>% 
  gather("year", "return", `2015`:`2016`)
```

(Hint: look at the variable types and think about column names.)

Both `spread()` and `gather()` have a `convert` argument. What does it do?
</div>

В объявленной переменной столбцы это численные значения с типом данных `<dbl>`. Функция `spread()` разбивает столбец `year` с числовыми значениями и делает из них названия столбцов. Затем функция `gather()` из названий столбцов делает значения для новой переменной. Новая переменная получается строковой с типом данных `<chr>`. Именно поэтому эти две функции *взаимодополняемые* а не *взаимообратные*!

Аргумент `convert()` позволяет конвертировать названия переменных при необходимости в числовой тип данных. По умолчанию у этого аргумента значение `FALSE`, поэтому не происходит конвертации при обычном вызове функции.

```{r}
stocks %>% 
  spread(year, return) %>% 
  gather("year", "return", `2015`:`2016`, convert = TRUE)
```

Забавно, однако и это не позволяет сделать эти функции идеально взаимообратными, по скольку даже в этом примере видно, что сконвертированная перменная имеет тип данных `<int>`, вместо изначального `<dbl>`.


#### Упражнение 12.3.3.2
<div class="question">
Why does this code fail?
```{r}
table4a %>% 
  gather(1999, 2000, key = "year", value = "cases")
```
</div>

Потому что названия столбцов здесь указаны числами в явном виде. Тогда как для того чтобы объявить числовые названия столбцов необходимо заключить их в апострофы

```{r}
table4a %>% 
  gather('1999', '2000', key = "year", value = "cases")
```


#### Упражнение 12.3.3.3
<div class="question">
Why does spreading this tibble fail? How could you add a new column to fix the problem?

```{r}
people <- tribble(
  ~name,             ~key,    ~value,
  #-----------------|--------|------
  "Phillip Woods",   "age",       45,
  "Phillip Woods",   "height",   186,
  "Phillip Woods",   "age",       50,
  "Jessica Cordero", "age",       37,
  "Jessica Cordero", "height",   156
)
```
</div>

Не получается выполнить разбиение по переменным, потому что не проставлен номер измерения.

```{r}
people %>%
  mutate(observation = c(1, 1, 2, 1, 1)) %>% # Проставил номер измерения
  spread(key, value)
```

#### Упражнение 12.3.3.4
<div class="question">
Tidy the simple tibble below. Do you need to spread or gather it? What are the variables?

```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)
```
</div>

Для того чтобы в строках были наблюдения, а в столбца параметры, нам нужно сводить этот фрейм данных. Делать более длинную таблицу.

```{r}
preg1 <-  preg %>%
  gather("male", "female", key = "sex", value = "count")
```

Тут можно пойти дальше и увидеть что два столбца принимают только два возможных знаения. Это значит, что их можно перевести в вектор логических значений

```{r}
(preg2 <- preg1 %>%
  mutate(female = sex == "female",
         pregnant = pregnant == "yes") %>%
  select(pregnant, count, female))         # Для того чтобы отсечь ненужный столбец sex
```

Тут можно ещё подумать о необходимости отбросить наблюдение беременных мужчин, но об этом узнаем чуть позже.

### Разделение и объединение столбцов

Взглянем ещё раз на фрейм данных
```{r}
table3
```

В ней в одной переменной `rate` содержится два значения --- `cases` и `population`, для того чтобы разделить эти переменные нам понадобится функция `separate()`.


#### Разделение столбцов при помощи функции `separate()`

Разделение производится всякий раз когда встречается символ разделитель. Это происходит автоматически:

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"))
```

Но можно задать разделитель в явном виде при помощи аргумента `sep`

```{r}
table3 %>%
  separate(rate, into = c("cases", "population"), sep = "/")
```

Формально, `sep` это регулярное выражение, но об этом чуть позже.

При разделении столбцов полученные новые столбцы имеют символьный тип. Это поведение в функции `separate()` задано по умолчанию --- для того чтобы оставлять тип столбца таким, какой он есть. В этой функции однако, предусмотрена возомжность конвертировать получаемые столбцы, как и у предыдущих функций этого семейства.

```{r}
table3 %>%
  separate(rate,
           into = c("cases", "population"),
           convert = TRUE
           )
```

МОжно так же отделять столбцы по количеству символов. Это можно осуществить передавая в аргумент `sep` целочисленное значение. При этом необходимо придерживаться правил:

* При разбиение строк с использованием целых чисел, длина `sep` должна быть на единицу меньше количества имён в `into`.
* Положительные значения начинаются с 1 и отсчитываются от крайней слева позиции в строках
* Отрицательные значения начинается с -1 и отсчитываются от крайней правой позиции в строках

#### Объединение столбцов при помощи функции `unite()`

Объединение используется реже, но тоже бывает полезно. Например, нам пригодится соединить два столбца, чтобы получить год
```{r}
table5 %>%
  unite(new, century, year)
```

По умолчанию используется разделитель `_`. Нам он тут не нужен, поэтому зададим разделитель в явном виде

```{r}
table5 %>%
  unite(new, century, year, sep = "")
```


#### Упражнение 12.4.3.1
<div class="question">
What do the extra and fill arguments do in separate()? Experiment with the various options for the following two toy datasets.

```{r}
tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"))
```
</div>

Параметр `extra` определяет что делать с переполняющими значениями. У `extra` есть три опции 
```{r}
t1 <- tibble(x = c("a,b,c", "d,e,f,g", "h,i,j"))

separate(t1, x, c("one", "two", "three"), extra = "warn")
# «warn» (по умолчанию): выдаёт предупреждение и отбрасывает дополнительные значения.

separate(t1, x, c("one", "two", "three"), extra = "drop")
# «drop»: отбрaсывает любые дополнительные значения без предупреждения.

separate(t1, x, c("one", "two", "three"), extra = "merge")
# «merge»: добавляет переполняющие значения в месте где они есть

```

Теперь посмотрим второй пример, и параметр `fill`. Этот параметр используется, когда не хватает значений, он определяет что делать, если значений не хватает,

```{r}
t2 <- tibble(x = c("a,b,c", "d,e", "f,g,i"))

separate(t2, x, c("one", "two", "three"), fill = "warn")
# «warn» (по умолчанию): выдаёт предупреждение и заполняет справа пропущенным значением NA

separate(t2, x, c("one", "two", "three"), fill = "right")
# заполняет справа пропущенным значение NA

separate(t2, x, c("one", "two", "three"), fill = "left")
# заполняет слева пропущенным значение NA
```

#### Упражнение 12.4.3.2
<div class="question">
Both `unite()` and `separate()` have a `remove` argument. What does it do? Why would you set it to FALSE?
</div>

Параметр `remove`, если `TRUE` удаляет входной стобец из выходных данных. 

Входной столбец может понадобится например в случаях объединения. Когда нам важна информация во входном столбце, отдельно от объединяемого столбца. Например, в случае ниже, нам может пригодится век измерения для совокупной проверки по одному столетию

```{r}
table5 %>%
  unite(new, century, year, sep = "", remove = FALSE)
```

#### Упражнение 12.4.3.3
<div class="question">
Compare and contrast `separate()` and `extract()`. Why are there three variations of separation (by position, by separator, and with groups), but only one unite?
</div>

Разделение при помощи `separate()` является частным и статичным, нужно знать либо разделяющий символ, либо позицию

```{r}
# разделение с разделителем
tibble(x = c("male-34", "female-12", "male-19", "female-42")) %>%
  separate(x, c("sex", "age"), sep = "-")

# разделение по позиции - второй с конца
tibble(x = c("male34", "female12", "male19", "female42")) %>%
  separate(x, c("sex", "age"), sep = c(-2))
```

Разделение при помощи `extract()` является более гибким, поскольку для него не требуются общие разделители или конкретные позиции столбцов.

```{r}
tibble(x = c("male-34", "female-12", "male-19", "female-42")) %>%
  extract(col = x, into = c("sex", "age"), regex = "([a-z]+)-([0-9]+)")
```

 Параметр группы задается при помощи аргумента `regex = "([условие])-([условие])"`. Опция `"+"` ставится в том случае, если необходимо взять все символы до разделителя которые соответствуют условию.

```{r}
tibble(x = c("male-34", "female-12", "male-19", "female-42")) %>%
  extract(col = x, into = c("sex", "age"), regex = "([a-z])-([0-9])")
```

Обе функции `separate ()` и `extract ()` преобразуют один столбец во многие столбцы. Однако `unite()` преобразует много столбцов в один, причем выбор разделителя включает значения столбцов.

Другими словами, с помощью `extract()` и `separate()` можно выбрать только один столбец, но есть много вариантов разделения этого столбца на разные столбцы. С `unite()`, есть много вариантов того, какие столбцы включать, но только один выбор, как объединить их содержимое в один вектор.

### Отсутствующие значения

Есть два типа отсутствующих значений

* явное --- имеющее маркер `NA`

* неявное --- то есть буквальное отсутствие значения среди данных

```{r}
stocks <- tibble(
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)
```

* значение для 2015 года 4 квартала --- явное отсутствие

* значение для 2016 года 1 квартала --- неявеное

Можно сделать неявное отсутсвие явным:
```{r}
stocks %>%
  spread(year, return)
```

Но по скольку эти пропущенные значения могут не играть важной роли от них можно избавиться, задав аргумент `na.rm = TRUE` и объединить столбцы.

```{r}
stocks %>%
  spread(year, return) %>%
  gather(year, return, `2015`:`2016`, na.rm = TRUE)
```

Есть ещё функция `complete()`

```{r}
stocks %>%
  complete(year, qtr)
```

Это очень крутая функция. Она принимает набор столбцов и находит все уникальные комбинации. Далее она убеждается в том, что исходный набор данных содержит все эти значения, вставояя маркеры явного отсутствия значений (NA) там, где это необходимо.

Существует ещё один важный вид отсутсвующих значений. Иногда, когда источник данных используется главным образом для ввода данных, отсутствующее значение указывает на то, что предыдущее значение должно быть перенесено в следующую запись.

```{r}
treatment <- tribble(
  ~ person,           ~ treatment, ~response,
  "Derrick Whitmore", 1,           7,
  NA,                 2,           10,
  NA,                 3,           9,
  "Katherine Burke",  1,           4
)
```

Как в этом случае --- ячейки с именеме якобы объединены. Эти отсутствующиее значения можно заполнить с помощью функции `fill()`. Она принимает набор столбцов, отсутвующие значения в которых мы хотим заменить ближайшими предыдущими значениями, не являющиеся отсутвующими.

```{r}
treatment %>%
  fill(person)
```

Это тоже очень крутая функция, которой я часто пользовался "ручками" в экселе.

#### Упражнение 12.5.1.1
<div class="question">
Compare and contrast the `fill` arguments to `spread()` and `complete()`.
</div>

В `spread()` аргумент `fill` явно устанавливает значение для замены `NA`. В `complete()` аргумент `fill` также устанавливает значение для замены `NA`, но это именованный список, позволяющий использовать разные значения для разных переменных. Кроме того, оба случая заменяют как неявные, так и явно отсутствующие значения.

В `spread()` eсли установлено, отсутствующие значения будут заменены этим значением. Обратите внимание, что во входном файле есть два типа пропусков: явные пропущенные значения (т. Е. NA) и неявные пропуски, строки, которых просто нет. Оба типа недостающего значения будут заменены заполнением.

В `complete()` именованный список, который для каждой переменной предоставляет единственное значение для использования вместо NA для отсутствующих комбинаций.

#### Упражнение 12.5.1.2
<div class="question">
What does the `direction` argument to `fill()` do?
</div>

Аргумент `direction` задаёт направление заполнения --- по умолчанию, сверху вниз `"down"`, но можно поменять на снизу вверх `"up"`

```{r}
treatment %>%
  fill(person, .direction = "up")
```

### Учебный пример

Очень клёво --- у нас типичный пример неряшливых данных. Мы будем использовать реальный пример данных о заболеваемости туберкулёзом
```{r}
who
```

По этому представлению, всё что пока что понятно это:

* Для определения страны используется избыточное количество переменных

* Столбец  `year` является переменной

* Остальные столбцы, можно предположить, являются значениями а не переменными.

Теперь перейдём к более аккуратному виду. Для этого объединим все столбцы с предполагаемыми значениям в одну переменную

```{r}
(who1 <- who %>%
  gather(
    new_sp_m014:newrel_f65, key = "key",
    value = "cases",
    na.rm = TRUE
  ))
```

Мы можем получить некое представление о структуре значений в новой переменной `key` подсчитав их.

```{r}
who1 %>%
  count(key)
```

Что означает символьная кодировка в ключе (о возрасте и поле догодался сам)

* Первые три буквы --- случай заболевания, `new` новый и  `ul` старый

* Следующие две буквы описывают тип туберкулёза
  - `reel` --- рецидивный
  - `up` --- внелёгочный
  - `sun` --- лёгочный, не диагностируемый с помощью мазка
  - `spa`  --- лёгочный, диагностируемый с помощью мазка
  
* Шестая буква --- Пол пациента

* оставшиеся цифра --- возрастная группа

Есть особенность, которую я заметил, когда набирал названия столбцов в коде --- есть столбцы которые именуются `new_rel`, а есть те что именуются `newrel`. Чтобы все дальнейшие действия над данными не были проблематичными, нужно привести все записи к одному виду. Для этого, просмотрев весь фрейм данных выбираем форму записи `new_rel` --- их больше.

```{r}
(who2 <- who1 %>%
  mutate(key = stringr::str_replace(key, "newrel", "new_rel")))
```

Разделим столбцы в `key` на параметры при помощи `separete()`, знак разделитель `"_"`

```{r}
who3 <- who2 %>%
  separate(key, c("new", "type", "sexage"), sep = "_")
```

Посмотрим что в новом столбцк "new":

```{r}
who3 %>%
  count(new)
```

В изначальном фрейме данных содержится информация только о новых заболеваниях, поэтому этот столбец избыточный, избавимся от него, вместе со столбцами `iso2`, `iso3` по той же причине.

```{r}
who4 <- who3 %>%
  select(-new, -iso2, -iso3)
```

Далее разделим столбец с возрастом и полом, разбиение делаем после первого символа

```{r}
who5 <- who4 %>%
  separate(sexage, c("sex", "age"), sep = 1)
```

Можно сказать что набор данных приведён к аккуратному виду. Я проделал это всё, назначая промежуточный результат переменной. Но как правило такая работа делается в канале.

```{r}
who %>%
  gather(key, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>% 
  mutate(key = stringr::str_replace(key, "newrel", "new_rel")) %>%
  separate(key, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1)
```

#### Упражнение 12.6.1.1
<div class="question">
In this case study I set `na.rm = TRUE` just to make it easier to check that we had the correct values. Is this reasonable? Think about how missing values are represented in this dataset. Are there implicit missing values? What’s the difference between an NA and zero?
</div>

```{r}
who1 %>%
  filter(cases == 0) %>%
  nrow()
```

В этом наборе данных `NA` означает отсутствие измерения на конкретный тест, а наличие нуля означает что тест проводился, и его результат отрицательный. Поэтому в данной ситуации было уместно убрать отсутствующие значения, а не заменять их нулями, так как мы не теряем информации о проведённых исследованиях.

Чтобы продемоснтрировать разницу между нулём и отсутствующим значением я приведу картинку. Потому что лучше один раз увидеть, чем сто раз услышать. 

![alt text](img/NA.jpg)

#### Упражнение 12.6.1.2
<div class="question">
What happens if you neglect the `mutate()` step? (`mutate(key = stringr::str_replace(key, "newrel", "new_rel"))`)
</div>

Эта строчка кода приводит записи наблюдений к одинаковой форме. Без этой строчки один и тот же по своей природе параметр будет встречаться дважды в виде двух разных записей `"newrel"`и `"new_rel"`.

Нельзя простро пропустить этот шаг в этом коде:

```{r}
who %>%
  gather(key, value, new_sp_m014:newrel_f65, na.rm = TRUE) %>% 
  mutate(key = stringr::str_replace(key, "newrel", "new_rel")) %>%
  separate(key, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1)
```

Потому что последующая логика разделения столбца `key` по параметрам, базируется на том, что группы разбивает разделитель `"_"`.


#### Упражнение 12.6.1.3
<div class="question">
I claimed that `iso2` and `iso3` were redundant with country. Confirm this claim.
</div>

Первым способом я решил объединить все три столбца и посчитать количество раз которое они встречаются. Любое отклонение от одинаковой суммы указывало бы на то, что вероятно объединение может быть 

```{r}
who %>%
  unite(key, country, iso2, iso3) %>%
  select(key) %>%
  count(key) %>%
  arrange(n)
```

```{r}
select(who3, country, iso2, iso3) %>%
  distinct() %>%
  group_by(country) %>%
  filter(n() > 1)
```

#### Упражнение 12.6.1.4
<div class="question">
For each country, year, and sex compute the total number of cases of TB. Make an informative visualization of the data.
</div>

Для начала я сделал точками.
```{r}
who_visual %>%
  group_by(country, year, sex) %>%
  filter(year >= 1995) %>%
  summarise(cases = sum(value)) %>%
  ggplot(aes(x = year, y = cases, color = sex)) +
  geom_point()
```

но потом, сделал получше


```{r}
who5 %>%
  group_by(country, year, sex) %>%
  filter(year > 1995) %>%
  summarise(cases = sum(cases)) %>%
  unite(country_sex, country, sex, remove = FALSE) %>%
  filter(between(cases, 50000, 800000)) %>%
  ggplot(aes(x = year, y = cases, group = country_sex, colour = sex)) +
  geom_line() + 
  facet_wrap(.~country)
```


