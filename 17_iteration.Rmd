---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Итерирование с помощью пакета `purrr`

### Введение

Снижение дублирования кода обеспечивает три основных преимущества

* Проследить намерения автора кода гораздо проще. Потому что внимание концентрируется на содержательной части кода, а не на повторяющихся участках

* Вносить исправления в код гораздо проще. Потому что нужно внести изменение в одном месте, а не бегать по всему коду и менять в соответствующих участках.

* Это облегчает устранение ошибок. Потому что опять-таки исправлять нужно в одном месте, а не в нескольких участках программы.

В этой главе мы познакомимся с двумя важными парадигмами итерирования:

* императивное программирование
  
  В императивном программировании имеются инструменты как циклы `for` или `while`. Эти циклы нужно описывать достаточно подробно

* функциональное программирование
  
  Функциональное программирование предлагает средства изолирования повторяющегося кода. Так что каждый шаблон цикла получает собственную функцию.

Как только научимся фигачить в функциональное программирование, будет легче решать многие итерационные задачи  

#### Используемые ресурсы

Тут понадобятся `purrr`, который входит в библиотеку `tidyverse`

```{r}
library(tidyverse)
```


### Циклы `for`

Пример. Есть такой фрейм.

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

Вычислим медиану для каждого столбца

```{r}
output <- vector("double", ncol(df))  # 1. вывод
for (i in seq_along(df)) {            # 2. последовательность
  output[[i]] <- median(df[[i]])      # 3. тело
}
output
```

Итак. каждый цикл `for` содержит три компонента

* *вывод* --- `output <- vector("double", ncol(df))`
  
  Прежде чем выполнить цикл, всегда необходимо выделить достаточно места для хранения выходных результатов. 
  Это очень важно для обеспечения эффективности вычислений --- если наращивать выходные результаты при помощи например вызовов `с()`, то цикл будет работать очень медленно.
  Общий способ создания пустого вектора заданной длины предлагает функция `vector()`. Она имеет два аргумента: тип вектора(логически, целочисленный, вещественный, символьный) и длина вектора

* *последовательность* --- `i in seq_along(df)`
  
  Этот компонент определяет по какой переменной выполняется итерирование.
  На каждй итерации цикла переменной `i` будет присваиваться другое значение, берущееся из последовательности `seq_along(df)`
  
  Отныне лучше всегда использовать именно `seq_along(df)` вместо `1:length(x)`. Вот почему
```{r}
y <- vector("double", 0)
seq_along(y) # это же вектор нулевой длины, всё верно
1:length(y)  # это же должен быть вектор нулевой длины, почему тут два числа???
```

* *тело цикла* --- `output[[i]] <- median(df[[i]])`
  
  Этот код делает всю работу. Он выполняется многократно,  каждый раз с последующим значением `i`. 
  На первой итерации будет выполненяться инструкция `output[[1]] <- median(df[[1]])`, на второй `output[[2]] <- median(df[[2]])` и так далее
  
#### Упражнение 21.2.1.1

<div class="question">
Write for loops to:

1. Compute the mean of every column in mtcars.

2. Determine the type of each column in `nycflights13::flights`.

3. Compute the number of unique values in each column of iris.

4. Generate 10 random normals for each of  $\mu = -10, 0, 10, 100$

Think about the output, sequence, and body before you start writing the loop.
</div>
  
  
1. Если решать циклом, можно переделать задачу из упражнения:

```{r}
output <- vector("double", ncol(mtcars))
names(output) <- names(mtcars)
for (i in seq_along(mtcars)) {
  output[[i]] <- mean(mtcars[[i]])
}
output
```

2. Тип вектора определяет функция `class()`

```{r}
output <- vector("list", ncol(nycflights13::flights))
names(output) <- names(nycflights13::flights)
for (i in seq_along(nycflights13::flights)) {
  output[[i]] <- class(nycflights13::flights[[i]])
}
output

ncol(nycflights13::flights)

class(nycflights13::flights[[1]])
```

3. Тут тоже не сложно

```{r}
iris
length(unique(iris$Sepal.Length))

length(unique(iris[[2]]))


output <- vector("double", ncol(iris))
names(output) <- names(iris)
for (i in seq_along(iris)) {
  output[[i]] <- length(unique(iris[[i]]))
}
output
```

4. 

```{r}
rnorm(10, mean = -10)

mu <- c(-10, 10, 0, 100)
output <- vector("list", length(mu))
for (i in seq_along(mu)) {
  output[[i]] <- rnorm(10, mean = i)
}
output
```

