---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Итерирование с помощью пакета `purrr`

### Введение

Снижение дублирования кода обеспечивает три основных преимущества

* Проследить намерения автора кода гораздо проще. Потому что внимание концентрируется на содержательной части кода, а не на повторяющихся участках

* Вносить исправления в код гораздо проще. Потому что нужно внести изменение в одном месте, а не бегать по всему коду и менять в соответствующих участках.

* Это облегчает устранение ошибок. Потому что опять-таки исправлять нужно в одном месте, а не в нескольких участках программы.

В этой главе мы познакомимся с двумя важными парадигмами итерирования:

* императивное программирование
  
  В императивном программировании имеются инструменты как циклы `for` или `while`. Эти циклы нужно описывать достаточно подробно

* функциональное программирование
  
  Функциональное программирование предлагает средства изолирования повторяющегося кода. Так что каждый шаблон цикла получает собственную функцию.

Как только научимся фигачить в функциональное программирование, будет легче решать многие итерационные задачи  

#### Используемые ресурсы

Тут понадобятся `purrr`, который входит в библиотеку `tidyverse`

```{r}
library(tidyverse)
```


### Циклы `for`

Пример. Есть такой фрейм.

```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

Вычислим медиану для каждого столбца

```{r}
output <- vector("double", ncol(df))  # 1. вывод
for (i in seq_along(df)) {            # 2. последовательность
  output[[i]] <- median(df[[i]])      # 3. тело
}
output
```

Итак. каждый цикл `for` содержит три компонента

* *вывод* --- `output <- vector("double", ncol(df))`
  
  Прежде чем выполнить цикл, всегда необходимо выделить достаточно места для хранения выходных результатов. 
  Это очень важно для обеспечения эффективности вычислений --- если наращивать выходные результаты при помощи например вызовов `с()`, то цикл будет работать очень медленно.
  Общий способ создания пустого вектора заданной длины предлагает функция `vector()`. Она имеет два аргумента: тип вектора(логически, целочисленный, вещественный, символьный) и длина вектора

* *последовательность* --- `i in seq_along(df)`
  
  Этот компонент определяет по какой переменной выполняется итерирование.
  На каждй итерации цикла переменной `i` будет присваиваться другое значение, берущееся из последовательности `seq_along(df)`
  
  Отныне лучше всегда использовать именно `seq_along(df)` вместо `1:length(x)`. Вот почему
```{r}
y <- vector("double", 0)
seq_along(y) # это же вектор нулевой длины, всё верно
1:length(y)  # это же должен быть вектор нулевой длины, почему тут два числа???
```

* *тело цикла* --- `output[[i]] <- median(df[[i]])`
  
  Этот код делает всю работу. Он выполняется многократно,  каждый раз с последующим значением `i`. 
  На первой итерации будет выполненяться инструкция `output[[1]] <- median(df[[1]])`, на второй `output[[2]] <- median(df[[2]])` и так далее
  
#### Упражнение 21.2.1.1

<div class="question">
Write for loops to:

1. Compute the mean of every column in mtcars.

2. Determine the type of each column in `nycflights13::flights`.

3. Compute the number of unique values in each column of iris.

4. Generate 10 random normals for each of  $\mu = -10, 0, 10, 100$

Think about the output, sequence, and body before you start writing the loop.
</div>
  
  
1. Если решать циклом, можно переделать задачу из упражнения:

```{r}
output <- vector("double", ncol(mtcars))
names(output) <- names(mtcars)
for (i in seq_along(mtcars)) {
  output[[i]] <- mean(mtcars[[i]])
}
output
```

2. Тип вектора определяет функция `class()`

```{r}
output <- vector("list", ncol(nycflights13::flights))
names(output) <- names(nycflights13::flights)
for (i in seq_along(nycflights13::flights)) {
  output[[i]] <- class(nycflights13::flights[[i]])
}
output

ncol(nycflights13::flights)

class(nycflights13::flights[[1]])
```

3. Тут тоже не сложно

```{r}
iris
length(unique(iris$Sepal.Length))

length(unique(iris[[2]]))


output <- vector("double", ncol(iris))
names(output) <- names(iris)
for (i in seq_along(iris)) {
  output[[i]] <- length(unique(iris[[i]]))
}
output
```

4. 

```{r}
rnorm(10, mean = -10)

mu <- c(-10, 10, 0, 100)
output <- vector("list", length(mu))
for (i in seq_along(mu)) {
  output[[i]] <- rnorm(10, mean = i)
}
output
```

#### Упражнение 21.2.1.2

<div class="question">
Eliminate the for loop in each of the following examples by taking advantage of an existing function that works with vectors:
</div>

1. Цикл `for` в данном примере объединяет все элементы вектора `letters`. Функция `str_c()` содержит внутри себя аргумент `collapse`, который выполняет эту же функцию. 

```{r}
out <- ""
for (x in letters) {
  out <- stringr::str_c(out, x)
}
out

str_c(letters, collapse = "")
```

2. Этот цикл считает стандартное отклонение $sd = \frac{\sum{(x_i - \bar{x}})^2}{n-1}$. 
Но ведь для этого есть функция `sd()`

```{r}
x <- sample(100)
sd <- 0
for (i in seq_along(x)) {
  sd <- sd + (x[i] - mean(x)) ^ 2
}
sd <- sqrt(sd / (length(x) - 1))

sd(x)
```

3. Эта функция считает скользящую (или кумулятивную) сумму --- считает сумму для каждого последующего элемента.
Для этих целей есть внутренняя функция `cumsum()`

```{r}
x <- runif(100)
out <- vector("numeric", length(x))
out[1] <- x[1]
for (i in 2:length(x)) {
  out[i] <- out[i - 1] + x[i]
}

cumsum(x)
```

#### Упражнение 21.2.1.3

<div class="question">
Combine your function writing and for loop skills:

Write a for loop that `prints()` the lyrics to the children’s song “Alice the camel”.

Convert the nursery rhyme “ten in the bed” to a function. Generalise it to any number of people in any sleeping structure.

Convert the song “99 bottles of beer on the wall” to a function. Generalise to any number of any vessel containing any liquid on any surface.
</div>

* Задание 1 --- песенка доступна по адресу <http://www.metrolyrics.com/alice-the-camel-lyrics-children.html>

Смысл такой, что по очереди от числа 5 до нуля у верблюда исчезают горбы и когда горбов нет, верблюд превращается в лошадь.

Реализовать можно и без команды `print()`. Я подошёл лениво к реализации --- моё решение не учитывает общий случай (когда горбов больше чем 5), но где вы видели верблюда с таким количеством горбов?
Но зато решение учитывает правила орфографии для единственного числа.

```{r}
count <- c("five", "four", "three", "two", "one", "no")

for (i in seq_along(count)) {
  if (i <= 4) {
    cat(str_c("Alice the camel has ", rep(count[i], 3), " humps.",
    collapse = "\n"
  ), "\nSo go, Alice, go.\n", "\n")
  }
  if (i == 5) {
    cat(str_c("Alice the camel has ", rep(count[i], 3), " hump.",
    collapse = "\n"
  ), "\nSo go, Alice, go.\n", "\n")
  }
  if (i == 6) {
   cat(str_c("Alice the camel has ", rep(count[i], 3), " humps.",
    collapse = "\n"
  ), "\nNow Alice is a horse.", "\n") 
  }
}
```

* Задание 2 --- песенка доступна по адресу <https://www.kididdles.com/lyrics/t003.html>

От заданного числа до нуля происходит счёт

There were ten in a bed\n
And the little one said\n
"Roll over, roll over"\n
So they all rolled over\n
And one fell out\n

на последнем элементе текст меняется на

There was one in a bed\n
And the little one said\n
"Good night!"\n

Для создания функции т.е. общего случая нужно иметь вектор всех названий числительных. 
Либо заменить числительные на число. Я в этой реализации опять сделаю ленивую версию в которой просто отработаю навык создания цикла `for`

```{r}
numbers <- c(
  "ten", "nine", "eight", "seven", "six", "five",
  "four", "three", "two", "one"
)

for (i in seq_along(numbers)) {
  if(length(numbers) - i >= 0 ) {
  cat("There were", numbers[i], "in a bed", "\nAnd the little one said
\"Roll over, roll over\"
So they all rolled over
And one fell out
\n")
  } else {
  "There was one in a bed
And the little one said
\"Good night!\""
}
}
```

