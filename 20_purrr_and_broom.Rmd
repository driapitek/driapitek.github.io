---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Обработка множества моделей с помощью пакетов `purrr` и `broom`
### Введение

Тут советуют не отчаиваться если сразу не получится осмыслить всё то что здесь объясняется.

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(modelr)
```

### Набор данных `gapminder`

В наборе соз=держится информация об изменении во времени суммарных показателей развития стран мира, рассчитанных на основк таких статистик как средняя продолжительность жизни и ВВП.

```{r}
library(gapminder)
gapminder
```

В данном примере мы сосредоточим внимание всего лишь на трех переменных и попытаемся ответить на вопрос: "Как изменяется средняя продолжительность жизни `lifeExp` со временем `year` для каждой страны `country`.

```{r}
gapminder %>% 
  ggplot(aes(year, lifeExp, group = country)) +
  geom_line()
```

Набор хоть и небольшой но тем не менее так сразу и не скажешь что тут происходит.
Один из способов заключается в том, чтобы использовать тот же подход, что и в предыдущей главе: существует один сильный сигнал (общий линейный тренд), который затрудняет наблюдение более слабых трендов.
Мы разведем эти факторы посредством построения модели с линейным трендом.
Эта модель захватит постоянный рост во времени, а остатки покажут, что остается.

Мы знаем как сделать это для одной страны.

```{r}
nz <- filter(gapminder, country == "New Zealand")

nz %>% 
  ggplot(aes(year, lifeExp)) +
  geom_line() +
  ggtitle("Full data")

nz_mod <- lm(lifeExp ~ year, data = nz)

nz %>% 
  add_predictions(nz_mod) %>% 
  ggplot(aes(year, pred)) +
  geom_line() +
  ggtitle("Linear trend")

nz %>% 
  add_residuals(nz_mod) %>% 
  ggplot(aes(year, resid)) +
  geom_line() +
  ggtitle("Remaining pattern")
```

Теперь посмотрим как строить модель для каждой страны.

#### Вложенные данные

Сделаем вложенные данные

```{r}
by_country <- gapminder %>% 
  group_by(country, continent) %>% 
  ?nest()

by_country

by_country <- if (require("gapminder")) {
  gapminder %>%
    group_by(country, continent) %>%
    nest()

  gapminder %>%
    nest(-country, -continent)
}
```

Последняя функция позволяет вложить в тиббл-фрейм ещё один тиббл-фрейм.

Это создает фрейм данных, который имеет одну строку на группу (на страну) и довольно необычный столбец: данные. Данные - это список фреймов данных (или, если быть точным, фрагментов данных). Это кажется сумасшедшей идеей: у нас есть фрейм данных со столбцом, который является списком других фреймов данных! Я вскоре объясню, почему я думаю, что это хорошая идея.

Столбец данных немного сложен, потому что это умеренно сложный список, и мы все еще работаем над хорошими инструментами для изучения этих объектов. К сожалению, использование str () не рекомендуется, так как это часто приводит к очень длинному выводу. Но если вы выделите один элемент из столбца данных, вы увидите, что он содержит все данные для этой страны (в данном случае, Афганистан).

```{r}
by_country$data[[50]]

by_country <- by_country %>% 
  head(29)
```

Обратите внимание на разницу между стандартным сгруппированным кадром данных и вложенным фреймом данных: в сгруппированном фрейме данных каждая строка является наблюдением; во вложенном фрейме данных каждая строка является группой. Еще один способ думать о вложенном наборе данных - теперь у нас есть мета-наблюдение: строка, представляющая полный временной курс для страны, а не один момент времени.

#### Столбцы-списки

Теперь, когда у нас есть вложенный фрейм данных, мы в состоянии приспособиться к некоторым моделям. У нас есть функция подбора модели:

```{r}
country_model <- function(df) {
  lm(lifeExp ~ year, data = df)
}
```

И мы хотим применить его к каждому фрейму данных. Фреймы данных находятся в списке, поэтому мы можем использовать `purrr::map()`, чтобы применить `country_model` к каждому элементу:

```{r}
models <- map(by_country$data, country_model)
```

Однако вместо того, чтобы оставлять список моделей как свободно плавающий объект, я думаю, что лучше хранить его в виде столбца во фрейме данных `by_country`. 
Хранение связанных объектов в столбцах является ключевой частью значения фреймов данных, и поэтому я считаю, что списочные столбцы - это хорошая идея. 
В ходе работы с этими странами у нас будет много списков, в которых у нас будет один элемент на страну. Так почему бы не хранить их все вместе в одном фрейме данных?

Другими словами, вместо создания нового объекта в глобальной среде, мы собираемся создать новую переменную во фрейме данных `by_country`. Это работа для `dplyr::mutate()`:

```{r}
by_country <- by_country %>% 
  mutate(model = map(data, country_model))
by_country
```

Это имеет большое преимущество: поскольку все связанные объекты хранятся вместе, вам не нужно вручную синхронизировать их при фильтрации или упорядочивании. Семантика фрейма данных позаботится об этом за вас:

```{r}
by_country %>% 
  filter(continent == "Europe")

by_country %>% 
  arrange(continent, country)
```

Если ваш список фреймов данных и список моделей были отдельными объектами, вы должны помнить, что всякий раз, когда вы переупорядочиваете или поднастраиваете один вектор, вы должны переупорядочивать или подгруппировать все остальные, чтобы синхронизировать их. Если вы забудете, ваш код продолжит работать, но он даст неправильный ответ!

#### Отмена вложенния данных

Вычислим остатки

```{r}
by_country <- by_country %>% 
  mutate(
    resid = map2(data, model, add_residuals)
  )

by_country
```

Для того чтобы нарисовать всё на одном графике разгруппируем, и приведём всё к виду обычного тиббл-фрейма

```{r}
resids <- unnest(by_country, resid)
resids
```

Каждый столбец повторяется один раз для каждой строки вложенного столбца.

Теперь, когда у нас есть обычный фрейм данных, построим график остатков

```{r}
resids %>% 
  ggplot(aes(year, resid)) + 
  geom_line(aes(group = country), alpha = 0.3) +
  geom_smooth(se = FALSE)
```

Добавим чуть-чуть информативности --- отобразим по континентам на разных панелях.

```{r}
resids %>% 
  ggplot(aes(year, resid)) +
  geom_line(aes(group = country), alpha = 0.3) +
  facet_wrap(~continent)
```

Большие остатки указывают на то, что мы упустили какую-то тенденцию --- наша модель работает не слишком хорошо.

#### Качество модели

Вместо анализа остатков, возникающих в модели, можно рассмотреть екоторые общие меры качества модели.
До этого мы узнали, как вычислять специализированные меры.
Здесь мы будем использовать функцию `broom::glance()` для извлечения качественных метрик модели. Применяя их к модели, мы получаем фрейм данных, состоящих из одной строки.

```{r}
broom::glance(nz_mod)
```

Создадим фрейм данных с одной строкой для каждой страны.

```{r}
by_country %>% 
  mutate(glance = map(model, broom::glance)) %>% 
  unnest(glance)
```

Это не совсем тот вывод который нужен, поскольку тут ещё есть столбцы списки.
Таково поведение по-умолчанию. Чтобы отменить это поведение нужно:

```{r}
glance <- by_country %>% 
  mutate(glance = map(model, broom::glance)) %>% 
  unnest(glance, .drop = TRUE)
```

Имея в своём распоряжении новые данные, мы можем приступить к поиску неудачных моделей.

```{r}
glance %>% 
  arrange(r.squared)
```

Визуализируем, кому больше всего принадлежат неудачные модели

```{r}
glance %>% 
  ggplot(aes(continent, r.squared)) +
  geom_jitter(width = 0.4)
```

В большей степени это Африка.

Мы можем отфильтровать данные соответствующие странам, с особо низким коэффициентом детерминации, и отобразить из в виде графика.

```{r}
bad_fit <- filter(glance, r.squared < 0.25)

gapminder %>% 
  semi_join(bad_fit, by = "country") %>% 
  ggplot(aes(year, lifeExp, color = country)) +
  geom_line()
```

Ну в моём случае это вот так. Но вообще, там стран побольше конечно.

Здесь видно не отчётливо. Но в оригинале выделяются два основных эффекта --- эпидемия СПИД (1999-2002 годы) и геноцид в Руанде.

#### Упражнение 25.2.1
<div class="question">
A linear trend seems to be slightly too simple for the overall trend. Can you do better with a quadratic polynomial? How can you interpret the coefficients of the quadratic? Hint you might want to transform year so that it has mean zero.)
</div>


