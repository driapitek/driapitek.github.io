---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Обработка множества моделей с помощью пакетов `purrr` и `broom`
### Введение

Тут советуют не отчаиваться если сразу не получится осмыслить всё то что здесь объясняется.

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(modelr)
```

### Набор данных `gapminder`

В наборе соз=держится информация об изменении во времени суммарных показателей развития стран мира, рассчитанных на основк таких статистик как средняя продолжительность жизни и ВВП.

```{r}
library(gapminder)
gapminder
```

В данном примере мы сосредоточим внимание всего лишь на трех переменных и попытаемся ответить на вопрос: "Как изменяется средняя продолжительность жизни `lifeExp` со временем `year` для каждой страны `country`.

```{r}
gapminder %>% 
  ggplot(aes(year, lifeExp, group = country)) +
  geom_line()
```

Набор хоть и небольшой но тем не менее так сразу и не скажешь что тут происходит.
Один из способов заключается в том, чтобы использовать тот же подход, что и в предыдущей главе: существует один сильный сигнал (общий линейный тренд), который затрудняет наблюдение более слабых трендов.
Мы разведем эти факторы посредством построения модели с линейным трендом.
Эта модель захватит постоянный рост во времени, а остатки покажут, что остается.

Мы знаем как сделать это для одной страны.

```{r}
nz <- filter(gapminder, country == "New Zealand")

nz %>% 
  ggplot(aes(year, lifeExp)) +
  geom_line() +
  ggtitle("Full data")

nz_mod <- lm(lifeExp ~ year, data = nz)

nz %>% 
  add_predictions(nz_mod) %>% 
  ggplot(aes(year, pred)) +
  geom_line() +
  ggtitle("Linear trend")

nz %>% 
  add_residuals(nz_mod) %>% 
  ggplot(aes(year, resid)) +
  geom_line() +
  ggtitle("Remaining pattern")
```

Теперь посмотрим как строить модель для каждой страны.

#### Вложенные данные

Сделаем вложенные данные

```{r}
by_country <- gapminder %>% 
  group_by(country, continent) %>% 
  ?nest()

by_country

by_country <- if (require("gapminder")) {
  gapminder %>%
    group_by(country, continent) %>%
    nest()

  gapminder %>%
    nest(-country, -continent)
}
```

Последняя функция позволяет вложить в тиббл-фрейм ещё один тиббл-фрейм.

Это создает фрейм данных, который имеет одну строку на группу (на страну) и довольно необычный столбец: данные. Данные - это список фреймов данных (или, если быть точным, фрагментов данных). Это кажется сумасшедшей идеей: у нас есть фрейм данных со столбцом, который является списком других фреймов данных! Я вскоре объясню, почему я думаю, что это хорошая идея.

Столбец данных немного сложен, потому что это умеренно сложный список, и мы все еще работаем над хорошими инструментами для изучения этих объектов. К сожалению, использование str () не рекомендуется, так как это часто приводит к очень длинному выводу. Но если вы выделите один элемент из столбца данных, вы увидите, что он содержит все данные для этой страны (в данном случае, Афганистан).

```{r}
by_country$data[[50]]

by_country <- by_country %>% 
  head(29)
```

Обратите внимание на разницу между стандартным сгруппированным кадром данных и вложенным фреймом данных: в сгруппированном фрейме данных каждая строка является наблюдением; во вложенном фрейме данных каждая строка является группой. Еще один способ думать о вложенном наборе данных - теперь у нас есть мета-наблюдение: строка, представляющая полный временной курс для страны, а не один момент времени.

#### Столбцы-списки

Теперь, когда у нас есть вложенный фрейм данных, мы в состоянии приспособиться к некоторым моделям. У нас есть функция подбора модели:

```{r}
country_model <- function(df) {
  lm(lifeExp ~ year, data = df)
}
```

И мы хотим применить его к каждому фрейму данных. Фреймы данных находятся в списке, поэтому мы можем использовать `purrr::map()`, чтобы применить `country_model` к каждому элементу:

```{r}
models <- map(by_country$data, country_model)
```

Однако вместо того, чтобы оставлять список моделей как свободно плавающий объект, я думаю, что лучше хранить его в виде столбца во фрейме данных `by_country`. 
Хранение связанных объектов в столбцах является ключевой частью значения фреймов данных, и поэтому я считаю, что списочные столбцы - это хорошая идея. 
В ходе работы с этими странами у нас будет много списков, в которых у нас будет один элемент на страну. Так почему бы не хранить их все вместе в одном фрейме данных?

Другими словами, вместо создания нового объекта в глобальной среде, мы собираемся создать новую переменную во фрейме данных `by_country`. Это работа для `dplyr::mutate()`:

```{r}
by_country <- by_country %>% 
  mutate(model = map(data, country_model))
by_country
```

Это имеет большое преимущество: поскольку все связанные объекты хранятся вместе, вам не нужно вручную синхронизировать их при фильтрации или упорядочивании. Семантика фрейма данных позаботится об этом за вас:

```{r}
by_country %>% 
  filter(continent == "Europe")

by_country %>% 
  arrange(continent, country)
```

Если ваш список фреймов данных и список моделей были отдельными объектами, вы должны помнить, что всякий раз, когда вы переупорядочиваете или поднастраиваете один вектор, вы должны переупорядочивать или подгруппировать все остальные, чтобы синхронизировать их. Если вы забудете, ваш код продолжит работать, но он даст неправильный ответ!

#### Отмена вложенния данных

Вычислим остатки

```{r}
by_country <- by_country %>% 
  mutate(
    resid = map2(data, model, add_residuals)
  )

by_country
```

Для того чтобы нарисовать всё на одном графике разгруппируем, и приведём всё к виду обычного тиббл-фрейма

```{r}
resids <- unnest(by_country, resid)
resids
```

Каждый столбец повторяется один раз для каждой строки вложенного столбца.

Теперь, когда у нас есть обычный фрейм данных, построим график остатков

```{r}
resids %>% 
  ggplot(aes(year, resid)) + 
  geom_line(aes(group = country), alpha = 0.3) +
  geom_smooth(se = FALSE)
```

Добавим чуть-чуть информативности --- отобразим по континентам на разных панелях.

```{r}
resids %>% 
  ggplot(aes(year, resid)) +
  geom_line(aes(group = country), alpha = 0.3) +
  facet_wrap(~continent)
```

Большие остатки указывают на то, что мы упустили какую-то тенденцию --- наша модель работает не слишком хорошо.

#### Качество модели

Вместо анализа остатков, возникающих в модели, можно рассмотреть екоторые общие меры качества модели.
До этого мы узнали, как вычислять специализированные меры.
Здесь мы будем использовать функцию `broom::glance()` для извлечения качественных метрик модели. Применяя их к модели, мы получаем фрейм данных, состоящих из одной строки.

```{r}
broom::glance(nz_mod)
```

Создадим фрейм данных с одной строкой для каждой страны.

```{r}
by_country %>% 
  mutate(glance = map(model, broom::glance)) %>% 
  unnest(glance)
```

Это не совсем тот вывод который нужен, поскольку тут ещё есть столбцы списки.
Таково поведение по-умолчанию. Чтобы отменить это поведение нужно:

```{r}
glance <- by_country %>% 
  mutate(glance = map(model, broom::glance)) %>% 
  unnest(glance, .drop = TRUE)
```

Имея в своём распоряжении новые данные, мы можем приступить к поиску неудачных моделей.

```{r}
glance %>% 
  arrange(r.squared)
```

Визуализируем, кому больше всего принадлежат неудачные модели

```{r}
glance %>% 
  ggplot(aes(continent, r.squared)) +
  geom_jitter(width = 0.4)
```

В большей степени это Африка.

Мы можем отфильтровать данные соответствующие странам, с особо низким коэффициентом детерминации, и отобразить из в виде графика.

```{r}
bad_fit <- filter(glance, r.squared < 0.25)

gapminder %>% 
  semi_join(bad_fit, by = "country") %>% 
  ggplot(aes(year, lifeExp, color = country)) +
  geom_line()
```

Ну в моём случае это вот так. Но вообще, там стран побольше конечно.

Здесь видно не отчётливо. Но в оригинале выделяются два основных эффекта --- эпидемия СПИД (1999-2002 годы) и геноцид в Руанде.

#### Упражнение 25.2.1
<div class="question">
A linear trend seems to be slightly too simple for the overall trend. Can you do better with a quadratic polynomial? How can you interpret the coefficients of the quadratic? Hint you might want to transform year so that it has mean zero.)
</div>

Квадратичный полином мы можем добавить при помощи функции `poly()`
Преобразуем функцию `country_model` которая дана в учебнике.

```{r}

country_model <- function(df) {
  lm(lifeExp ~ poly(year - median(year), 2), data = df)
}

by_country <- gapminder %>%
  group_by(country, continent) %>%
  nest()

by_country <- by_country %>% 
  head(29)

by_country <- by_country %>%
  mutate(model = map(data, country_model))

by_country <- by_country %>%
  mutate(
    resids = map2(data, model, add_residuals)
  )


unnest(by_country, resids) %>%
  ggplot(aes(year, resid)) +
  geom_line(aes(group = country), alpha = 1 / 3) +
  geom_smooth(se = FALSE) +
  facet_wrap(~continent)

by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance, .drop = TRUE) %>%
  ggplot(aes(continent, r.squared)) +
  geom_jitter(width = 0.2)

glance1 <- by_country %>% 
  mutate(glance = map(model, broom::glance)) %>% 
  unnest(glance, .drop = TRUE)

glance1 %>% arrange(r.squared)
```

Как видно, в моём усечённом примере, квадратный полином улучшил модель. 
Показатель коэффициента детерминации уменьшился для стран Африки.

#### Упражнение 25.2.2
<div class="question">
Explore other methods for visualizing the distribution of $R^2$ per continent. You might want to try the ggbeeswarm package, which provides similar methods for avoiding overlaps as jitter, but uses deterministic methods.
</div>

Вот например такой метод

```{r}
library("ggbeeswarm")
by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance, .drop = TRUE) %>%
  ggplot(aes(continent, r.squared)) +
  geom_beeswarm()
```

Выглядит несколько приятнее чем `jitter`

```{r}
by_country %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance, .drop = TRUE) %>%
  ggplot(aes(continent, r.squared)) +
  geom_quasirandom()
```

А этот почти такой же `jitter`


#### Упражнение 25.2.3
<div class="question">
To create the last plot (showing the data for the countries with the worst model fits), we needed two steps: we created a data frame with one row per country and then semi-joined it to the original dataset. It’s possible to avoid this join if we use `unnest()` instead of `unnest(.drop = TRUE)`. How?
</div>

Для того чтобы избежать объединения, можно дважды раскрыть вложенные столбца списки.

```{r}
gapminder %>%
  group_by(country, continent) %>%
  nest() %>%
  head(29) %>% 
  mutate(model = map(data, ~ lm(lifeExp ~ year, .))) %>%
  mutate(glance = map(model, broom::glance)) %>%
  unnest(glance) %>%
  unnest(data) %>%
  filter(r.squared < 0.25) %>%
  ggplot(aes(year, lifeExp)) +
  geom_line(aes(color = country))
```

### Столбцы-списки

Авторы книги лишь недавно по достоинству оценили вложенные столбцы-списки.
Эта структура данных неявно фигурирует в определении фрейма данных --- фрейм данных это именованный список векторов равной длинны. 
Список это вектор, поэтому всегда можно было на вполне законных основаниях использовать список в качетсве столбца фрейма данных.
Однако базовые пакеты R не позволяют столе же просто создавать столбцы-списки, и функция `data.frame()` торактует список, как список столбцов.

```{r}
data.frame(x = list(1:3, 3:5))
```

Такое поведение функции можно предотвратить с помощи функции `I()`, однако при этом результат выводится не в самом удобном виде

```{r}
data.frame(
  x = I(list(1:3, 3:5)),
  y = c("1, 2", "3, 4, 5")
)
```

Тиббл фрейм позволяет сгладить эту проблему, за счёт того что он более *ленивый* (функция тиббл не изменяет свои входные данные), а так же за счёт того что предоставляет более наглядный метод печати.

```{r}
tibble(
  x = list(1:3, 3:5),
  y = c("1, 2", "3, 4, 5")
)
```

Но с функцией `tribble()` ещё проще работать, по той причине, что она может автоматически определить, что вам нужен список.

```{r}
tribble(
  ~x, ~y,
  1:3, "1, 2",
  3:5, "3, 4, 5"
)
```

Стоит понимать, что столбцы списки наиболее полезны в качестве промежуточных структур данных. С ними тяжело работать непосредственно, поскольку большинство функцй имеют дело с атомарными векторами или фреймами данных, но возможность содержать вместе все родственные эдементы в одном фрейме данных стоит дополнительных хлопот.

В общем случае эффективный канал столбцов-списков состоит из трёх частей

  1. ВЫ создаёте столбец-список с помощью одного из следующих вариантов nest()`, `summarise() + list()`,`mutate()` + функция `map` как описано в разделе создания столбцов-списков.
  2. Вы создаёте другие промежуточные столбцы-списки, преобразуя существующие столбцы-списки с помощью функций `map()`, `map2()` или `pmap()`. Так в предыдуущем типовом примере мы создавали столбец --- список моделей путем преобразования столбца --- списка фреймов данных.
  3. Вы упрощаете столбец-список путем его обратного преобразования во фрейм данных или атомарный вектор, как описано в разделе упрощения столбцов-списков.
  
### Создание столбцов-списков

Для создания используется один из трёх методов

  1. `nest()`. Для преобразования сгруппированного фрейма данных во вложненный фрейм, в котором вы имеете столбец --- список фреймов данных.
  2. с помощью `mutate()` и векторизованных функций, возвращающих список
  3. с помощью `summarise()` и `summary()`, которые возвращают несколько резельтатов.
  
Есть ещё альтернативный способ при помощи `tibble::enframe()`

Объекты в столбцах списках должны быть однородны --- каждый элемент должен содержать объекты одного и того же типа.

#### Создание столбцов списков на основе вложений

`nest()` создает вложенный фрейм данных, представляющий собой столбец-список фреймов данных. Во вложенном фрейму данных каждая строка является метанаблюдением: переменные, которые определяют наблюдение, предоставляются другими столбцами, а столбец --- список фреймов данных предоставляет индивидуальные наблюдения, которые образуют метанаблюдение.

Можно использовать двумя способами

```{r}
gapminder %>% 
  group_by(country, continent) %>% 
  nest()
```

И вот так. Указываем явно, какие столбцы должны быть сгруппированы.

```{r}
gapminder %>% 
  nest(year:gdpPercap)
```

#### Создание столбцов списков на основе векторизованных функций

Некоторые полезные функции принимают атомарный вектор и возваразают список. Например, функция `stringr::str_split()`, она принимает символьный вектор и возвращает список символьных векторов.

Если использовать этот подход в функции `mutate()`, то получим столбец-список

```{r}
df <- tribble(
  ~x1,
  "a,b,c", 
  "d,e,f,g"
) 

df %>% 
  mutate(x2 = stringr::str_split(x1, ","))
```

Функция `unnest()` знает как обрабатывать такие списки векторов.

```{r}
df %>% 
  mutate(x2 = stringr::str_split(x1, ",")) %>% 
  unnest()
```

Есть полезная функция `tidyr::separate_rows()` она является обёрткой для этого полезного шаблона.

Альтернативный вариант этого шаблона предполагает использование функций `map()`, `map2()`, `pmap()`. Например

```{r}
sim <- tribble(
  ~f,      ~params,
  "runif", list(min = -1, max = 1),
  "rnorm", list(sd = 5),
  "rpois", list(lambda = 10)
)

sim %>%
  mutate(sims = invoke_map(f, params, n = 10))
```

#### Создание столбцов списков на основе многозначных итогов

Одним из ограничений `summarise()` является то, что она работает с итоговыми функциями, возвращающими одиночное значение. Таким образом, ее нельзя использовать с функциями наподобие `quantile()` которые возвращают вектор произвольной длины.

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarise(q = quantile(mpg))
```

Однако этот результат можно свернуть в список

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarise(q = list(quantile(mpg)))
```

Для получения полезных результатов с помощью `unnest()` вам так же понадобится получить вероятности

```{r}
probs <- c(0.01, 0.25, 0.5, 0.75, 0.99)
mtcars %>% 
  group_by(cyl) %>% 
  summarise(p = list(probs), q = list(quantile(mpg, probs))) %>% 
  unnest()
```

#### Создание столбцов списков на основе именнованных списков

Фрейм данных со столбцами-списками обеспечивают решение одной часто встречающейся задачи:
как быть, если необходимо итерировать как по содержимому списка, так и по его элементам?
Вместо того чтобы пытаться втиснуть всё в один объект, часто гораздо легче создать фрейм данных: один столбец модет содержать элементы, а другой --- список. Простой способ создания такого фрейма данных из списка предлагает функция `tibble::enframe()`

```{r}
x <- list(
  a = 1:5,
  b = 3:4, 
  c = 5:6
) 

df <- enframe(x)
df
```

Преимущество этой структуры --- она обобщается самым непосредственным образом: имена полезны, если вы имеете дело с символьным вектором метаданных, но в случае других типов данных или нескольких векторов они вам не помогут. 
Теперь, если вы хотите итерировать одновременно по именам и значениям, это можно сделать с помощью `map2`

```{r}
df %>% 
  mutate(
    smry = map2_chr(name, value, ~ stringr::str_c(.x, ": ", .y[1]))
  )
```

#### Упражнение 25.4.1
<div class="question">
List all the functions that you can think of that take a atomic vector and return a list.
</div>

Многие функции работы со строками принимают атомарный вектор и возвращают список

```{r}
str_split(sentences[1:3], " ")

str_match_all(c("abc", "aa", "aabaa", "abbbc"), "a+")
```

Функции семейства `map()` выполняют похожие вещи

```{r}
map(1:3, runif)
```

#### Упражнение 25.4.2
<div class="question">
Brainstorm useful summary functions that, like `quantile()`, return multiple values.
</div>

```{r}
range(mtcars$mpg)

fivenum(mtcars$mpg)

boxplot.stats(mtcars$mpg)
```

#### Упражнение 25.4.3
<div class="question">
What’s missing in the following data frame? How does quantile() return that missing piece? Why isn’t that helpful here?
</div>

```{r}
mtcars %>%
  group_by(cyl) %>%
  summarise(q = list(quantile(mpg))) %>%
  unnest()
```

Не хватает конкретные значения квантилей от 0 до 1.
Функция `quantile()` возвращает их в названиях столбцов.

```{r}
quantile(mtcars$mpg)
```

Поскольку функция `unnest()` отбрасывает имена векторов, они здесь бесполезны.

#### Упражнение 25.4.3
<div class="question">
What does this code do? Why might might it be useful?
</div>

```{r}
mtcars %>%
  group_by(cyl) %>%
  summarise_each(funs(list))
```

Этот код создает фрейм данных, в котором каждая строка соответствует значению цилиндров `group_by(cyl)`, а каждое наблюдение для каждого столбца (кроме `cyl`) является вектором всех значений этого столбца для этого значения цилиндров.


### Упрощение столбцов-списков

Чтобы применить методы манипулирования данными и визуализации, которые вы изучили в этой книге, вам нужно упростить список-столбец обратно до обычного столбца (атомарного вектора) или набора столбцов. Техника, которую вы будете использовать, чтобы вернуться к более простой структуре, зависит от того, хотите ли вы одно значение для элемента или несколько значений:

* Если вам нужно одиночное значение, используйте `mutate()` с функциями `map_lgl()`, `map_int()`, `map_dbl()` и `map_chr()` для создания атомарного вектора.

* Если вам нужно несколько значений, используйте `unnest()`, чтобы преобразовать столбцы списка обратно в обычные столбцы, повторяя строки столько раз, сколько необходимо.

Разберём их подробнее

#### Преобразование списка в вектор

Преобразовав свой столбец-список в атомарный выектор, вы получите обычный столбец. Например, вы всегда можете суммировать объект по типу и длине, поэтому следующий код будет работать для любого списка столбца

```{r}
df <- tribble(
  ~x,
  letters[1:5],
  1:3,
  runif(5)
)
  
df %>% mutate(
  type = map_chr(x, typeof),
  length = map_int(x, length)
)
```

Это та же основная информация, которую вы получаете из функции `print()` по умолчанию, но теперь вы можете использовать ее для фильтрации. Это полезный метод, если у вас есть неоднородный список, и вы хотите отфильтровать части, которые не нужны.

Не забывайте о сокращенных вызовах функций `map_*()` - вы можете использовать `map_chr(x, "apple")`, чтобы извлечь строку, хранящуюся в `apple`, для каждого элемента `x`. Это полезно для разделения вложенных списков в обычные столбцы. Используйте аргумент `.null`, чтобы указать значение, которое будет использоваться, если элемент отсутствует (вместо возврата `NULL`):

```{r}
df <- tribble(
  ~x,
  list(a = 1, b = 2),
  list(a = 2, c = 4)
)
df %>% mutate(
  a = map_dbl(x, "a"),
  b = map_dbl(x, "b", .null = NA_real_)
)
```

#### Отмена вложения

Функция `unnest()` работает, повторяя обычные столбцы один раз для каждого элемента списка-столбца. Например, в следующем очень простом примере мы повторяем первую строку 4 раза (потому что там первый элемент y имеет длину четыре), а вторую строку один раз:

```{r}
tibble(x = 1:2, y = list(1:4, 1)) %>% unnest(y)
```

Это означает, что вы не можете одновременно удалить два столбца, которые содержат разное количество элементов:

```{r}
# работает, поскольку y и z содержат одинаковое кол-во элементов
# в каждой строке
df1 <- tribble(
  ~x, ~y,           ~z,
   1, c("a", "b"), 1:2,
   2, "c",           3
)
df1

df1 %>% unnest(y, z)


# Не работает, поскольку y и z имеют разное кол-во элементов
df2 <- tribble(
  ~x, ~y,           ~z,
   1, "a",         1:2,  
   2, c("b", "c"),   3
)
df2

df2 %>% unnest(y, z)
```

Тот же принцип применяется при развертывании списка-столбцов фреймов данных. Вы можете отложить несколько списочных столбцов, если все фреймы данных в каждой строке имеют одинаковое количество строк.

#### Упражнение 25.5.1
<div class="question">
Why might the `lengths()` function be useful for creating atomic vector columns from list-columns?
</div>

Функция `lengths()` возвращает длину каждого элемента в списке. Это может быть полезно для проверки, имеют ли все элементы в столбце списка одинаковую длину. Вы можете получить максимальную длину, чтобы определить, сколько атомных векторных столбцов создать. Это также замена для чего-то вроде `map_int(x, length)` или `sapply(x, length)`.

#### Упражнение 25.5.2
<div class="question">
ist the most common types of vector found in a data frame. What makes lists different?
</div>

Частовстречающиеся вектора это 

* `logical`

* `numeric`

* `integer`

* `character`

* `factor`

Все распространенные типы векторов во фремйах данных являются атомарными. Списки не являются атомарными, поскольку они могут содержать другие списки и другие векторы.

### Приведение данных к аккуратной форме при помоще пакета `broom`

Пакет `broom` предоставляет три основных инструмента для превращения моделей в аккуратные фреймы данных:

* `broom::glance(model)` возвращает строку для каждой модели. В каждом столбце дается сводка модели: либо показатель качества модели, либо сложность, либо их комбинация.

* `broom::tidy(model)` возвращает строку для каждого коэффициента в модели. Каждый столбец содержит информацию об оценке или ее изменчивости.

* `broom::augment(модель, данные)` возвращает строку для каждой строки в данных, добавляя дополнительные значения, такие как невязки, и влияет на статистику.