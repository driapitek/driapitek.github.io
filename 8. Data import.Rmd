---
output: html_document
editor_options: 
  chunk_output_type: console
---



## Импорт данных с помощью пакета `reader`

### Введение

В этой главе я узнаю как нужно экспортировать данные.

#### Необходимые ресурсы

Загружать будем при помощи инструментов библиотеки `tidyverse`

```{r}
library("tidyverse")
```

### Приступаем к работе

Большинство функций пакета `reader` связано с перемезением данных из простых текстовых файлов во фреймы данных. Все эти функции имеют сходный синтаксис

* Функция `read_csv()` читает текстовые файлы с *запятой* в качестве разделителя

* Функция `read_csv2()` читает текстовые файлы с *точку с запятой* в качестве разделителя

* Функция `read_tsv()` читает текстовые файлы с *символом табуляции* в качестве разделителя

* Функция `read_delim()` файлы с любым разделителем

* Функция `read_fwf()` читает текстовые файлы с *фиксированной шириной* полей --- либо по ширине поля с `fwf_widths()`, либо по их позиции с `fwf_positions()`

* Функция `read_table()` читает текстовые файлы с фиксированной шириной полей, в которых столбцы разделены *пробелом*


Работать в качестве примера будем с самым популярным форматом --- `read_csv()`.

Первый аргумент играет наиболее важную роль --- путь к файлу, который мы хотим прочитать.

В качестве примера возьмём простенький набор данных.
```{r}
heights <- read_csv("weight-height.csv")
```

Примечательно, что при чтении файла функция выводит спецификацию столбцов, в которой указывает тип данных.

Кроме того, можно самому сгенерировать csv-file например таким образом:

```{r}
read_csv("a, b, c
1, 2, 3
4, 5, 6")
```

В качестве названий столбцов используется первая строка. Есть несколько ситуаций, когда может понадобится изменить это поведение.

1. Некоторые файлы начинаются с нескольких строк метаданных. Их можно скипнуть аргументом `skip = n`, чтобы пропустить `n`  первых строк. Или использовать аргумент `comment = "#"` чтобы пропустить все строки начинующиеся на заданный символ `#` 

```{r}
read_csv("The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3", skip = 2)

read_csv("# A comment I want to skip
  x,y,z
  1,2,3", comment = "#")
```

1. Данные могут не иметь названий столбцов. ЧТобы не обрабатывать первую строку как строку заголовкой, необходимо использовать аргумент `col_names = FALSE`. В этом случае в заголовки столбцов будут автоматически помещены последовательные метки от `X1` до `Xn`

```{r}
read_csv("1,2,3\n4,5,6", col_names = FALSE)
```

Ещё один способ, когда необходимо обозвать переменные чтобы не запутаться, передать вместе с аргументом `col_names` символьный вектор с названиями столбцов.

```{r}
read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
```

Можно читать и более сложные форматы, но для этого необходимо погрузиться в дебри пакета `readr`.


#### Сравнение с базовыми возможностями R

Я уже замечал при наборе функции что R предлагает мне функцию `read.csv()` вместо желаемой `read_csv()`. Оказывается функция с точкой это базовая функция. И предпочтительно её *не использовать*. По следующим веским причинам:

* Функция `read_csv()` из пакета `readr` работает быстрее

* Функция создаёт tibble-формат со всеми вытекающими бонусами

* Их поведение воспроизводимо и не зависит от используемой операционной системы

#### Упражнение 11.2.2.1
<div class="question">
What function would you use to read a file where fields were separated with “|”?
</div>

Функция `read_delim()` читает файлы с любым разделителем. Поэтому я бы использовал её

```{r}
# read_delim(file, delim = "|")
```

#### Упражнение 11.2.2.2
<div class="question">
Apart from `file`, `skip`, and `comment`, what other arguments do `read_csv()` and `read_tsv()` have in common?
</div>

`read_csv()` и `read_tsv()` имеют следующие аргументы:

* file - Либо путь к файлу, либо соединение, либо литеральные данные (либо одна строка, либо необработанный вектор).

* delim --- Один символ используется для разделения полей в записи.

* quote --- Один символ используется для цитирования строк.

* escape_backslash --- Использует ли файл обратную косую черту, чтобы избежать специальных символов? Это более общий, чем escape_double, поскольку обратные слэши могут использоваться для исключения символа разделителя, символа кавычки или для добавления специальных символов, таких как \ n.

* escape_double --- Сохраняет ли файл кавычки, удваивая их? т. е. если этот параметр имеет значение ИСТИНА, значение "" "" представляет собой одиночную кавычку \ ".

* col_names --- Или TRUE, FALSE или символьный вектор имен столбцов.
Если TRUE, первая строка ввода будет использоваться в качестве имен столбцов и не будет включена в фрейм данных. Если FALSE, имена столбцов будут сгенерированы автоматически: X1, X2, X3 и т. Д.
Если col_names является символьным вектором, значения будут использоваться в качестве имен столбцов, а первая строка ввода будет считана в первой строке кадра выходных данных.
Названия столбцов Missing (NA) генерируют предупреждение и заполняются фиктивными именами X1, X2 и т. Д. Дублирующие имена столбцов генерируют предупреждение и становятся уникальными с числовым префиксом.

* col_types --- тип данных в столбцу

* locale --- язык по умолчанию

* na --- Символьный вектор строк для использования для отсутствующих значений. Установите этот параметр для символа (), чтобы указать отсутствие пропущенных значений.

* quoted_na --- Если отсутствующие значения внутри кавычек должны рассматриваться как отсутствующие значения (по умолчанию) или строки.

* comment --- Строка, используемая для идентификации комментариев. Любой текст после символов комментария будет игнорироваться.

* trim_ws --- Следует ли обрезать передние и конечные пробелы из каждого поля перед его разбором?

* skip --- Количество строк для пропусков перед чтением данных.

* n_max --- Максимальное количество записей для чтения.

* guess_max --- Максимальное количество записей, используемых для угадывания типов столбцов.

* progress --- Отобразить индикатор выполнения? По умолчанию он будет отображаться только в интерактивном сеансе, а не во время вставки документа. Дисплей обновляется каждые 50 000 значений и будет отображаться только в том случае, если приблизительное время показа составляет 5 секунд или более. Автоматический индикатор выполнения можно отключить, установив параметр readr.show_progress в FALSE.

можно посмотреть список общих аргументов формулой
```{r}
union(names(formals(read_csv)), names(formals(read_tsv)))
```

Разберём написанный код:

* функция `formals()` получает или устанавливает аргументы функции и показывает значения по умолчанию этих аргументов.

```{r}
formals(read_csv)
```

* функция `names()` задаёт или получает названия объекта

```{r}
names(formals(read_csv))
```

* функция `union()` сравнивает по средствам оператора `И` и объединяет наборы данных

#### Упражнение 11.2.2.3
<div class="question">
What are the most important arguments to `read_fwf()`?
</div>

Так как функция `read_fwf()` читает форматы с фиксированной шириной, то наиболее важным аргументом `read_fwf()`, является `col_positions`, который сообщает функции, где столбцы данных начинаются и заканчиваются.

#### Упражнение 11.2.2.4
<div class="question">
Sometimes strings in a CSV file contain commas. To prevent them from causing problems they need to be surrounded by a quoting character, like `"` or `'`. By convention, `read_csv()` assumes that the quoting character will be `"`, and if you want to change it you’ll need to use `read_delim()` instead. What arguments do you need to specify to read the following text into a data frame?

```{r}
"x,y\n1,'a,b'"
```
</div>

Привыкаем орудовать с именованием.
```{r}
# Сначала присваиваем заданный набор символов в переменную
x <- "x,y\n1,'a,b'"
# Для чтения этого набора символов как фрейм данных, используем функцию read_csv()
# Нам нужно выделить элемент, не нарушая его целостности
# Для этого нужно процитировать текст как есть. Это умеет аргумент quote
# Объявим знаком начала-окончания цитаты одинарную ковычку
read_csv(x, quote = "'")
```

#### Упражнение 11.2.2.5
<div class="question">
Identify what is wrong with each of the following inline CSV files. What happens when you run the code?
</div>

Разберём каждый пример

1. В этом примере в строке заголовка 2 объекта, а в строках значений по три.
```{r}
read_csv("a,b\n1,2,3\n4,5,6")
```

Программа "удаляет" или если угодно скрывает значения, для которых не объявлен заголовок. Чтобы прочитать всё как следует, необходимо добавить ещё одно название столбца:
```{r}
read_csv("a,b,c\n1,2,3\n4,5,6")
```

1. Этот пример можно интерпретировать разными способами, но я буду придерживаться следующего.
Примем за данность, что перенос всегда строки ставится корректно. Я делаю такое предположение, чтобы не вносить значения данных вручную.
```{r}
read_csv("a,b,c\n1,2\n1,2,3,4")
```

Тогда в этом случае в примере пропущено название одного столбца, и пропущены значения в первой строке в двух последнийх столбцах. Добавим ещё один столбец.
```{r}
read_csv("a,b,c,d\n1,2\n1,2,3,4")
```

1. В этом примере не совсем ясно что должно происходить.

```{r}
read_csv("a,b\n\"1")
```

НАчальная цитата "1 не рассматривается, потому что она не закрыта. И значения для столбца `а` рассматривается как целое число 1.
Даже не стану исправлять.

1. Тоже не совсем ясно. Оба столбца выводятся хорошо, и являются символьными, потому что вы каждом содержатся буквы.

```{r}
read_csv("a,b\n1,2\na,b")
```

Можно интерпретировать по разному, например вот так: что в столбец `а` автор хотел поместить значения `1,2`, а в столбец `b` --- `a,b`. 

1. В этом используется разделитель точка с запятой вместо просто запятой.

```{r}
read_csv("a;b\n1;3")
```

Это легко исправить, если использовать функцию `read_csv2`

```{r}
read_csv2("a;b\n1;3")
```

### Синтаксический анализ векторов

Парсинг --- это синтаксический анализ. 
Функции семейства `parse_*()` принимают символьный вектор и возвращают вектор специализированного типа.

```{r}
str(parse_logical(c("TRUE", "FALSE", "NA")))
str(parse_integer(c("1", "2", "3")))
str(parse_date(c("2010-01-01", "1979-10-14")))
```

Функция `str()` --- Компактно отображает внутреннюю структуру объекта R, диагностическую функцию и альтернативу сводке (и в некоторой степени, dput). В идеале отображается только одна строка для каждой «базовой» структуры. Он особенно хорошо подходит для компактного отображения (сокращенного) содержимого (возможно, вложенных) списков. Идея состоит в том, чтобы дать разумный результат для любого объекта R. Он вызывает args для (не-примитивных) объектов функции.

Функции этого семейства унифицированны --- их первый аргумент, это символьный вектор подлежащий анализу. Аргумент `na` указывает на то какие строки считать пропущенными значениями

```{r}
parse_integer(c("1", "231", ".", "456"), na = ".")
```

В случае неуспешного парсинга элемента выводится соответствующее сообщение

```{r}
x <- parse_integer(c("123", "345", "abc", "123.45"))
```

Такие элементы при выводе отмечаются как отсутсвующие элементы

```{r}
x
```

Чтобы изучить полный набор ошибок парсинга можно воспользоваться функцией `problems()`. Он возвращает tibble-frame которым можно манипулировать с помощью пакета `dplyr` 

```{r}
problems(x)
```

Эффективное выполнение парсинга требует знания того , какие парсеры имеются в вашем располряжении и как они обрабатывают различные типы входных данных. Чаще всего используются девять парсеров:

* `parse_logical()` и `parse_integer()` --- парсинг логических и целочисленных значений соответственно. Никаких затруднений при работе с ними в основном не возникает.

* `parse_double()` строгий числовой парсер, тогда как  `parse_number()` --- гибкий числовой парсер. Работать с ними сложнее, по скольку в разных странах числа записываются по разному.

* `parse_character()` --- символьный парсер, пригодится для того чтобы перекидывать символьные кодировки.


* `parse_factor()` --- создает факторы, или структуры данных, которые R использует для предоставления категориальных переменных, т.е. переменных, имеющих известный фиксированный набор возможных значений.

* `parse_datetime()`, `parse_date()`, and `parse_time()` --- позволяют анализировать значения даты и времени, заданные в соответствии с различными спецификащиями. Эти парсеры отличаются наибольшей сложностью ввиду существования множества различных форматов записи дат и времени.

#### Парсинг чисел

Парсинг чисел осложняется следующими обстоятельствами:

1. В разных странах числа записывают по-разному --- разделение бывает точкой, а бывает запятой

2. Числа окружены другими символами, обеспечивающими определённый контекст `100%` `$1007`

3. Числа часто содержат разделители групп разрядов `100,000,000`.  При чём в разных странах для этих целей могут использоваться разные символы.

Чтобы справиться с первой проблемой в введено понятие локали --- объекта определяющего правила парсинга. Можно задавать при помощи локали символ разделяющий десятичного разделителя.

```{r}
parse_double("1.23")

parse_double("1,23", locale = locale(decimal_mark = ","))
```

По умолчанию используется локаль для США. 

Чтобы справиться со второй проблемой нужно использовать `parse_number()` --- она игнорирует символы которые располагаются непосредственно перед числом и после него.

```{r}
parse_number("$100")
parse_number("20%")
parse_number("It cost $123.45")
```

Последняя проблема решается путём совместного использования фнкции `parse_number()` и локали, которая задает символ, группирующий цифры по разрядам.

```{r}
# Используется в США
parse_number("$123,456,789")
```

```{r}
# Используется во многих европейских странах
parse_number(
  "$123.456.789",
  locale = locale(grouping_mark = "."))
```

```{r}
# Используется в Швейцарии
parse_number(
  "$123'456'789",
  locale = locale(grouping_mark = "'"))
```


