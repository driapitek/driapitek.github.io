---
output: html_document
editor_options: 
  chunk_output_type: console
---



## Импорт данных с помощью пакета `reader`

### Введение

В этой главе я узнаю как нужно экспортировать данные.

#### Необходимые ресурсы

Загружать будем при помощи инструментов библиотеки `tidyverse`

```{r}
library("tidyverse")
```

### Приступаем к работе

Большинство функций пакета `reader` связано с перемезением данных из простых текстовых файлов во фреймы данных. Все эти функции имеют сходный синтаксис

* Функция `read_csv()` читает текстовые файлы с *запятой* в качестве разделителя

* Функция `read_csv2()` читает текстовые файлы с *двоеточием* в качестве разделителя

* Функция `read_tsv()` читает текстовые файлы с *символом табуляции* в качестве разделителя

* Функция `read_delim()` файлы с любым разделителем

* Функция `read_fwf()` читает текстовые файлы с *фиксированной шириной *полей --- либо по ширине поля с `fwf_widths()`, либо по их позиции с `fwf_positions()`

* Функция `read_table()` читает текстовые файлы с фиксированной шириной полей, в которых столбцы разделены *пробелом*


Работать в качестве примера будем с самым популярным форматом --- `read_csv()`.

Первый аргумент играет наиболее важную роль --- путь к файлу, который мы хотим прочитать.

В качестве примера возьмём простенький набор данных.
```{r}
heights <- read_csv("weight-height.csv")
```

Примечательно, что при чтении файла функция выводит спецификацию столбцов, в которой указывает тип данных.

Кроме того, можно самому сгенерировать csv-file например таким образом:

```{r}
read_csv("a, b, c
1, 2, 3
4, 5, 6")
```

В качестве названий столбцов используется первая строка. Есть несколько ситуаций, когда может понадобится изменить это поведение.

1. Некоторые файлы начинаются с нескольких строк метаданных. Их можно скипнуть аргументом `skip = n`, чтобы пропустить `n`  первых строк. Или использовать аргумент `comment = "#"` чтобы пропустить все строки начинующиеся на заданный символ `#` 

```{r}
read_csv("The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3", skip = 2)

read_csv("# A comment I want to skip
  x,y,z
  1,2,3", comment = "#")
```

1. Данные могут не иметь названий столбцов. ЧТобы не обрабатывать первую строку как строку заголовкой, необходимо использовать аргумент `col_names = FALSE`. В этом случае в заголовки столбцов будут автоматически помещены последовательные метки от `X1` до `Xn`

```{r}
read_csv("1,2,3\n4,5,6", col_names = FALSE)
```

Ещё один способ, когда необходимо обозвать переменные чтобы не запутаться, передать вместе с аргументом `col_names` символьный вектор с названиями столбцов.

```{r}
read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
```

Можно читать и более сложные форматы, но для этого необходимо погрузиться в дебри пакета `readr`.


#### Сравнение с базовыми возможностями R

Я уже замечал при наборе функции что R предлагает мне функцию `read.csv()` вместо желаемой `read_csv()`. Оказывается функция с точкой это базовая функция. И предпочтительно её *не использовать*. По следующим веским причинам:

* Функция `read_csv()` из пакета `readr` работает быстрее

* Функция создаёт tibble-формат со всеми вытекающими бонусами

* Их поведение воспроизводимо и не зависит от используемой операционной системы

#### Упражнение 11.2.2.1
<div class="question">
What function would you use to read a file where fields were separated with “|”?
</div>

Функция `read_delim()` читает файлы с любым разделителем. Поэтому я бы использовал её

```{r}
# read_delim(file, delim = "|")
```

