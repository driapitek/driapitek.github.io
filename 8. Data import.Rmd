---
output: html_document
editor_options: 
  chunk_output_type: console
---



## Импорт данных с помощью пакета `reader`

### Введение

В этой главе я узнаю как нужно экспортировать данные.

#### Необходимые ресурсы

Загружать будем при помощи инструментов библиотеки `tidyverse`

```{r}
library("tidyverse")
```

### Приступаем к работе

Большинство функций пакета `reader` связано с перемезением данных из простых текстовых файлов во фреймы данных. Все эти функции имеют сходный синтаксис

* Функция `read_csv()` читает текстовые файлы с *запятой* в качестве разделителя

* Функция `read_csv2()` читает текстовые файлы с *точку с запятой* в качестве разделителя

* Функция `read_tsv()` читает текстовые файлы с *символом табуляции* в качестве разделителя

* Функция `read_delim()` файлы с любым разделителем

* Функция `read_fwf()` читает текстовые файлы с *фиксированной шириной* полей --- либо по ширине поля с `fwf_widths()`, либо по их позиции с `fwf_positions()`

* Функция `read_table()` читает текстовые файлы с фиксированной шириной полей, в которых столбцы разделены *пробелом*


Работать в качестве примера будем с самым популярным форматом --- `read_csv()`.

Первый аргумент играет наиболее важную роль --- путь к файлу, который мы хотим прочитать.

В качестве примера возьмём простенький набор данных.
```{r}
heights <- read_csv("weight-height.csv")
```

Примечательно, что при чтении файла функция выводит спецификацию столбцов, в которой указывает тип данных.

Кроме того, можно самому сгенерировать csv-file например таким образом:

```{r}
read_csv("a, b, c
1, 2, 3
4, 5, 6")
```

В качестве названий столбцов используется первая строка. Есть несколько ситуаций, когда может понадобится изменить это поведение.

1. Некоторые файлы начинаются с нескольких строк метаданных. Их можно скипнуть аргументом `skip = n`, чтобы пропустить `n`  первых строк. Или использовать аргумент `comment = "#"` чтобы пропустить все строки начинующиеся на заданный символ `#` 

```{r}
read_csv("The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3", skip = 2)

read_csv("# A comment I want to skip
  x,y,z
  1,2,3", comment = "#")
```

1. Данные могут не иметь названий столбцов. ЧТобы не обрабатывать первую строку как строку заголовкой, необходимо использовать аргумент `col_names = FALSE`. В этом случае в заголовки столбцов будут автоматически помещены последовательные метки от `X1` до `Xn`

```{r}
read_csv("1,2,3\n4,5,6", col_names = FALSE)
```

Ещё один способ, когда необходимо обозвать переменные чтобы не запутаться, передать вместе с аргументом `col_names` символьный вектор с названиями столбцов.

```{r}
read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
```

Можно читать и более сложные форматы, но для этого необходимо погрузиться в дебри пакета `readr`.


#### Сравнение с базовыми возможностями R

Я уже замечал при наборе функции что R предлагает мне функцию `read.csv()` вместо желаемой `read_csv()`. Оказывается функция с точкой это базовая функция. И предпочтительно её *не использовать*. По следующим веским причинам:

* Функция `read_csv()` из пакета `readr` работает быстрее

* Функция создаёт tibble-формат со всеми вытекающими бонусами

* Их поведение воспроизводимо и не зависит от используемой операционной системы

#### Упражнение 11.2.2.1
<div class="question">
What function would you use to read a file where fields were separated with “|”?
</div>

Функция `read_delim()` читает файлы с любым разделителем. Поэтому я бы использовал её

```{r}
# read_delim(file, delim = "|")
```

#### Упражнение 11.2.2.2
<div class="question">
Apart from `file`, `skip`, and `comment`, what other arguments do `read_csv()` and `read_tsv()` have in common?
</div>

`read_csv()` и `read_tsv()` имеют следующие аргументы:

* file - Либо путь к файлу, либо соединение, либо литеральные данные (либо одна строка, либо необработанный вектор).

* delim --- Один символ используется для разделения полей в записи.

* quote --- Один символ используется для цитирования строк.

* escape_backslash --- Использует ли файл обратную косую черту, чтобы избежать специальных символов? Это более общий, чем escape_double, поскольку обратные слэши могут использоваться для исключения символа разделителя, символа кавычки или для добавления специальных символов, таких как \ n.

* escape_double --- Сохраняет ли файл кавычки, удваивая их? т. е. если этот параметр имеет значение ИСТИНА, значение "" "" представляет собой одиночную кавычку \ ".

* col_names --- Или TRUE, FALSE или символьный вектор имен столбцов.
Если TRUE, первая строка ввода будет использоваться в качестве имен столбцов и не будет включена в фрейм данных. Если FALSE, имена столбцов будут сгенерированы автоматически: X1, X2, X3 и т. Д.
Если col_names является символьным вектором, значения будут использоваться в качестве имен столбцов, а первая строка ввода будет считана в первой строке кадра выходных данных.
Названия столбцов Missing (NA) генерируют предупреждение и заполняются фиктивными именами X1, X2 и т. Д. Дублирующие имена столбцов генерируют предупреждение и становятся уникальными с числовым префиксом.

* col_types --- тип данных в столбцу

* locale --- язык по умолчанию

* na --- Символьный вектор строк для использования для отсутствующих значений. Установите этот параметр для символа (), чтобы указать отсутствие пропущенных значений.

* quoted_na --- Если отсутствующие значения внутри кавычек должны рассматриваться как отсутствующие значения (по умолчанию) или строки.

* comment --- Строка, используемая для идентификации комментариев. Любой текст после символов комментария будет игнорироваться.

* trim_ws --- Следует ли обрезать передние и конечные пробелы из каждого поля перед его разбором?

* skip --- Количество строк для пропусков перед чтением данных.

* n_max --- Максимальное количество записей для чтения.

* guess_max --- Максимальное количество записей, используемых для угадывания типов столбцов.

* progress --- Отобразить индикатор выполнения? По умолчанию он будет отображаться только в интерактивном сеансе, а не во время вставки документа. Дисплей обновляется каждые 50 000 значений и будет отображаться только в том случае, если приблизительное время показа составляет 5 секунд или более. Автоматический индикатор выполнения можно отключить, установив параметр readr.show_progress в FALSE.

можно посмотреть список общих аргументов формулой
```{r}
union(names(formals(read_csv)), names(formals(read_tsv)))
```

Разберём написанный код:

* функция `formals()` получает или устанавливает аргументы функции и показывает значения по умолчанию этих аргументов.

```{r}
formals(read_csv)
```

* функция `names()` задаёт или получает названия объекта

```{r}
names(formals(read_csv))
```

* функция `union()` сравнивает по средствам оператора `И` и объединяет наборы данных

#### Упражнение 11.2.2.3
<div class="question">
What are the most important arguments to `read_fwf()`?
</div>

Так как функция `read_fwf()` читает форматы с фиксированной шириной, то наиболее важным аргументом `read_fwf()`, является `col_positions`, который сообщает функции, где столбцы данных начинаются и заканчиваются.

#### Упражнение 11.2.2.4
<div class="question">
Sometimes strings in a CSV file contain commas. To prevent them from causing problems they need to be surrounded by a quoting character, like `"` or `'`. By convention, `read_csv()` assumes that the quoting character will be `"`, and if you want to change it you’ll need to use `read_delim()` instead. What arguments do you need to specify to read the following text into a data frame?

```{r}
"x,y\n1,'a,b'"
```
</div>

Привыкаем орудовать с именованием.
```{r}
# Сначала присваиваем заданный набор символов в переменную
x <- "x,y\n1,'a,b'"
# Для чтения этого набора символов как фрейм данных, используем функцию read_csv()
# Нам нужно выделить элемент, не нарушая его целостности
# Для этого нужно процитировать текст как есть. Это умеет аргумент quote
# Объявим знаком начала-окончания цитаты одинарную ковычку
read_csv(x, quote = "'")
```

#### Упражнение 11.2.2.5
<div class="question">
Identify what is wrong with each of the following inline CSV files. What happens when you run the code?
</div>

Разберём каждый пример

1. В этом примере в строке заголовка 2 объекта, а в строках значений по три.
```{r}
read_csv("a,b\n1,2,3\n4,5,6")
```

Программа "удаляет" или если угодно скрывает значения, для которых не объявлен заголовок. Чтобы прочитать всё как следует, необходимо добавить ещё одно название столбца:
```{r}
read_csv("a,b,c\n1,2,3\n4,5,6")
```

1. Этот пример можно интерпретировать разными способами, но я буду придерживаться следующего.
Примем за данность, что перенос всегда строки ставится корректно. Я делаю такое предположение, чтобы не вносить значения данных вручную.
```{r}
read_csv("a,b,c\n1,2\n1,2,3,4")
```

Тогда в этом случае в примере пропущено название одного столбца, и пропущены значения в первой строке в двух последнийх столбцах. Добавим ещё один столбец.
```{r}
read_csv("a,b,c,d\n1,2\n1,2,3,4")
```

1. В этом примере не совсем ясно что должно происходить.

```{r}
read_csv("a,b\n\"1")
```

НАчальная цитата "1 не рассматривается, потому что она не закрыта. И значения для столбца `а` рассматривается как целое число 1.
Даже не стану исправлять.

1. Тоже не совсем ясно. Оба столбца выводятся хорошо, и являются символьными, потому что вы каждом содержатся буквы.

```{r}
read_csv("a,b\n1,2\na,b")
```

Можно интерпретировать по разному, например вот так: что в столбец `а` автор хотел поместить значения `1,2`, а в столбец `b` --- `a,b`. 

1. В этом используется разделитель точка с запятой вместо просто запятой.

```{r}
read_csv("a;b\n1;3")
```

Это легко исправить, если использовать функцию `read_csv2`

```{r}
read_csv2("a;b\n1;3")
```

### Синтаксический анализ векторов

Парсинг --- это синтаксический анализ. 
Функции семейства `parse_*()` принимают символьный вектор и возвращают вектор специализированного типа.

```{r}
str(parse_logical(c("TRUE", "FALSE", "NA")))
str(parse_integer(c("1", "2", "3")))
str(parse_date(c("2010-01-01", "1979-10-14")))
```

Функция `str()` --- Компактно отображает внутреннюю структуру объекта R, диагностическую функцию и альтернативу сводке (и в некоторой степени, dput). В идеале отображается только одна строка для каждой «базовой» структуры. Он особенно хорошо подходит для компактного отображения (сокращенного) содержимого (возможно, вложенных) списков. Идея состоит в том, чтобы дать разумный результат для любого объекта R. Он вызывает args для (не-примитивных) объектов функции.

Функции этого семейства унифицированны --- их первый аргумент, это символьный вектор подлежащий анализу. Аргумент `na` указывает на то какие строки считать пропущенными значениями

```{r}
parse_integer(c("1", "231", ".", "456"), na = ".")
```

В случае неуспешного парсинга элемента выводится соответствующее сообщение

```{r}
x <- parse_integer(c("123", "345", "abc", "123.45"))
```

Такие элементы при выводе отмечаются как отсутсвующие элементы

```{r}
x
```

Чтобы изучить полный набор ошибок парсинга можно воспользоваться функцией `problems()`. Он возвращает tibble-frame которым можно манипулировать с помощью пакета `dplyr` 

```{r}
problems(x)
```

Эффективное выполнение парсинга требует знания того , какие парсеры имеются в вашем располряжении и как они обрабатывают различные типы входных данных. Чаще всего используются девять парсеров:

* `parse_logical()` и `parse_integer()` --- парсинг логических и целочисленных значений соответственно. Никаких затруднений при работе с ними в основном не возникает.

* `parse_double()` строгий числовой парсер, тогда как  `parse_number()` --- гибкий числовой парсер. Работать с ними сложнее, по скольку в разных странах числа записываются по разному.

* `parse_character()` --- символьный парсер, пригодится для того чтобы перекидывать символьные кодировки.


* `parse_factor()` --- создает факторы, или структуры данных, которые R использует для предоставления категориальных переменных, т.е. переменных, имеющих известный фиксированный набор возможных значений.

* `parse_datetime()`, `parse_date()`, and `parse_time()` --- позволяют анализировать значения даты и времени, заданные в соответствии с различными спецификащиями. Эти парсеры отличаются наибольшей сложностью ввиду существования множества различных форматов записи дат и времени.

#### Парсинг чисел

Парсинг чисел осложняется следующими обстоятельствами:

1. В разных странах числа записывают по-разному --- разделение бывает точкой, а бывает запятой

2. Числа окружены другими символами, обеспечивающими определённый контекст `100%` `$1007`

3. Числа часто содержат разделители групп разрядов `100,000,000`.  При чём в разных странах для этих целей могут использоваться разные символы.

Чтобы справиться с первой проблемой в введено понятие локали --- объекта определяющего правила парсинга. Можно задавать при помощи локали символ разделяющий десятичного разделителя.

```{r}
parse_double("1.23")

parse_double("1,23", locale = locale(decimal_mark = ","))
```

По умолчанию используется локаль для США. 

Чтобы справиться со второй проблемой нужно использовать `parse_number()` --- она игнорирует символы которые располагаются непосредственно перед числом и после него.

```{r}
parse_number("$100")
parse_number("20%")
parse_number("It cost $123.45")
```

Последняя проблема решается путём совместного использования фнкции `parse_number()` и локали, которая задает символ, группирующий цифры по разрядам.

```{r}
# Используется в США
parse_number("$123,456,789")
```

```{r}
# Используется во многих европейских странах
parse_number(
  "$123.456.789",
  locale = locale(grouping_mark = "."))
```

```{r}
# Используется в Швейцарии
parse_number(
  "$123'456'789",
  locale = locale(grouping_mark = "'"))
```

#### Парсинг строк

Разберёмся как строки представляются в компьютере. Чтобы в R получить строку в том виде, в каком она хранится в памяти компьютера, следует использовать функцию `charToRaw()`.

```{r}
charToRaw("Stanislav")
```

Выдача --- это числа в шестнадцатиричном формате. Каждое число это байт информации.  

КОдирование --- это отображение шестнадцатиричного числа в символ. Используемый в данном случае код называется ASCII (American Standard Code for Information Interchange --- американский стандартный код для обмена информацией).

В случае языков отличных от английского не всё так просто. Поэтому везде используется негласный стандарт --- UTF8.
Но не во всех случаях используется нужная кодировка. Иногда помогает определить кодировку функция `parse_character()`:

```{r}
x1 <- "El Ni\xf1o was particularly bad this year"
x2 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"

parse_character(x1, locale = locale(encoding = "Latin1"))
parse_character(x2, locale = locale(encoding = "Shift-JIS"))
```

Вот более подробная информация по кодированию-декодированию
[http://kunststube.net/encoding/](http://kunststube.net/encoding/)

#### Факторы

Факторы используются в R для представления *категориальных* значений, т.е. значений образующих известный набор.

```{r}
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)
```

#### Календарные даты, календарные дата и время, время суток

Есть три вида парсинга даты-времени, который зависит от того, что необходимо в конкретной задаче

* Функция `parse_datetime()` ожидает значение определяющее дату и время в соответствии со стандартом ISO8601. ФОрмат такой --- ГГГГ-ММ-ДД ЧЧ:ММ:СС

```{r}
parse_datetime("2010-10-01T2010")
```

* Функция `parse_date()` если нам надо вытащить дату, ожидает значение в одном из форматов ГГГГ-ММ-ДД или ГГГГ/ММ/ДД

```{r}
parse_date("2010-10-01")
```

* Функция `parse_time()` ожидает значение в формате ЧЧ:ММ:СС с необязательным спецификатором a.m./p.m (до полудня/после полудня). Так как в базовых пакетах отсутствует специальный класс, для работы со временем суток принято использовать для этого класс, предоставляемый пакетом `hms`

```{r}
library(hms)
parse_time("01:10 am")
```

Если эти форматы не подходят, можно задать свой.

Year
: `%Y` (4 цифры). 
: `%y` (2 цифры); 00-69 -> 2000-2069, 70-99 -> 1970-1999.

Month
: `%m` (2 цифры).
: `%b` (сокращенное название, например "Jan").
: `%B` (полное название, "January").

Day
: `%d` (2 цифры).
: `%e` (необязательный ведущий пробел).

Time
: `%H` 0-23 часовой формат.
: `%I` 0-12, следует использовать вместе `%p`.
: `%p` AM/PM indicator.
: `%M` минуты.
: `%S` целочисленные секунды.
: `%OS` вещественные секунды.
: `%Z` часовой пояс (as name, e.g. `America/Chicago`). 
: `%z` (смещение от UTC, e.g. `+0800`). 

Нецифровые символы
: `%.` пропуск одного нецифрового символа.
: `%*` пропуск любого количества нецифровых символов.

Лучший способ определить корректный формат --- создать несколько примеров в символьном векторе и протестировать их с помощью одной из функций анализаторов
```{r}
parse_date("01/02/15", "%m/%d/%y")
parse_date("01/02/15", "%d/%m/%y")
parse_date("01/02/15", "%y/%m/%d")
```

В случае использования элементов формата  `%b` или `%B` с названием месяцев не на английском необходимо задать аргумент  `lang` функции `locale`
```{r}
parse_date("3 сентября 2018", "%d %B %Y", locale = locale("ru"))
```

#### Упражнение 11.3.5.1
<div class="question">
What are the most important arguments to `locale()`?
</div>

Наиболее важными аргументами является
 
* `date_format, time format` которые указывают формат даты и времени

* `encoding` кодировка

* `decimal_mark, grouping_mark` разделитель

* `tz` часовой пояс 

#### Упражнение 11.3.5.2
<div class="question">
1. What happens if you try and set `decimal_mark` and `grouping_mark` to the same character? 

2. What happens to the default value of `grouping_mark` when you set `decimal_mark` to `","`? 

3. What happens to the default value of `decimal_mark` when you set the `grouping_mark` to `"."`?
</div>

1. Должна произойти ошибка, потому что интерпретатор попадёт в вилку, что считать десятичным разделитем а что группировкой (так и есть)

```{r}
parse_number(
  "$123.456.789",
  locale = locale(grouping_mark = ".", decimal_mark = "."))
```

2. Не знаю, вероятно `grouping_mark` изменит своё значение на точку (так и есть)

```{r}
locale(decimal_mark = ",")
```

3. Вероятно так же как и в примере выше, `decimal_mark` изменит своё значение на запятую 

```{r}
locale(grouping_mark = ".")
```


#### Упражнение 11.3.5.3
<div class="question">
I didn’t discuss the `date_format` and `time_format` options to `locale()`. What do they do? Construct an example that shows when they might be useful.
</div>

```{r}
locale()
```

По умолчанию заданы форматы `%AD` и `%AT` для соответственно даты и времени.

```{r}
parse_date("1 января 2018", "%d %B %Y", locale = locale(date_names = "ru", date_format = ))

parse_date("21 окт. 1991", "%d %b %Y", locale = locale("ru", time_format ="ioojdpijsdf" ))
```

Сложно придумать пример, если они на что-то и влияют, то мне не удалось придумать пример


#### Упражнение 11.3.5.4
<div class="question">
If you live outside the US, create a new locale object that encapsulates the settings for the types of file you read most commonly.
</div>

Да я живу за пределами Штатов, но пожалуй менять настройки пока что не буду. При случае, если это понадобится надо будет почитать хэлп к локали `?locale`

#### Упражнение 11.3.5.5
<div class="question">
What’s the difference between `read_csv()` and `read_csv2()`?
</div>

* Функция `read_csv()` читает текстовые файлы с *запятой* в качестве разделителя

* Функция `read_csv2()` читает текстовые файлы с *точку с запятой* в качестве разделителя

#### Упражнение 11.3.5.6
<div class="question">
What are the most common encodings used in Europe? What are the most common encodings used in Asia? Do some googling to find out.
</div>

UTF-8 стандарт. Еще уважаемый Скоморохов завещал в любой непонятной ситуации юзать ютф. Вот небольшой расклад по странам и регионам.

* Japanese: JIS X 0208, Shift JIS, ISO-2022-JP
* Chinese: GB 2312, GBK, GB 18030
* Korean: KS X 1001, EUC-KR, ISO-2022-KR
* Western European Latin script languages: ISO-8859-1, Windows-1250 (also CP-1250 for code-point)
* Eastern European Latin script languages: ISO-8859-2, Windows-1252
* Greek: ISO-8859-7
* Turkish: ISO-8859-9, Windows-1254
* Hebrew: ISO-8859-8, IBM424, Windows 1255
* Russian: Windows 1251
* Japanese: Shift JIS, ISO-2022-JP, EUC-JP
* Korean: ISO-2022-KR, EUC-KR
* Chinese: GB18030, ISO-2022-CN (Simplified), Big5 (Traditional)
* Arabic: ISO-8859-6, IBM420, Windows 1256

почитать [http://kunststube.net/encoding/](http://kunststube.net/encoding/)

#### Упражнение 11.3.5.7
<div class="question">
enerate the correct format string to parse each of the following dates and times:
</div>

```{r}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
t1 <- "1705"
t2 <- "11:15:10.12 PM"
```


```{r}
parse_date(d1, "%B %d, %Y")
parse_date(d2, "%Y-%b-%d")
parse_date(d3, "%d-%b-%Y")
parse_date(d4, "%B %d (%Y)")
parse_date(d5, "%m/%d/%y")
parse_time(t1, "%H%M")
parse_time(t2, "%H:%M:%OS %p")
```

### Синтаксический анализ файлов

Разберём два момента

* как пакет `readr` автоматически определяет тип каждого столбца

* как изменить параметры, заданные по умолчанию

#### Стратегия

Для определения каждого типа столбца используется эвристический подход --- берутся первые 1000 строк, и для определения типа столбцов используются эвристические алгоритмы. Это выглядит примерно так --- функция `guess_parser` возвращает наилучшую догадку, `parse_guess` - использует эту догадку для анализа столбца.

```{r}
guess_parser("2010-10-01")
guess_parser("15:01")
guess_parser(c("TRUE", "FALSE"))
guess_parser(c("1", "5", "9"))
guess_parser(c("12,352,561"))

str(parse_guess("2010-10-10"))
```

Эвристика подсчитывает каждый из перечисленных ниже типов, останавливая процесс в случае совпадения:

* logical: содержит только "F", "T", "FALSE", or "TRUE".
* integer: содержит тольцо цифровые символы и ещё `-`.
* double: содержит только допустимые вещественные числа (включая `4.5e-5`).
* number: содержит вещественные числа с разделителями групп разрядов
* time: соответствует формату `time_format`, заданному по умолчанию
* date: соответствует формату `date_format`, заданному по умолчанию
* date-time: любая дата в формате ISO8601

Если ни одно из этих правил не применимо столбец остаётся в виде вектора строк.

#### Проблемы

* Первая тысяча строк может быть не показательной, вследствие чего догадки пакета `readr` окажутся не достаточно общими. Например может быть столбец вещественных значений в первых 1000 строках которого содержатся только целые числа

* СТолбец может содержать множество отсутствующих значений. Если первая тысяча строк содержит лишь значения `NA`, то пакет `readr` сочтет, что это символьный вектор, тогда как вероятно хотелось бы выбрать более специфический способ обработки

Пакет `readr` содержит текстовый csv-файл который иллюстрирует обе проблемы

```{r}
challenge <- read_csv(readr_example("challenge.csv"))
```

```{r}
problems(challenge)
```

*Неплохая стратегия обрабатывать столбец за столбцом пока проблемы не исчезнут.* В данном случае видно, что проблемы связаны со столбцом `x` --- в нем за целочисленными значениями следуют хвостовые символы. Это наводит на мысль что надо использовать парсер вещественных чисел.

Начнем с того, что скопируем и вставим спецификаци столбца в первоначальный вызов

```{r}
challenge <- read_csv(
  readr_example("challenge.csv"),
  col_types = cols(
    x = col_integer(),
    y = col_character()
  )
)
```

Попробуем, не получилось. Значит поправим тип столбца

```{r}
challenge <- read_csv(
  readr_example("challenge.csv"),
  col_types = cols(
    x = col_double(),
    y = col_character()
  )
)
```

Это помогло устранить первую проблему, но если мы присмотримся к нескольким последним строкам, то заметим что они содержат даты, сохраненные в символьном векторе.

```{r}
tail(challenge)
```

Это можно исправить, указав что этот столбец является столбцом дат

```{r}
challenge <- read_csv(
  readr_example("challenge.csv"), 
  col_types = cols(
    x = col_double(),
    y = col_date()
  )
)
tail(challenge)
```

Для каждой функции `parse_xyz()` имеется соответствующая функция `col_xyz()`. Функция `parse_xyz()` используется в тех случаях, когда данные уже находятся в R в виде символьного вектора, а функция `col_xyz()` --- когда нужно сообщить пакету `readr` как нужно загружать данные.

Нам рекомендуют всегда предоставлять типы столбцов, отталкиваясь от вывода, обеспечиваемого пакетом `readr`. Так наш сценарий импорта данных всегда будет согласованным и воспроизводимым.

#### Другие страгтегии 

Существует несколько других общих стратегий

* В предыдущем примере нам просто не повезло, стоило просмтротреть файла всего на одну строку больше, и мы могли бы кооректно выпонлить анализз одним махом:

```{r}
(challenge2 <- read_csv(readr_example("challenge.csv"), guess_max = 1001))
```

* Иногда проще всего диагностировать проблему, прочитав все столбцы как символьные векторы
