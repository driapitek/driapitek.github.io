---
output: html_document
editor_options: 
  chunk_output_type: console
---


## Аккуратизация данных с помощью пакета `tidyr`

### Введение

В этой главе будем узнавать что такое аккуратные данные. Больше про это рассказал Хэдли Уикем в своей [статье](http://www.jstatsoft.org/v59/i10/paper)

#### Необходимые ресурсы

Подключаем библиотеку

```{r}
library("tidyverse")
```


### Аккуратные данные

Существует три правила, соблюдение которых делает набор данных аккуратным:

* каждая переменная должна иметь собственный столбец

* каждое наблюдение должно иметь собственную строку

* каждое значение должно иметь собственную ячейку

Все они взаимосвязаны --- без одного не может быть дву других. Всё это хорошо иллюстрирует изображение

![alt text](img/tidy-1.png)

Всё можно упростить до двух правил 

1. Помещать каждый набор данных в tibble-фрейм

1. Помещеать каждую переменную в столбец

В учебнике было не понятно почему на оси лет такое странное отображение годов.
```{r}
library("ggplot2")
ggplot(table1, aes(year, cases)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country)) 
```

Но когда построил сам врубился --- между точками построения двух годов программа просто добавила 4 промежутка по 0.25

#### Упражнения 12.2.1.1
<div class="question">
Using prose, describe how the variables and observations are organised in each of the sample tables
</div>

```{r}
table1
table2
table3
table4a
table4b
```

1. Таблица 1

Таблица состоит из четырех столбцов-переменных. 
Первый столбец --- категориальная переменная, в которую входят названия трёх стран. 
Второй столбец --- это тоже категориальная переменная, в которой содержатся года в которые происходили наблюдения их два. 
Третий столбец --- это непрерывная переменная "случаи", которая показывает количество случаев происходящих в каждой стране в указанный год
Четвёртый столбец --- тоже непрерывная переменная, которая показывает количество населения соотвтствующее комбинации страна-год-случай

Или если совсем просто:

* Одно наблюдение соответствует одной строке. 
* Одна переменная соответствует одному наблюдению. 
* Одна ячейка соответствует одному значению.

1. Таблица 2

* Одно наблюдение разбито переменной (type) на две строки. В остальном, всё хорошо:
* Одна переменная соответствует одному столбцу
* Одна ячейка соответствует одному значению.

1. Таблица 3

* Одно наблюдение соответствует одной строке. 
* Одна переменная соответствует одному наблюдению. 
* Но в одной ячейке содержится два значения --- (cases/population)

1. Таблицы 4а, 4b

В отдельности эти таблицы являются аккуратными. Но так как они описывают одно измерение, произведено неудобное разделение по переменным ---- (cases) таблица `а` и (population) таблица `b`

#### Упражнения 12.2.1.2
<div class="question">
Compute the rate for table2, and table4a + table4b. You will need to perform four operations:

a) Extract the number of TB cases per country per year.
b) Extract the matching population per country per year.
c) Divide cases by population, and multiply by 10000.
d) Store back in the appropriate place.
e) Which representation is easiest to work with? Which is hardest? Why?</div>
</div>

a) Не очень хорошо получилось. Потому что это просто один столбец значений, без указания года в котором произошло событие.

```{r}
t2_cases <- filter(table2, type == "cases")           # Извлекаем число случаев заболевания
t2_population <- filter(table2, type == "population") # Извлекаем число популяции
t2_rate <- cases$count / population$count * 10000     # Находим отношение
rate <- as.tibble(t2_rate)                            # Сохраняем куда-то
```

Поэтому немного переделаем, чтобы было по красоте

```{r}
t2_cases <- filter(table2, type == "cases") %>%            # Извлекаем число случаев заболевания
  rename(cases = count) %>%                                # Переименовываем стобец
  arrange(country, year)                                   # Сортируем, чтобы избежать ошибок
t2_population <- filter(table2, type == "population") %>%  # Действуем по аналогии и для популяции
  rename(population = count) %>%
  arrange(country, year)
t2_rate <- t2_cases %>% 
  mutate(population = t2_population$population,            # Добавляем переменную популяции
         cases_per_cap = (cases / population) * 10000) %>% # Добавляем переменную с отношением
  select(country, year, cases_per_cap)                     # Оставляем только нужное
```

b) Грязненько это вот так. Разделить отдельно каждый год, и объединить полученные вектора в одну матрицу, а её превратить в тиббл таблицу. Это решение в лоб.

```{r}
table4_1999 <- table4a$`1999` / table4b$`1999` * 10000
table4_2000 <- table4a$`2000` / table4b$`2000` * 10000
table4_rate <- as.tibble(cbind(table4_1999, table4_2000))
```

Элегантнее вот так вот:

```{r}
table4c <-
  tibble(country = table4a$country,
         `1999` = table4a[["1999"]] / table4b[["1999"]] * 10000,
         `2000` = table4a[["2000"]] / table4b[["2000"]] * 10000)
```

Я уже говорил выше, что таблицы 4а и 4b в отрыве друг от друга аккуратные tibble таблицы. Поэтому с ними проще и приятнее работать, чем с "грязной" таблицей номер 2.

#### Упражнения 12.2.1.3
<div class="question">
Recreate the plot showing change in cases over time using table2 instead of table1. What do you need to do first?
</div>

Для того чтобы построить график, нужно для начала высчитать то, что мы проделали в упражнении 2: извлечь все значения для каждого года в отдельности.

```{r}
ggplot(t2_rate, aes(year, cases_per_cap)) +
  geom_line(aes(group = country), color = "grey50") +
  geom_point(aes(color = country))
```

### Рассредоточение и сведение столбцов
