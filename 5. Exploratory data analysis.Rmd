---
editor_options: 
  chunk_output_type: console
output: html_document
---

## Предварительный анализ данных
### Введение

По сути ПАД --- итеративный процесс, включающий три стадии

1. Формулирование вопросов относительно данных

1. Поиск ответов на поставленные вопросы путем их визуализации, преобразования и моделирования данных

1. Использование полученных знаний для уточнения вопросов и (или) формулировки новых запросов.

ПАД --- это способ мышления

#### Необходимые ресурсы
В этой главе закрепляем полученные навыки о пакетах `ggplot` & `dplyr`.

```{r}
library("tidyverse")
library("viridis")
library("forcats")
library("nycflights13")
library("Lahman")
```


### Вопросы

Главная цель ПАД --- добиться понимания данных.
Для понимания данных, может пригодится знания бизнес-аналитики и правильного формулирования вопросов.

Вопросов много, и научиться правильно их задавать, это целое искусство. Но в центре, по крайне мере этой главы будут два вопроса:

1. Вариации какого типа существуют среди переменных

1. Ковариации какого типа существуют между переменными

Определимся с терминологией:

* *Переменная* --- это количество, качество или свойство, которые можно измерить

* *Значение* --- это состояние переменной в момент ее измерения. Значение переменной может изменяться от измерения к измерению.

* *Наблюдение* или *случай* --- это набор измерений, выполненный в одинаоквых условиях обычно все измерения, входящие в наблюдение делаются в одно и тоже время для одного и того же объекта. Наблюдение содержит несколько значений, каждое из которых связано с отдельной переменной. Иногда вместо термина *наблюдение* мы будем использовать термин *точка данных*

* *Табличные данные* --- это набор значений, каждое из которых связано с переменной и наблюдением. Табличные данные считаются аккуратно организованными, если каждое значение находится в собственной ячейку, каждая переменная --- в собственном столбце, а каждое наблюдение --- в собственной строке. 

В столбцах --- переменная, в строке --- наблюдение, на пересечении --- значение.

### Вариация

Вариация --- это свойство значений переменных изменяться от измерения к измерению.

#### Визуализация распределений

Как именно стоит визуализировать переменную, зависит от того какого она типа:

* *Категориальными* --- называются переменные, которые имеют небольшой набор возможных значений.

Для визуализации категориальных переменных хорошо подходит столбчатая диаграмма

```{r}
ggplot(data = diamonds) +
  geom_bar(aes(cut))
```

Высота столбца соответсвует количеству наблюдений для каждого значения. Вычисление вручную:

```{r}
diamonds %>% 
  count(cut)
```

* *Непрерывная* переменная --- это такая переменная которая принимает любое из бесконечного можества упорядоченных значений.

Для визуализации непрерывного распределения нужно использовать гистограмму, она показывает сколько наблюдений попало в конкретный диапазон.

```{r}
ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)
```

Вычисление вручную:

```{r}
diamonds %>% 
  count(cut_width(carat, 0.5))
```

Как учил ещё великий Скоморохов, проверять интервалы гистограмм нужно проверять. Потому что варьируя разбег, можно наткнуться на интересные закономерности. Пример из учебника:

```{r}
ggplot(data = diamonds) +
  geom_histogram(
    mapping = aes(x = carat), binwidth = 0.1) # Меняем значение для того чтобы показать, как изменится вид гистограммы
```

КОгда нужно наложить несколько гистограмм на один график, следует использовать вместо `geom_histogram` функцию `geom_freqpoly`. Статистику для вычисления последняя функция использует такую же как и гистограммы, однако для построения использует линии, а не столбцы.


```{r}
smaller <- diamonds %>% 
  filter(carat < 3)

ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1)
```

#### Типичные значения

В этой части главы, открывается очень интересная грань статистического исследования. Она граничит с бизнес-аналитикой --- это постановка вопросов и обращение внимания на всякого рода закономерности.

Вопросы которые помогут всегда, я их на всякий случай оставлю тут, может когда-то пригодится:

* Какие значения встречаются наиболее часто? Почему?

* Какие значения являются редкими? Почему? Соответствует ли это вашим ожиданиям?

* Замечаете ли вы некоторые необычные закономерности? Чем их можно объяснить

* Хозяйке на заметку --- образование кластеров близких значений, указывает на существование подгрупп среди данных.

* Насколько близки друг к другу наблюдения в пределах каждого кластера?

* Насколько различаются между собой наблюдения, принадлежащие разным кластерам?

* Как можно объяснить или описать кластеры?

* Почему внешний вид кластеров может вводить в заблуждение?

#### Необычные значения

*Выбросами* называют необычные наблюдения --- точки данных, выпадющих из общего ряда.

Хороший пример из учебника. Наличие выбросов заметить нелегко, и только широкий диапазон построения может указывать на то, что здесь помимо построенных столбцов, существуют ещё значения.

```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)
```

На построеннии почти ничего не заметно. Для того чтобы увеличить масштаб необходимо воспользоваться функцией `coord_cartesian()`:
  
```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```

Мы обнаружили выбросы, теперь извлечём их:

```{r}
(unusual <- diamonds %>% 
  filter(y < 3 | y > 20) %>%
  arrange(y))
```

Таким образом мы нашли бриллианты, которые имеют нулевые размеры и имеют стоимость. А так же имеют гигантские размеры, но при этом стоят копейки. С выбросами всегда надо быть осторожным.

#### Упражнение 7.3.4.1
<div class="question">
Explore the distribution of each of the `x`, `y`, and `z` variables in `diamonds`. What do you learn? Think about a diamond and how you might decide which dimension is the length, width, and depth.
</div>

Я хотел построить все три параметра на одной плоскости. Но это было бы не так информативно как панели.

Решение с панелями я подсмотрел [Jeffrey Arnold](https://github.com/jrnold). Но конечено же я не хочу бездумно копировать, поэтому прежде чем приводить его решение, я разберу новые неизвестные для меня, но используемые у Джефри функции.

* Функция `gather()` --- она используется, когда нужно несколько столбцов поместить в одну переменную. Такое иногда необходимо на практике, и я сам пару раз использовал подобный приём в Excel (В дополнении PLEX Еxcell для подобных нужд даже есть специальная функция) Продемонстрирую как работает `gather()`:


```{r}
#--------- Создаём набор данных, в котором есть 10 наблюдений трёх переменных записанных в стандартной форме
(stocks <- data.frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
))
```

Теперь мы хотим построить все три переменные за один приём. Чтобы это сделать, необходимо из трёх переменных сделать одну, и ввести идентификатор различия этой переменной. Эту операцию делает как раз функция `gather()`. Функция первым аргументом берёт набор данных, вторым необходимо указать название переменной, а последующими аргументами необходимо указать требумые переменные.
:

```{r}
gather(stocks, nazavanie_peremennoy, price, -time)
# stocks %>% gather(nazavanie_peremennoy, price, -time)
```

* Функция `geom_density()`. Это кривая распределения, построенная по вершинам гистограммы. Это полезная альтернатива гистограмме для непрерывных данных, которая исходит из лежащего в основе плавного распределения:

```{r}
#--Гистограмма
ggplot(diamonds, aes(carat)) +
  geom_histogram(binwidth = 0.05)
```

```{r}
#--Сглаженная кривая
ggplot(diamonds, aes(carat)) +
  geom_density()
```

А теперь приступим к разбору предлагаемого решения:

```{r}
diamonds %>%                         # Исходный набор данных с бриллиантами
  mutate(id = row_number()) %>%      # Добавить в набор параметр id который нумерует строки
  select(x, y, z, id) %>%            # Взять только изучаемые параметры и номера строк
  gather(variable, value , -id)  %>% # Преобразуем три набора параметров в один, исключаем id
  ggplot(aes(x = value)) +           # В атрибуте aes(), задаём параметр x = value, в котором у нас три переменные x, y, z
  geom_density() +                   # Строим сглаженную гистограмму
  facet_grid(variable ~ .)           # Группируем решение в панели, для визуализации распределния параметров x, y, z
```

Отвечая на вопрос о новых знаниях об этих переменных --- 

1. у всех трёх переменных есть необычные значения ближе к нулю и подальше 30.

1. Все три переменные имеют похожее распределение с двумя ярковыраженными пиками.


Отвечая на вопрос об измерениях --- Бриллианты, как правило, имеют круглую форму. Поэтому два измерения --- длинна и ширина, должны иметь примерно одинаковые значения. На графике выше видно, что `X` и `У` очень похожи между собой, выходит, что `Z` --- это глубина

#### Упражнение 7.3.4.2
<div class="question">
Explore the distribution of `price`. Do you discover anything unusual or surprising? (Hint: Carefully think about the `binwidth` and make sure you try a wide range of values.)
</div>

```{r}
ggplot(diamonds) +
  geom_histogram(aes(price), binwidth = 10) +
  coord_cartesian(xlim = c(0, 2500))
```

1. Цена на бриллианты в этом наборе данных начинается чуть больше чем с 250, я так полагаю ближе к 300 долларам

1. Существует провал в цене рядом со значением 1500

1. Есть всплеск в точках около 750

1. Распределение цены плавно убывает от всплеска 750, до примерно 19000

```{r}
ggplot(diamonds) +
  geom_histogram(aes(price), binwidth = 10) +
  coord_cartesian(xlim = c(0, 2500))
```

```{r}
ggplot(diamonds) +
  geom_histogram(aes(price), binwidth = 10) +
  coord_cartesian(xlim = c(15000, 19000))
```

```{r}
ggplot(diamonds) +
  geom_histogram(aes(price), binwidth = 100)
```

#### Упражнение 7.3.4.3
<div class="question">
How many diamonds are 0.99 carat? How many are 1 carat? What do you think is the cause of the difference?
</div>

разница ощутима:
```{r}
diamonds %>%
  filter(carat >= 0.99, carat <= 1) %>%
  count(carat)
```

Истинная природа может скрываться в округлении веса до сотой, ради цены:

```{r}
diamonds %>%
  filter(carat >= 0.99, carat <= 1) %>%
  group_by(carat) %>%
  summarise(mean_price = mean(price))
```

А может и не скрываться. Эта визуализация показывает пусть и нелинейную но прямопропорциональную зависимость средней цены от веса бриллианта
```{r}
diamonds %>%
  group_by(carat) %>%
  summarise(mean_price = mean(price)) %>%
  ggplot(aes(mean_price, carat)) +
  geom_point()
```

Вероятно бриллианты с "круглыми" каратами более популярны
```{r}
diamonds %>%
   filter(carat >= 0.9, carat <= 1.1) %>%
   count(carat) %>%
   print(n = 30)
```

Не то чтобы это правда, но очень на то похоже

#### Упражнение 7.3.4.4
<div class="question">
Compare and contrast `coord_cartesian()` vs `xlim()` or `ylim()` when zooming in on a histogram. What happens if you leave `binwidth` unset? What happens if you try and zoom so only half a bar shows?
</div>

Функция `coord_cartesian()` как бы увеличивает масштаб в указанных координатах
```{r}
ggplot(diamonds) +
  geom_histogram(aes(price), binwidth = 10) +
  coord_cartesian(xlim = c(1000, 2000))
```

В то время как `xlim()` удаляет все значение между указанными координатами. О чем `R` любезно предупреждает при построении графика.
```{r}
ggplot(diamonds) +
  geom_histogram(aes(price), binwidth = 10) +
  xlim(1000, 2000)
```

Если не задать аргумент `binwidth`, то ав


### Отсутствующие значения

Необычные значения можно:

* Отбросить, но это плохо

```{r}
diamonds2 <- diamonds %>%
  filter(between(y, 3, 20)) # Возьми только значения между 3 и 20 
```

* Лучше всего заменить необычные значения отсутствующими. Для замены можно использовать функцию `ifelse()`. Эта функция и по смыслу и по синтаксису похожа на функцию `ЕСЛИ` в Excel.

```{r}
diamonds2 <- diamonds %>%                   # В новый набор данных добавь новую переменную в которой,
  mutate(y = ifelse(y < 3 | y > 20, NA, y)) # Если значение "y" меньше 3 или больше 20, замени на NA, иначе, оставь их прежними
```

ВНИМАНИЕ. Это целая философия --- отсутствующие значения никогда не должны молчаливо исчезать. Самый приличный и профессиональный метод --- продублировать пресловутую переменную и заменить в ней аномальные значения на отсутствующие. Если возникнет необходимость визуализировать эту переменную, легко можно отбросить отсутствующие значения параметром `na.rm = TRUE`

```{r}
ggplot(diamonds2, aes(x,y)) +
  geom_point(na.rm = TRUE)
```

#### Упражнение 7.3.5.1
<div class="question">
What happens to missing values in a histogram? What happens to missing values in a bar chart? Why is there a difference?
</div>

В гистограмме переменная `x` должна быть числовой, а `stat_bin()` группирует наблюдения по диапазонам в ячейки. Поскольку числовое значение наблюдений `NA` неизвестно, они не могут быть помещены в конкретный столбец и отбрасываются.

```{r}
ggplot(diamonds2, aes(y)) +
  geom_histogram(na.rm = TRUE, binwidth = 0.1)
```

В функции `geom_bar()` отсутствующие значения `NA` рассматриваются как другая категория. Аргумент `aes(x)` в `geom_bar()` требует дискретной (категориальной) переменной, а отсутствующие значения действуют как другая категория.

```{r}
diamonds2 %>%
  ggplot() +
  geom_bar(aes(y))
```

Пример лучше иллюстрирующий сказанное:

```{r}
diamonds %>%
  mutate(cut = if_else(runif(n()) < 0.1, NA_character_, as.character(cut))) %>%
  ggplot() +
  geom_bar(mapping = aes(x = cut))
```


#### Упражнение 7.3.5.2
<div class="question">
What does `na.rm = TRUE` do in `mean()` and `sum()`?
</div>

Аргумент `na.rm = TRUE` в функциях `mean()` и `sum()`, позволяет производить подсчёт не взирая на отсутствующие значения.

```{r}
x <- c(1, 3, 5, 7, 9, NA)
sum(x, na.rm = FALSE)
```

```{r}
x <- c(1, 3, 5, 7, 9, NA)
sum(x, na.rm = TRUE)
```
### Ковариация

Ковариация --- это тенденция к взаимосвязанному изменению значений двух и более переменных. И конечно лучший способ отследить ковариацию --- визуализирвоать переменные.

#### Категориальные и непрерывные переменные

При большом разбросе значений, мелкие интересности на фоне больших значений сложно разглядеть. Рассмотрим в качестве примера, как изменяется цена бриллиантов в зависимости от их качества.

```{r}
ggplot(diamonds, aes(price)) +
  geom_freqpoly(aes(color = cut), binwidth = 500)
```

Увидеть различия в распределении трудно, ввиду больших различий в размерах групп

```{r}
ggplot(diamonds) +
  geom_bar(aes(cut))
```

Чтобы облегчить сравнение распределений, необходимо поменять переменную отображаемую по оси `y`. Для этого воспользуемся стандартизированной количественной характеристикой --- плотностью.

```{r}
ggplot(diamonds, aes(x = price, y = ..density..)) +
  geom_freqpoly(aes(color = cut), binwidth = 500)
```

И наконец, мы дошли до ящиков с усами. Диаграммы размаха удобно использовать для визуальной экспресс оценки. Напомню что такое ящик с усами

![alt text](img/boxplot.png)
Рассмотрим распределение цены `price`в замивсимости от качества огранки `cut`, используя функцию `geom_boxplot()`

```{r}
ggplot(diamonds, aes(cut, price)) +
  geom_boxplot()
```

Ящики позволяют сравнивать между собой распределения. Очень удачно, что в текущем примере с бриллиантами все классы качества упорядочены по возрастанию качества от `Fair` удовлетворительного до `Ideal` идеального. Конечно же не всегда данные так упорядочены, и для того чтобы удобнее и логичнее выстравить построения можно использовать функцию `reorder()`. 

Рассмотрим например переменную `class`из набора данных про автомобили. Предположим, мы хотим выяснить как меняется показатель расхода топлива `hwy` в зависимости от класса автомобиля `class`

```{r}
ggplot(mpg, aes(class, hwy)) +
  geom_boxplot()
```

чтобы сделать тренд более наглядным, переставим значения класса, основываясь на медиане значений `hwy`

```{r}
ggplot(mpg) +
  geom_boxplot(
   mapping = aes(
     x = reorder(class, hwy, FUN = median), # меняем местами переменные, по возрастанию медианы
     y = hwy)) +
  coord_flip()                              # поворачиваем на 90 градусов, чтобы поместились надписи
```

#### Упражнение 7.5.1.1.1
<div class="question">
Use what you’ve learned to improve the visualisation of the departure times of cancelled vs. non-cancelled flights.
</div>

Используем построение ящиками с усами, для того чтобы сделать визуализацию нагляднее

```{r}
flights %>%
  mutate(canceled = is.na(dep_time),  # Добавляем категориальную переменную, FALSE соответствует отменённым рейсам
         sched_dep_time_minute = ((sched_dep_time %/% 100) * 60) + sched_dep_time %% 100) %>% # Переводим представление даты
ggplot() +
  geom_boxplot(mapping = aes(x = canceled, y = sched_dep_time_minute))  # Строим ящик с усами
```

#### Упражнение 7.5.1.1.2
<div class="question">
What variable in the `diamonds` dataset is most important for predicting the price of a diamond? How is that variable correlated with `cut`? Why does the combination of those two relationships lead to lower quality diamonds being more expensive?
</div>

Хорошо, что в наборе данных `diaminds` не так много переменных, и все их можно проверить --- это займет не так много времени на первый взгляд. Но будем действовать разумнее и отсечём менее информативные показатели. На мой взгляд, с ценой должен хорошо коррелировать параметр `carat` --- это вес алмаза. Так как вес определяется размерами (и ещё плотностью, которой у нас нет), то параметры относящиеся к размеру мы отсекаем. Собственно после этого останется --- `cut`, `color`, `clarity`. В итоге четыре параметра для проверки. Начнем с веса.

Обе переменные `carat` и `price` непрерывные, для визуализации зависимости нужно будет немного исхитриться. Но для начала покажем на диграмме рассеяния зависимость цены от веса:

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_point()
```

Как видно с увеличением веса, по какой-то зависимости происходит и увеличение цены, значит мы в верном направлении. Осталось, для визуализации преобразовать непрерывные данные в категориальные. В этом нам поможет аргумент `cut_width()` --- который разрезат весь интервал на участки. Об этом как раз говорилось в начале главы.

```{r}
ggplot(data = diamonds, mapping = aes(x = carat, y = price)) +
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.2)))
```

Этот график нагляднее показывает скорость роста цены от веса бриллианта. От группе к группе --- медиана увеличивается, с некоторыми провалами в райое 3.0-3.5 карат. Посмотрим что с другими выбранными для анализа переменными

```{r}
ggplot(diamonds, aes(color, price)) +
  geom_boxplot()
```

Видно что есть некоторый рост цены с изменением цвета от D к J, однако он не такой существенный как рост цены от веса. Посмотрим как изменяется цена в зависимости чистоты бриллианта

```{r}
ggplot(diamonds, aes(clarity, price)) +
  geom_boxplot()
```

Ясность вообще выглядит удивительно --- чем прозрачнее степень бриллианта, тем меньше его средняя цена. Это контринтуитивно, но вероятно этому есть логическое объяснение. В поиски логического объяснения я пока уходить не буду, потому что изменение цены от ясности не такое большое как от веса бриллианта. Поэтому я остановлю свой выбор среди представленных переменных, для лучшего предсказания цены бриллианта на переменной `carat`. 

Теперь посмотрим как `carat` зависит от `cut`.

```{r}
ggplot(diamonds, aes(cut, carat)) +
  geom_boxplot()
```

Наблюдается небольшая обратная зависимость --- при улучшении качества огранки, немного изменяется цена. Примечательно, что самые большие бриллианты имеют плохую огранку. Это может быть связано с тем, что большие бриллианты это самородки. Маленьким бриллиантам нужно уделить больше внимания, чтобы они выглядели более презентабельно при продаже.

#### Упражнение 7.5.1.1.3
<div class="question">
Install the `ggstance` package, and create a horizontal boxplot. How does this compare to using `coord_flip()`?
</div>

Ранее мы использовали поворот системы координат в примере с визуализацией расхода топлива от класса автомобиля.
```{r}
ggplot(mpg) +
  geom_boxplot(aes(x = reorder(class, hwy, FUN = median), 
                   y = hwy)) +
  coord_flip()
```

Для того что сделать горизонтальную диаграмму размаха через функции пакета `ggstance`, необходимо подключить его и воспользоваться функцией `geom_boxploth()`. 

```{r}
library("ggstance")
ggplot(mpg) +
  geom_boxploth(aes(x = reorder(class, hwy, FUN = median),
                    y = hwy))
```

Похоже, что эта функция специально предназначена для построения горизонтальных диаграмм размахов (ящиков с усами).
```{r}
ggplot(mpg) +
  geom_boxploth(aes(y = reorder(class, hwy, FUN = median),
                    x = hwy))
```

#### Упражнение 7.5.1.1.4
<div class="question">
One problem with box plots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of “outlying values”. One approach to remedy this problem is the letter value plot. Install the `lvplot` package, and try using `geom_lv()` to display the distribution of `price` vs `cut`. What do you learn?

How do you interpret the plots?
</div>

Ух ты, много раз задумывался о том, что ящики это что-то старенькое, и на них ну уж очень много данных попадает порой в область выбросов. Оказывается это так и есть. Устанавливаем пакет и подключаем библиотеку

```{r}
library("lvplot")

ggplot(diamonds, aes(x = cut, y = price)) +
  geom_lv(aes(fill=..LV..))
```

[В статье](https://vita.had.co.nz/papers/letter-value-plot.pdf) объясняются преимущества Side-by-side LV boxplots, а так же показаны примеры и сравнения. Здесь объяснений приводить не буду, ограничусь тем, что скажу что новый вид диаграмм более информативен посравнению с ящиками с усами Джона Тьюки.

#### Упражнение 7.5.1.1.5
<div class="question">
Compare and contrast `geom_violin()` with a faceted `geom_histogram()`, or a colored `geom_freqpoly()`. What are the pros and cons of each method?
</div>

С построением `geom_freqpoly()` я уже знаком --- его основное преимущество это возможность построить на одном графике разными линиями несколько категориальных переменных. При этом можно бегло оценить их распределение и поверхностно сравнить. Основным недостатком является тот факт, что при большой дисперсии выборок, хотя бы в одной переменной, сравнивать более мелкие ковариации становится затруднительно, нужно либо изменять масштаб, либо отбрасывать данные вокруг рассматриваемого участка.
```{r}
ggplot(diamonds,aes(price, ..density..)) +
  geom_freqpoly(mapping = aes(color = cut), binwidth = 500)
```

Гистограммы в панелях тоже интересное решение, когда нужно сравнить распределение и возможные ковариации нескольких переменных. В этом варианте несколько попроще разгядеть зависимости
```{r}
ggplot(diamonds, aes(x = price)) +
  geom_histogram() +
  facet_wrap(~ cut, ncol = 1)
```

Однако и в этом случае, если встречаются разномасштабные данные, для лучшей визуализации необходимо "поиграться" с масштабом. Для этого устанавливается независимый масштаб у переменных

```{r}
ggplot(diamonds, aes(x = price)) +
  geom_histogram() +
  facet_wrap(~ cut, ncol = 1, scales = "free_y")
```

Теперь попробуем построить скрипичный график.
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
  geom_violin()
```

Скрипичный график представляет собой компактную визуализацию непрерывного распределения. [Подробнее о построении скрипичного графика](http://www.stat.cmu.edu/~rnugent/PCMI2016/papers/ViolinPlots.pdf)

#### Упражнение 7.5.1.1.6
<div class="question">
If you have a small dataset, it’s sometimes useful to use `geom_jitter()` to see the relationship between a continuous and categorical variable. The ggbeeswarm package provides a number of methods similar to geom_jitter(). List them and briefly describe what each one does.
</div>

В описании встретилось два метода 

* `geom_quasirandom()` создает графики, которые представляют собой смесь джиттера и скрипки. Существует несколько разных методов, которые точно определяют, как генерируется случайное расположение точек.

* `geom_beeswarm()` создает построение, подобное построению скрипки, но компенсируя точки.

Вспомним построение язиков для визуализации расхода топлива в зависимости от класса автомобиля

```{r}
ggplot(mpg) +
  geom_boxplot(aes(x = reorder(class, hwy, FUN = median), 
                   y = hwy))
```

Теперь построим квазирандомом

```{r}
library("ggbeeswarm")
ggplot(mpg) +
  geom_quasirandom(aes(x = reorder(class, hwy, FUN = median),
                                 y = hwy))
```

Эта визуализация похожа на ящики с усами, но по количеству и плотности точек можно нагляднее представить характер распределения.
У этого построения есть несколько методов задания распределения рандомности точек.

```{r}
ggplot(mpg) +
  geom_quasirandom(aes(x = reorder(class, hwy, FUN = median),
                                 y = hwy),
                   method = "frowney")
```

```{r}
ggplot(mpg) +
  geom_quasirandom(aes(x = reorder(class, hwy, FUN = median),
                                 y = hwy),
                   method = "smiley")
```

Но перейдём теперь к `geom_beeswarm()`

```{r}
ggplot(mpg) +
  geom_beeswarm(aes(x = reorder(class, hwy, FUN = median),
                                 y = hwy))
```

В принципе у него тоже есть некий алгоритм рандомности, но в общих чертах выглядит похоже на предыдущие построения. У него плотность точек побольше.

#### Две категориальные переменные

Порой необходимо проверить как между собой связаны две категориальные переменные. Например когда необходимо установить, какая пара категориальных переменных чаще всего встречается. Для этого можно воспользоваться несколькими способами.

* Посчитать количество точек попавших в каждую пару внутренней функцией пакета

```{r}
ggplot(diamonds) +
  geom_count(aes(cut, color))
```

* Посчитать через `dplyr`

```{r}
diamonds %>% 
  count(color, cut)
```

и затем визуализировать

```{r}
diamonds %>% 
  count(color, cut) %>%  
  ggplot(mapping = aes(x = color, y = cut)) +
    geom_tile(mapping = aes(fill = n)) +
  coord_flip()
```

#### Упражнение 7.5.2.1.1
<div class="question">
How could you rescale the `count` dataset above to more clearly show the distribution of `cut` within `colour`, or `colour` within `cut`?
</div>

Сгруппируем по отдельности, сначала по цвету, потом по степени огранки и в каждом случае введём переменную вычисляющую пропорцию. Для того чтобы можно было сравнить в одних условиях.

```{r}
diamonds %>%
  count(color, cut) %>%                        # Считаем количество значений в парах
  group_by(color) %>%                          # Группирупм по цвету
  mutate(prop = n / sum(n)) %>%                # Добавляем переменную, в которой вычисляем пропорцию
  ggplot(aes(color, cut)) +
  geom_tile(aes(fill = prop))                  # Делаем заливку введённой переменной
```

Теперь проделаем всё тоже самое, но с группировкой по `cut`

```{r}
diamonds %>%
  count(color, cut) %>%
  group_by(cut) %>%
  mutate(prop = n / sum(n)) %>%
  ggplot(aes(color, cut)) +
  geom_tile(aes(fill = prop))
```

Группировка по цвету имеет более упорядоченный вид.

#### Упражнение 7.5.2.1.2
<div class="question">
Use `geom_tile()` together with `dplyr` to explore how average flight delays vary by destination and month of year. What makes the plot difficult to read? How could you improve it?
</div>

Итак, сначала построим распределение средней задержки в разрезе двух категориальных переменных  месяца отправки и направлению вылета.

```{r}
flights %>%
  group_by(month, dest) %>%                           # Группируем по месяцу и направлению
  summarise(mean = mean(dep_delay, na.rm = TRUE)) %>% # Вводим новую переменную, в которой считаем среднее время задержки в группах
  ggplot(aes(month, dest)) +
  geom_tile(aes(fill = mean)) +                       # Строим диаграмму распределения с заливкой по среднему значению
  labs(x = "Mесяц", y = "Направление", fill = "Задержка отправления")
```

Затрудняет чтение диаграммы отсутствие месяцев. Чтобы представить месяцы в более привычной форме нужно использовать функцию `factor()`, я пока не знаю как она работает. Но она помогла.

```{r}
flights %>%
  group_by(month, dest) %>%                           
  summarise(mean = mean(dep_delay, na.rm = TRUE)) %>% 
  ggplot(aes(factor(month), dest)) +
  geom_tile(aes(fill = mean)) +
  labs(x = "Mесяц", y = "Направление", fill = "Задержка отправления")
```

Мешают отсутсвующие значения. Удалим их. 

С этим пришлось повозиться, и сделать необычную конструкцию.
Её суть заключается в том, чтобы отображать на графике только те направления, по которым летали заданное количество месяцев. Нам интересно видеть круглогодично заполненные аэропорты, поэтому зададим количество месяцев равным 12.


```{r}
flights %>%
  group_by(month, dest) %>%                           
  summarise(mean = mean(dep_delay, na.rm = TRUE)) %>% 
  group_by(dest) %>%
  filter(n() == 12) %>%
  
  ggplot(aes(factor(month), dest)) +
  geom_tile(aes(fill = mean)) +
  labs(x = "Mесяц", y = "Направление", fill = "Задержка отправления")
```

Затрудняет алфавитный порядок, поскольку при беглом анализе несколько теряется информативность. Можно сортировать направление вылета не по алфавиту, а по какому-нибудь значимому параметру, например по среднему количеству полётов в году, или по средней задержки. Для того чтобы отсортировать переменную `dest` необходимо воспользоваться функцией `reorder()`. Эта функция«по умолчанию» рассматривает свой первый аргумент как категориальную переменную и переупорядочивает его уровни на основе значений второй переменной, обычно числовой, в нашем случае это будет среднегодовое время задержки вылета.

```{r}
flights %>%
  group_by(month, dest) %>%                           
  summarise(mean = mean(dep_delay, na.rm = TRUE)) %>% 
  group_by(dest) %>%
  filter(n() == 12) %>%
  ungroup() %>%
  mutate(dest = reorder(dest, mean)) %>%
  
  ggplot(aes(factor(month), dest)) +
  geom_tile(aes(fill = mean)) + 
  labs(x = "Mесяц", y = "Направление", fill = "Задержка отправления")
```

#### Упражнение 7.5.2.1.2
<div class="question">
Why is it slightly better to use `aes(x = color, y = cut)` rather than `aes(x = cut, y = color)` in the example above?
</div>

Всё просто. Ответ лежит в плоскости листа, точнее его ориентации. Дело в том, что чем больше переменных тем хуже воспринимается альбомная ориентация, поэтому рекомендуется параметр с большим количеством переменных распологать по оси абсцис. Не совсем удачно для этой задачи выбран пример, поскольку имена переменных прекрасно укладываются по обеим осям.

```{r}
diamonds %>%
  count(color, cut) %>%  
  ggplot(mapping = aes(y = color, x = cut)) +
    geom_tile(mapping = aes(fill = n))
```

```{r}
diamonds %>%
  count(color, cut) %>%  
  ggplot(mapping = aes(y = cut, x = color)) +
    geom_tile(mapping = aes(fill = n))
```

Однако эту ситуацию идеально иллюстрируют предыдущее упражнение, если поменять оси местами, то совершенно невозомжно будет различить какие где аэропорты:

```{r}
flights %>%
  group_by(month, dest) %>%                           
  summarise(mean = mean(dep_delay, na.rm = TRUE)) %>% 
  group_by(dest) %>%
  filter(n() == 12) %>%
  ungroup() %>%
  mutate(dest = reorder(dest, mean)) %>%
  
  ggplot(aes(factor(month), dest)) +
  geom_tile(aes(fill = mean)) + 
  labs(x = "Mесяц", y = "Направление", fill = "Задержка отправления") +
  coord_flip()
```

#### Две непрерывные переменные

С одним из способов визуализации двух непрерывных переменных я уже знаком. Это точечная диаграмма рассеяния.

```{r}
ggplot(diamonds) +
  geom_point(aes(carat, price))
```

Даже при таком построении просматривается экспоненциальный характер связи. Однако большое скопление точек затрудняет восприятие. Частично эту ситуацию может решит введение уже знакомой мне прозрачности

```{r}
ggplot(diamonds) +
  geom_point(aes(carat, price), 
             alpha = 0.01)
```

Однако это не панацея. Чуть более полезное решение --- использование карманов (интервалов значений). Так называем карманы создаются с помощью функций `geom_bin2d()` и `geom_hex()`. Для использования последней необходимо установить пакет `hexbin`. 

```{r}
#install.packages("hexbin")
ggplot(diamonds) +
  geom_bin2d(aes(carat, price))
```

```{r}
ggplot(smaller) +
  geom_hex(aes(carat, price))
```

Это красиво. Но есть старые добрые методы от Тьюки --- ящики с усами. 

```{r}
ggplot(smaller, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.1)))
```

Однако ящики с усами имеют один и тот же внешний вид, за исключением количества выбросов, независимо от количества наблюдений, которым они соответствуют. ПОэтому судить о том , какое количество наблюдений просуммировано в каждом кармане очень трудно. ОДин из способов сделать это возможным заключается в использовании карманов, ширина которых пропорциональна количеству точек данных `varwidth = TRUE`

```{r}
ggplot(smaller, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.1)),
               varwidth = TRUE)
```

Не очень наглядно, но говорят иногда выручает. Ещё один способ, заключается в том, чтобы отражать примерно одно и то же количество точек в каждом кармане. Это делается с помощью функции `cut_number()`

```{r}
ggplot(smaller, aes(carat, price)) +
  geom_boxplot(aes(group = cut_number(carat, 20)))
```

#### Упражнение 7.5.3.1.1
<div class="question">
Instead of summarizing the conditional distribution with a box plot, you could use a frequency polygon. What do you need to consider when using `cut_width()` vs `cut_number()`? How does that impact a visualization of the 2d distribution of `carat` and `price`?
</div>

Принимая решение о том какую из функций использовать, необходимо учитывать следующие факторы

* При использовании `cut_width()` необходимо указать ширину просматриваемого диапазона. 

* При использовании `cut_number()` необходимо указать количество ящиков, которое необходимо построить. 

#### Упражнение 7.5.3.1.2
<div class="question">
Visualize the distribution of `carat`, partitioned by `price`.
</div>

Как я понял это задание --- нужно сгруппировать данные в ящиках по переменной `price`. Это означает, что нужно указать группировку либо по количеству ящиков, которые будем строить, т.е.`cut_number()`. Сначала я построил вот такое распределение.

```{r}
ggplot(diamonds, aes(price, carat)) +
  geom_boxplot(aes(group = cut_number(price, 10))) +
  coord_flip()
```

Здесь построено 10 ящиков сгруппированных по переменной `price`, с примерно одним количеством точек в кармане или диапазоне. В принципе подобное же решение но с группировкой по переменной `carat` приведена в учебнике. Меня смущает здесь тот факт, что столбцы ящиков с усами имеют разную ширину хотя они и показывают количество точек попавших в карман. Чтобы построить ящики равной ширины и при этом отобразить количество точек попавших в наблюдение, можно убрать группировку при построении оставив только функцию `cut_number`

```{r}
ggplot(diamonds, aes(cut_number(price, 10), carat)) +
  geom_boxplot() +
  coord_flip()
```

Как видно такое построение не повлияло на характер распределения, однако сделало визуализацию чуть более аккуратной. Такой подход ситуативен, потому что повторюсь --- первый вариант даёт наглядное представление о количестве точек, попавших в карман.

#### Упражнение 7.5.3.1.3
<div class="question">
How does the `price` distribution of very large diamonds compare to small diamonds. Is it as you expect, or does it surprise you?
</div>

```{r}
ggplot(smaller, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.1)),
               varwidth = TRUE)
```

Как видно из распределения более тяжёлые бриллианты имеют больший межквартильный размах, это говорит о том, что плотность данных не высокая и в нутри выборки в пределах одного веса происходят большие флуктуации --- начиная с веса в один карат и выше, размах составляет от 5000 долларов за единицу веса. При этом чем меньше вес бриллианта, тем большая плотность цены у бриллиантов. 

По началу меня это удивило. Но если брать в расчёт ранее полученную информацию о прозрачности и цвете бриллиантов, то становится ясно, что чем меньше бриллиант, тем идеальнее он должен быть, чтобы его продать. Большой самородок проще продать, даже если он имеют не идеальные цвет, качество огранки и прозрачность.

#### Упражнение 7.5.3.1.4
<div class="question">
Combine two of the techniques you’ve learned to visualize the combined distribution of `cut`, `carat`, and `price`.
</div>

Попробуем несколько способов визуализации указанных переменных. Один из первых --- это объединение панелями.

Уже на этом этапе понятно, что интерпритируемость некоторых вариантов значительно хуже других.

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.5))) +
  facet_wrap(~ cut, nrow = 2)
```

Построение в панелях ящиков с усами, даёт некоторое представление о взаимном распределении переменных, однако на сравнение необходимо затратить некоторое время. Чуть более интересную визуализацию панелями даёт построение шестигранных диаграмм

```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_hex() +
  facet_wrap(~ cut, nrow = 2)
```

Следующий способ --- построить ящики с усами, разбить просматриваемый диапазон на равное количество карманов, и в каждом диапазоне разбить один ящик на несколько, согласно категориальной переменной. Так как категориальная переменная одна `cut`, то в зависимости от того, распределение какой переменной мы хотим изучить, будем создавать карманы либо по весу

```{r}
ggplot(diamonds, aes(x = cut_number(carat, 6), y = price)) +
  geom_boxplot(aes(color = cut)) +
  xlab("carat")
```

Либо по цене

```{r}
ggplot(diamonds, aes(x = cut_number(price, 6), y = carat)) +
  geom_boxplot(aes(color = cut)) +
  coord_flip() +
  xlab("price")
```

#### Упражнение 7.5.3.1.5
<div class="question">
Two dimensional plots reveal outliers that are not visible in one dimensional plots. For example, some points in the plot below have an unusual combination of `x` and `y` values, which makes the points outliers even though their `x` and `y` values appear normal when examined separately.
</div>

Почему в данном случае легче заметить необычные точки на диаграмме рассеяния, чем на диаграмме использующей карманы.

```{r}
ggplot(diamonds) +
  geom_point(aes(x = x, y = y)) +
  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))
```

Потому что при построении ящиков или диаграмм с карманами, интересующие нас точки попадая в карман могут во-первых наклыдваться друг на друга. 

```{r}
ggplot(diamonds) +
  geom_boxplot(mapping = aes(x = cut_number(x, 10), y = y)) + 
   coord_cartesian(xlim = c(3, 11), ylim = c(4, 11))
```

### Шаблоны поведения переменных и модели

Если в поведении двух перменных наблюдается систематическая закономерность, то это может свидетельствовать о наличии устойчивой связи между данными. Как только я замечаю какую-либо закономерность, мне следует задать себе примерно такие вопросы:

* Может ли эта закономерность быть лишь кажущейся, другими словами --- не обусловлена ли она случайным совпадением?

* Как можно описать отношение между переменными, которое следует из наблюдаемой закономерности?

* Насколько сильна связь между переменными, которую можно предпологать, исходя из наблюдаемой закономерности?

* Какие другие пременные могут оказывать влияние на отношение между данными переменными?

* Изменяется ли это отношение при переходе к рассмотрению отдельных подгрупп данных?

Возьмём к примеру, извержения гейзера.

```{r}
ggplot(faithful) +
  geom_point(aes(eruptions, waiting))
```

Видно, что чем больше задержка перед извержением, тем дольше длится это извержение. Кроме этого, на графике отчётличво просматриваются два кластера. 

* Вариация --- явление, создающее неопредлённость.

* Ковариация --- это явление, уменьшающее неопрделённость.

Если между переменными существует ковариация, то значения одной переменной могут быть использованы для предсказания или улучшения предсказания другой переменной. Есть особые случаи --- когда ковариация обсуловлена причинно-следственной связью, тогда значения одной пременной могут быть испрльзованы для управления значениями другой переменной.

Модели --- это инструмент используемый для выявления закономерностей в поведении данных. Вернёмся снова к бриллиантам.

Понять природу отношения между переменными `cut`, `carat`, `price` не легко потому что они тесно связаны между собой.
МОжно использовать модель, которая исключает влияегие очень сильной связи между переменными `carat` и `price` и тем самым предоставляет возможность ислледовать более тонкие детали.

Приведённый ниже код соответствует модели, которая предсказывает ЦЕНУ по ВЕСУ, а затем вычисляет остатки (то есть разницу между предсказанием и фактическим значением). Остатки дают представление о цене бриллиантов после исключения из неё влияния веса.

```{r}
library(modelr)

mod <- lm(log(price) ~ log(carat), data = diamonds)

diamonds2 <- diamonds %>%
  add_residuals(mod) %>%
  mutate(resid = exp(resid))
  
ggplot(diamonds2) +
  geom_point(aes(carat, resid))
```

О том как работает этот код мы узнаем позже, пока важно ухватить суть --- исключив влияние сильной взаимосвязи переменных `carat` и `price` мы видим, что соотношение между переменными `cut` и `price` соответствует ожидаемому. Для алмазов сравнимого размера, более высокому качеству соответствует более высокая цена.

Данные без применения модели
```{r}
ggplot(diamonds) +
  geom_boxplot(aes(cut, price))
```


Данные, полсе применения модели

```{r}
ggplot(diamonds2) +
  geom_boxplot(aes(cut, resid))
```

### Вызов функций `ggplot`

В этой главе рассказано, что у некоторых функций есть короткая запись.
К моменту прочтения этой главы, я уже догадался об этом и использовал ранее в решениях.

### Дополнительная информация

Несколько хороших книг по пройденному материалу

* [Graphical Data Analysis with R (Chapman & Hall/CRC The R Series)](https://www.amazon.com/dp/1498715230/ref=cm_sw_su_dp)

* [R Graphics Cookbook](https://www.amazon.com/dp/1449316956/ref=cm_sw_su_dp)

* [ggplot2: Elegant Graphics for Data Analysis (Use R!)](https://www.amazon.com/dp/331924275X/ref=cm_sw_su_dp)

