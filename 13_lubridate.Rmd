---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Работа с датами и временем с помощью пакета `lubridate`

### Введение

Вhемя не так просто как может показаться. Всему своё время, и в этой главе мы наловчимся обрабатывать время.

#### Используемые ресурсы

```{r}
library(tidyverse)
library(lubridate)
library(nycflights13)
```

### Создание перменных описывающих дату и время

Существует три типа данных ссылающихся на момент времени

* дата --- календарная дата, tibble выводит это как `<date>`

* время --- время суток, tibble выводит это как `<time>`

* дата/время --- дата время, в tibble выводится как `<dttm>`

Для получения текущей даты можно использовать

```{r}
today()
now()
```

Существует три способа создания данных в формате даты/времени.
Рассмотрим их более подробно

#### Создание значений даты/времени на основе строк

МОжно распарсить дату время при помощи средств пакета `readr`, это описано в главе 8.
МОжно встроенными инструментами пакета `lubridate`, для этошо есть семейство функций, которые по факту осуществляют парсинг входных данных и выводят данные в формате даты времени

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

Главное в верном порядке расставить буквы, означающие год-месяц-день.
Можно так же через нижнее подчеркивание задавать время

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

#### Создание значений даты/времени на основе отдельных компонентов

Иногда вместо отдельной строки, в распоряжении будет отдельный компонент, предоставленный в нескольких столбцах.

```{r}
flights %>% 
  select(year, month, day, hour, minute)
```

Для таких случаев есть функции `make_date()` и `make_datetime()`
```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Сделаем тоже самое для таблиц `flights` связанные со временем.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Используя эти данные мы можем визуализировать распределение времени вылета на протяжении года

```{r}
flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

Или на протяжении одного дня 

```{r}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

При построении значений даты/времени в числовом контексте, как в случае гистограммы, 1 означает одну секунду, поэтому значению параметра `binwidth` равному 86400 соответствует один день. Для дат значению 1 соответствует один день

#### Создание значений даты/времени на основе других типов

Может возникнуть необходимость в переходе между  значениями даты/времени и даты. 
Это работа функций `as_datetime()` и `as_date()`

```{r}
as_datetime(today())
as_date(now())
```


#### Упражнение 16.2.4.1
<div class="question">
What happens if you parse a string that contains invalid dates?

```{r}
print(class(ymd(c("2010-10-10", "bananas"))))
```
</div>

Функция создает NA и предупреждающее сообщение.

#### Упражнение 16.2.4.2
<div class="question">
What does the `tzone` argument to today() do? Why is it important?
</div>

Часовой пояс.
Он определяет часовой пояс даты.
Поскольку разные часовые пояса могут иметь разные даты, значение `today()` может варьироваться в зависимости от указанного часового пояса.

#### Упражнение 16.2.4.3
<div class="question">
Use the appropriate lubridate function to parse each of the following dates:

```{r}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
```
</div>

```{r}
mdy(d1)
ymd(d2)
dmy(d3)
mdy(d4)
mdy(d5)
```

### Компоненты даты/времени

В этом разделе наше внимание будет сосредоточено на функциях доступа, позволяющих получать и устанавливать значения отдельных компонентов. 

#### Получение компонентов

Для извлечения отдельных компонентов предназначены функции

`year()`, 
`month()`,
`mday()` (day of the month),
`yday()` (day of the year),
`wday()` (day of the week),
`hour()`, 
`minute()`, 
`second()`

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
```

Можно передать функция аргумент `label = TRUE` чтобы получить сокращенное название месяца или дня недели. ЧТобы получить полное нзвание, задайте аргумент `abbr = FALSE`

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Мы можем использовать функцию `wday()` для того чтобы убедится, что количество вылетов на протяжении недели больше чем в выходные дни

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

В поведении среднего времени задержки вылета в зависимости от минуты часа наблюдается любопытная закономерность.
Похоже, что для авиарейсов, вылетающих в минутные интервалы часа 20-30 и 50-60, задержки намного меньше, чем для остальных временных промежутков.

```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

Интересно, что если взглянуть на время вылета по расписанию, то никакой ярко выраженной закономерности не наблюдается

```{r}
sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()
```

Так почему же нам удается наблюдать закономерность, в фактическом времени вылета? Подобно многим другим данным, подготовленным людьми, здесь наблюдаеися отчетливое смещение в сторону авиарейсов, отправляющихся в круглое время. Работая с данными, подверженными влиянию человеческих суждений, всегда надо быть настороже!

```{r}
ggplot(sched_dep, aes(minute, n)) +
  geom_line()
```

#### Округление

Альтернативный подход к построению графиков отдельных компонент --- округление даты до ближайшей единицы времени с помощью функций 
`floor_date()`, `round_date()`, `ceiling_date()`. Каждая из этих функций принимает вектор дат, подлежащих округлению и название единицы, до которой должно выполняться округление вниз `floor`, округление вверх `ceiling`, или до ближайшего значения `round`. Это например, позволяет построить график количества авиарейсов в неделю.

```{r}
flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()
```

Особенно полезно может быть вычсиление разницы между округленной и неокруглённой датой.

#### Задание значений компонентов

Функции доступа так же позволяет устанавливать значения компонентов даты/времени. 

```{r}
(datetime <- ymd_hms("2016-07-08 12:34:56"))

year(datetime) <- 2020
datetime

month(datetime) <- 01
datetime

hour(datetime) <- hour(datetime) + 1
datetime
```

Альтернативный вариант позволяет не изменять значения на месте, а создавать новые значения с помощью функции `update()`. Кроме того можно устанавливать одновременно несколько значений.

```{r}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```

Если значения слишком велики, они "закольцовываются"

```{r}
ymd("2015-02-01") %>% 
  update(mday = 30)

ymd("2015-02-01") %>% 
  update(hour = 400)
```

Функцию `update()` можно использовать для того, чтобы отобразить распределение авиарейсов на протяжении дня для каждого дня в году

```{r}
flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)
```

Задание для более крупных компонентов даты постоянного значения --- удобная методика, позволяющая исследовать закономерности, связанные с меньшими компонентами.

