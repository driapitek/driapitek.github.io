---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Работа с датами и временем с помощью пакета `lubridate`

### Введение

Вhемя не так просто как может показаться. Всему своё время, и в этой главе мы наловчимся обрабатывать время.

#### Используемые ресурсы

```{r}
library(tidyverse)
library(lubridate)
library(nycflights13)
```

### Создание перменных описывающих дату и время

Существует три типа данных ссылающихся на момент времени

* дата --- календарная дата, tibble выводит это как `<date>`

* время --- время суток, tibble выводит это как `<time>`

* дата/время --- дата время, в tibble выводится как `<dttm>`

Для получения текущей даты можно использовать

```{r}
today()
now()
```

Существует три способа создания данных в формате даты/времени.
Рассмотрим их более подробно

#### Создание значений даты/времени на основе строк

МОжно распарсить дату время при помощи средств пакета `readr`, это описано в главе 8.
МОжно встроенными инструментами пакета `lubridate`, для этошо есть семейство функций, которые по факту осуществляют парсинг входных данных и выводят данные в формате даты времени

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

Главное в верном порядке расставить буквы, означающие год-месяц-день.
Можно так же через нижнее подчеркивание задавать время

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

#### Создание значений даты/времени на основе отдельных компонентов

Иногда вместо отдельной строки, в распоряжении будет отдельный компонент, предоставленный в нескольких столбцах.

```{r}
flights %>% 
  select(year, month, day, hour, minute)
```

Для таких случаев есть функции `make_date()` и `make_datetime()`
```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Сделаем тоже самое для таблиц `flights` связанные со временем.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Используя эти данные мы можем визуализировать распределение времени вылета на протяжении года

```{r}
flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

Или на протяжении одного дня 

```{r}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

При построении значений даты/времени в числовом контексте, как в случае гистограммы, 1 означает одну секунду, поэтому значению параметра `binwidth` равному 86400 соответствует один день. Для дат значению 1 соответствует один день

#### Создание значений даты/времени на основе других типов

Может возникнуть необходимость в переходе между  значениями даты/времени и даты. 
Это работа функций `as_datetime()` и `as_date()`

```{r}
as_datetime(today())
as_date(now())
```


#### Упражнение 16.2.4.1
<div class="question">
What happens if you parse a string that contains invalid dates?

```{r}
print(class(ymd(c("2010-10-10", "bananas"))))
```
</div>

Функция создает NA и предупреждающее сообщение.

#### Упражнение 16.2.4.2
<div class="question">
What does the `tzone` argument to today() do? Why is it important?
</div>

Часовой пояс.
Он определяет часовой пояс даты.
Поскольку разные часовые пояса могут иметь разные даты, значение `today()` может варьироваться в зависимости от указанного часового пояса.

#### Упражнение 16.2.4.3
<div class="question">
Use the appropriate lubridate function to parse each of the following dates:

```{r}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
```
</div>

```{r}
mdy(d1)
ymd(d2)
dmy(d3)
mdy(d4)
mdy(d5)
```

### Компоненты даты/времени

В этом разделе наше внимание будет сосредоточено на функциях доступа, позволяющих получать и устанавливать значения отдельных компонентов. 

#### Получение компонентов

Для извлечения отдельных компонентов предназначены функции

`year()`, 
`month()`,
`mday()` (day of the month),
`yday()` (day of the year),
`wday()` (day of the week),
`hour()`, 
`minute()`, 
`second()`

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
```

Можно передать функция аргумент `label = TRUE` чтобы получить сокращенное название месяца или дня недели. ЧТобы получить полное нзвание, задайте аргумент `abbr = FALSE`

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Мы можем использовать функцию `wday()` для того чтобы убедится, что количество вылетов на протяжении недели больше чем в выходные дни

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

В поведении среднего времени задержки вылета в зависимости от минуты часа наблюдается любопытная закономерность.
Похоже, что для авиарейсов, вылетающих в минутные интервалы часа 20-30 и 50-60, задержки намного меньше, чем для остальных временных промежутков.

```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

Интересно, что если взглянуть на время вылета по расписанию, то никакой ярко выраженной закономерности не наблюдается

```{r}
sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()
```

Так почему же нам удается наблюдать закономерность, в фактическом времени вылета? Подобно многим другим данным, подготовленным людьми, здесь наблюдаеися отчетливое смещение в сторону авиарейсов, отправляющихся в круглое время. Работая с данными, подверженными влиянию человеческих суждений, всегда надо быть настороже!

```{r}
ggplot(sched_dep, aes(minute, n)) +
  geom_line()
```

#### Округление

Альтернативный подход к построению графиков отдельных компонент --- округление даты до ближайшей единицы времени с помощью функций 
`floor_date()`, `round_date()`, `ceiling_date()`. Каждая из этих функций принимает вектор дат, подлежащих округлению и название единицы, до которой должно выполняться округление вниз `floor`, округление вверх `ceiling`, или до ближайшего значения `round`. Это например, позволяет построить график количества авиарейсов в неделю.

```{r}
flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()
```

Особенно полезно может быть вычсиление разницы между округленной и неокруглённой датой.

#### Задание значений компонентов

Функции доступа так же позволяет устанавливать значения компонентов даты/времени. 

```{r}
(datetime <- ymd_hms("2016-07-08 12:34:56"))

year(datetime) <- 2020
datetime

month(datetime) <- 01
datetime

hour(datetime) <- hour(datetime) + 1
datetime
```

Альтернативный вариант позволяет не изменять значения на месте, а создавать новые значения с помощью функции `update()`. Кроме того можно устанавливать одновременно несколько значений.

```{r}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```

Если значения слишком велики, они "закольцовываются"

```{r}
ymd("2015-02-01") %>% 
  update(mday = 30)

ymd("2015-02-01") %>% 
  update(hour = 400)
```

Функцию `update()` можно использовать для того, чтобы отобразить распределение авиарейсов на протяжении дня для каждого дня в году

```{r}
flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)
```

Задание для более крупных компонентов даты постоянного значения --- удобная методика, позволяющая исследовать закономерности, связанные с меньшими компонентами.

#### Упражнение 16.3.4.1
<div class="question">
How does the distribution of flight times within a day change over the course of the year?
</div>

Давайте попробуем построить помесячный график.

```{r}
flights_dt %>%
  filter(!is.na(dep_time)) %>%
  mutate(dep_hour = update(dep_time, yday = 1),
         month = factor(month(dep_time))) %>% 
  ggplot(aes(dep_hour, color = month)) +
  geom_freqpoly(binwidth = 60 * 60)
```

Чтобы убрать отклонения заметные отклонения между месяцами из-за разного количества дней в месяце, нужно отнормировать построение

```{r}
flights_dt %>%
  filter(!is.na(dep_time)) %>%
  mutate(dep_hour = update(dep_time, yday = 1),
         month = factor(month(dep_time))) %>% 
  ggplot(aes(dep_hour, color = month)) +
  geom_freqpoly(aes(y = ..density..), binwidth = 60 * 60)
```

#### Упражнение 16.3.4.2
<div class="question">
Compare `dep_time`, `sched_dep_time` and `dep_delay`. Are they consistent? Explain your findings.
</div>


```{r}
flights_dt %>%
  mutate(residual = (dep_time - sched_dep_time) / 60) %>% 
  filter(residual != dep_delay) %>%
  select(residual, dep_time, sched_dep_time, dep_delay)
```

Существуют расхождения. 
Похоже, в данных есть ошибки. 
Это рейсы, в которых фактическое время отправления на следующий день относительно запланированного времени отправления. 
Мы забыли учесть это при создании даты и времени с помощью функции `make_datetime_100()` в 16.2.2 из отдельных компонентов.
Код должен был бы проверить, если время отправления меньше запланированного времени отправления плюс задержка отправления (в минутах). В качестве альтернативы, простое добавление задержки отправления к запланированному времени отправления является более надежным способом построения времени отправления, поскольку оно автоматически учитывает переход на следующий день.

#### Упражнение 16.3.4.3
<div class="question">
Compare `air_time` with the duration between the departure and arrival. 
Explain your findings. 
(Hint: consider the location of the airport.)
</div>

```{r}
flights_dt %>%
  mutate(residual = as.numeric(arr_time - dep_time),
         diff = residual - air_time) %>% 
  select(origin, dest, residual, air_time, diff, arr_time, dep_time) %>% 
  group_by(diff) %>%
  count(diff) %>%
  filter(!is.na(diff)) %>%
  ggplot(aes(diff, n)) +
  geom_jitter(alpha = 0.25, width = 0, height = 0.2) +
  scale_x_log10()
```

Большая часть точек лежит в области отклонения. Вероятно, это связано с переводом времени.


#### Упражнение 16.3.4.4
<div class="question">
How does the average delay time change over the course of a day? Should you use `dep_time` or `sched_dep_time`? Why?
</div>

Будем брать запланированное время вылета. 
Потому что это заявленная характеристика вылета, и на неё можно ореентироваться. 
КРоме того использование `dep_time` всегда смещает задержки на более поздний день. 
```{r}
flights_dt %>%
  mutate(sched_dep_hour = hour(sched_dep_time)) %>%
  group_by(sched_dep_hour) %>%View()
  summarise(dep_delay = mean(dep_delay)) %>% 
  ggplot(aes(y = dep_delay, x = sched_dep_hour)) +
  geom_point() +
  geom_smooth()
```

Как видно на графике,  самые большие задержки плавно возрастают в течении дня, и за пару часов до полуночи, немного спадают. При этом пик образуется в районе 19 часов.

#### Упражнение 16.3.4.5
<div class="question">
On what day of the week should you leave if you want to minimise the chance of a delay?
</div>

Чтобы ответить на этот вопрос, нужно посчитать среднее время задержки в каждом дне недели


```{r}
flights_dt %>% 
  mutate(wday = wday(sched_dep_time, label = TRUE)) %>%
  group_by(wday) %>%
  summarise(mean_wday_arr_delay = mean(arr_delay, na.rm = TRUE),
            mean_wday_dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(mean_wday_dep_delay, mean_wday_arr_delay)) +
    geom_point() +
    geom_text(aes(label = wday), vjust = 1, hjust = 1, check_overlap = TRUE) +
  labs(x = "Среднее время задержки вылета, минут",
       y = "Среднее время задержки прилёта, минут")
```

Очевидно, я бы выбрал для полёта субботу

#### Упражнение 16.3.4.6
<div class="question">
What makes the distribution of `diamonds$carat` and `flights$sched_dep_time` similar?
</div>

```{r}
ggplot(diamonds, aes(x = carat %% 1 * 100)) +
  geom_histogram(binwidth = 1)
```


```{r}
ggplot(flights_dt, aes(x = minute(sched_dep_time))) +
  geom_histogram(binwidth = 1)
```

И в `diamonds$carat`, и в `flights$sched_dep_time` есть аномально большие значения, которые находятся под хорошими «человеческими» числами. 
В `flights$sched_dep_time` это минуты 00 и 30 минут и кратные 0 и 5 минутам.

В `diamonds$carat` это в 0, 1/3, 1/2, 2/3.


#### Упражнение 16.3.4.7
<div class="question">
Confirm my hypothesis that the early departures of flights in minutes 20-30 and 50-60 are caused by scheduled flights that leave early. 
Hint: create a binary variable that tells you whether or not a flight was delayed
</div>


```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

На минутном уровне ничего не появляется:

```{r}
flights_dt %>%
  mutate(
    early = dep_delay < 0,
    minute = minute(sched_dep_time)
  ) %>% 
  group_by(minute) %>%
  summarise(early = mean(early)) %>% 
  ggplot(aes(x = minute, y = early)) +
  geom_point()
```

Но если сгруппировать с 10-минутными интервалами, то в эти минуты будет больше доля ранних рейсов.

```{r}
flights_dt %>%
  mutate(
    early = dep_delay < 0,
    minute = minute(sched_dep_time) %% 10
  ) %>%
  group_by(minute) %>%
  summarise(early = mean(early)) %>% 
  ggplot(aes(x = minute, y = early)) +
  geom_point()
```

