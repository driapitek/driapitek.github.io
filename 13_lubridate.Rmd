---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Работа с датами и временем с помощью пакета `lubridate`

### Введение

Время не так просто как может показаться. Всему своё время, и в этой главе мы наловчимся обрабатывать время.

#### Используемые ресурсы

```{r}
library(tidyverse)
library(lubridate)
library(nycflights13)
```

### Создание перменных описывающих дату и время

Существует три типа данных ссылающихся на момент времени

* дата --- календарная дата, tibble выводит это как `<date>`

* время --- время суток, tibble выводит это как `<time>`

* дата/время --- дата время, в tibble выводится как `<dttm>`

Для получения текущей даты можно использовать

```{r}
today()
now()
```

Существует три способа создания данных в формате даты/времени.
Рассмотрим их более подробно

#### Создание значений даты/времени на основе строк

МОжно распарсить дату время при помощи средств пакета `readr`, это описано в главе 8.
МОжно встроенными инструментами пакета `lubridate`, для этошо есть семейство функций, которые по факту осуществляют парсинг входных данных и выводят данные в формате даты времени

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

Главное в верном порядке расставить буквы, означающие год-месяц-день.
Можно так же через нижнее подчеркивание задавать время

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

#### Создание значений даты/времени на основе отдельных компонентов

Иногда вместо отдельной строки, в распоряжении будет отдельный компонент, предоставленный в нескольких столбцах.

```{r}
flights %>% 
  select(year, month, day, hour, minute)
```

Для таких случаев есть функции `make_date()` и `make_datetime()`
```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Сделаем тоже самое для таблиц `flights` связанные со временем.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Используя эти данные мы можем визуализировать распределение времени вылета на протяжении года

```{r}
flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day
```

Или на протяжении одного дня 

```{r}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

При построении значений даты/времени в числовом контексте, как в случае гистограммы, 1 означает одну секунду, поэтому значению параметра `binwidth` равному 86400 соответствует один день. Для дат значению 1 соответствует один день

#### Создание значений даты/времени на основе других типов

Может возникнуть необходимость в переходе между  значениями даты/времени и даты. 
Это работа функций `as_datetime()` и `as_date()`

```{r}
as_datetime(today())
as_date(now())
```


#### Упражнение 16.2.4.1
<div class="question">
What happens if you parse a string that contains invalid dates?

```{r}
print(class(ymd(c("2010-10-10", "bananas"))))
```
</div>

Функция создает NA и предупреждающее сообщение.

#### Упражнение 16.2.4.2
<div class="question">
What does the `tzone` argument to today() do? Why is it important?
</div>

Часовой пояс.
Он определяет часовой пояс даты.
Поскольку разные часовые пояса могут иметь разные даты, значение `today()` может варьироваться в зависимости от указанного часового пояса.

#### Упражнение 16.2.4.3
<div class="question">
Use the appropriate lubridate function to parse each of the following dates:

```{r}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
```
</div>

```{r}
mdy(d1)
ymd(d2)
dmy(d3)
mdy(d4)
mdy(d5)
```

### Компоненты даты/времени

В этом разделе наше внимание будет сосредоточено на функциях доступа, позволяющих получать и устанавливать значения отдельных компонентов. 

#### Получение компонентов

Для извлечения отдельных компонентов предназначены функции

`year()`, 
`month()`,
`mday()` (day of the month),
`yday()` (day of the year),
`wday()` (day of the week),
`hour()`, 
`minute()`, 
`second()`

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
```

Можно передать функция аргумент `label = TRUE` чтобы получить сокращенное название месяца или дня недели. ЧТобы получить полное нзвание, задайте аргумент `abbr = FALSE`

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Мы можем использовать функцию `wday()` для того чтобы убедится, что количество вылетов на протяжении недели больше чем в выходные дни

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

В поведении среднего времени задержки вылета в зависимости от минуты часа наблюдается любопытная закономерность.
Похоже, что для авиарейсов, вылетающих в минутные интервалы часа 20-30 и 50-60, задержки намного меньше, чем для остальных временных промежутков.

```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

Интересно, что если взглянуть на время вылета по расписанию, то никакой ярко выраженной закономерности не наблюдается

```{r}
sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()
```

Так почему же нам удается наблюдать закономерность, в фактическом времени вылета? Подобно многим другим данным, подготовленным людьми, здесь наблюдаеися отчетливое смещение в сторону авиарейсов, отправляющихся в круглое время. Работая с данными, подверженными влиянию человеческих суждений, всегда надо быть настороже!

```{r}
ggplot(sched_dep, aes(minute, n)) +
  geom_line()
```

#### Округление

Альтернативный подход к построению графиков отдельных компонент --- округление даты до ближайшей единицы времени с помощью функций 
`floor_date()`, `round_date()`, `ceiling_date()`. Каждая из этих функций принимает вектор дат, подлежащих округлению и название единицы, до которой должно выполняться округление вниз `floor`, округление вверх `ceiling`, или до ближайшего значения `round`. Это например, позволяет построить график количества авиарейсов в неделю.

```{r}
flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()
```

Особенно полезно может быть вычсиление разницы между округленной и неокруглённой датой.

#### Задание значений компонентов

Функции доступа так же позволяет устанавливать значения компонентов даты/времени. 

```{r}
(datetime <- ymd_hms("2016-07-08 12:34:56"))

year(datetime) <- 2020
datetime

month(datetime) <- 01
datetime

hour(datetime) <- hour(datetime) + 1
datetime
```

Альтернативный вариант позволяет не изменять значения на месте, а создавать новые значения с помощью функции `update()`. Кроме того можно устанавливать одновременно несколько значений.

```{r}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```

Если значения слишком велики, они "закольцовываются"

```{r}
ymd("2015-02-01") %>% 
  update(mday = 30)

ymd("2015-02-01") %>% 
  update(hour = 400)
```

Функцию `update()` можно использовать для того, чтобы отобразить распределение авиарейсов на протяжении дня для каждого дня в году

```{r}
flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)
```

Задание для более крупных компонентов даты постоянного значения --- удобная методика, позволяющая исследовать закономерности, связанные с меньшими компонентами.

#### Упражнение 16.3.4.1
<div class="question">
How does the distribution of flight times within a day change over the course of the year?
</div>

Давайте попробуем построить помесячный график.

```{r}
flights_dt %>%
  filter(!is.na(dep_time)) %>%
  mutate(dep_hour = update(dep_time, yday = 1),
         month = factor(month(dep_time))) %>% 
  ggplot(aes(dep_hour, color = month)) +
  geom_freqpoly(binwidth = 60 * 60)
```

Чтобы убрать отклонения заметные отклонения между месяцами из-за разного количества дней в месяце, нужно отнормировать построение

```{r}
flights_dt %>%
  filter(!is.na(dep_time)) %>%
  mutate(dep_hour = update(dep_time, yday = 1),
         month = factor(month(dep_time))) %>% 
  ggplot(aes(dep_hour, color = month)) +
  geom_freqpoly(aes(y = ..density..), binwidth = 60 * 60)
```

#### Упражнение 16.3.4.2
<div class="question">
Compare `dep_time`, `sched_dep_time` and `dep_delay`. Are they consistent? Explain your findings.
</div>


```{r}
flights_dt %>%
  mutate(residual = (dep_time - sched_dep_time) / 60) %>% 
  filter(residual != dep_delay) %>%
  select(residual, dep_time, sched_dep_time, dep_delay)
```

Существуют расхождения. 
Похоже, в данных есть ошибки. 
Это рейсы, в которых фактическое время отправления на следующий день относительно запланированного времени отправления. 
Мы забыли учесть это при создании даты и времени с помощью функции `make_datetime_100()` в 16.2.2 из отдельных компонентов.
Код должен был бы проверить, если время отправления меньше запланированного времени отправления плюс задержка отправления (в минутах). В качестве альтернативы, простое добавление задержки отправления к запланированному времени отправления является более надежным способом построения времени отправления, поскольку оно автоматически учитывает переход на следующий день.

#### Упражнение 16.3.4.3
<div class="question">
Compare `air_time` with the duration between the departure and arrival. 
Explain your findings. 
(Hint: consider the location of the airport.)
</div>

```{r}
flights_dt %>%
  mutate(residual = as.numeric(arr_time - dep_time),
         diff = residual - air_time) %>% 
  select(origin, dest, residual, air_time, diff, arr_time, dep_time) %>% 
  group_by(diff) %>%
  count(diff) %>%
  filter(!is.na(diff)) %>%
  ggplot(aes(diff, n)) +
  geom_jitter(alpha = 0.25, width = 0, height = 0.2) +
  scale_x_log10()
```

Большая часть точек лежит в области отклонения. Вероятно, это связано с переводом времени.


#### Упражнение 16.3.4.4
<div class="question">
How does the average delay time change over the course of a day? Should you use `dep_time` or `sched_dep_time`? Why?
</div>

Будем брать запланированное время вылета. 
Потому что это заявленная характеристика вылета, и на неё можно ореентироваться. 
КРоме того использование `dep_time` всегда смещает задержки на более поздний день. 
```{r}
flights_dt %>%
  mutate(sched_dep_hour = hour(sched_dep_time)) %>%
  group_by(sched_dep_hour) %>%View()
  summarise(dep_delay = mean(dep_delay)) %>% 
  ggplot(aes(y = dep_delay, x = sched_dep_hour)) +
  geom_point() +
  geom_smooth()
```

Как видно на графике,  самые большие задержки плавно возрастают в течении дня, и за пару часов до полуночи, немного спадают. При этом пик образуется в районе 19 часов.

#### Упражнение 16.3.4.5
<div class="question">
On what day of the week should you leave if you want to minimise the chance of a delay?
</div>

Чтобы ответить на этот вопрос, нужно посчитать среднее время задержки в каждом дне недели


```{r}
flights_dt %>% 
  mutate(wday = wday(sched_dep_time, label = TRUE)) %>%
  group_by(wday) %>%
  summarise(mean_wday_arr_delay = mean(arr_delay, na.rm = TRUE),
            mean_wday_dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(mean_wday_dep_delay, mean_wday_arr_delay)) +
    geom_point() +
    geom_text(aes(label = wday), vjust = 1.2, hjust = 1.2, check_overlap = TRUE) +
  labs(x = "Среднее время задержки вылета, минут",
       y = "Среднее время задержки прилёта, минут")
```

Очевидно, я бы выбрал для полёта субботу

#### Упражнение 16.3.4.6
<div class="question">
What makes the distribution of `diamonds$carat` and `flights$sched_dep_time` similar?
</div>

```{r}
ggplot(diamonds, aes(x = carat %% 1 * 100)) +
  geom_histogram(binwidth = 1)
```


```{r}
ggplot(flights_dt, aes(x = minute(sched_dep_time))) +
  geom_histogram(binwidth = 1)
```

И в `diamonds$carat`, и в `flights$sched_dep_time` есть аномально большие значения, которые находятся под хорошими «человеческими» числами. 
В `flights$sched_dep_time` это минуты 00 и 30 минут и кратные 0 и 5 минутам.

В `diamonds$carat` это в 0, 1/3, 1/2, 2/3.


#### Упражнение 16.3.4.7
<div class="question">
Confirm my hypothesis that the early departures of flights in minutes 20-30 and 50-60 are caused by scheduled flights that leave early. 
Hint: create a binary variable that tells you whether or not a flight was delayed
</div>


```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

На минутном уровне ничего не появляется:

```{r}
flights_dt %>%
  mutate(
    early = dep_delay < 0,
    minute = minute(sched_dep_time)
  ) %>% 
  group_by(minute) %>%
  summarise(early = mean(early)) %>% 
  ggplot(aes(x = minute, y = early)) +
  geom_point()
```

Но если сгруппировать с 10-минутными интервалами, то в эти минуты будет больше доля ранних рейсов.

```{r}
flights_dt %>%
  mutate(
    early = dep_delay < 0,
    minute = minute(sched_dep_time) %% 10
  ) %>%
  group_by(minute) %>%
  summarise(early = mean(early)) %>% 
  ggplot(aes(x = minute, y = early)) +
  geom_point()
```

### Временные промежутки

* длительности --- количество секунд

* периоды --- представляют промежутки времени, используемые людьми, такие как недели или месяцы

* интервалы --- начальный и конечный моменты времени

#### Длительности

При вычитании двух дат в `R` получется объект `difftime`

```{r}
h_age <- today() - ymd(19921020)
h_age
```

Объект класса `difftime` записывает временные промежутки, выраженные в секундах, минутах, часах, днях или неделях. Эта неоднозначность может несколько затруднить работсу с объектами `difftime`, поэтому пакет `lubridate` предоставляет альтернативу --- длительности `duration`, которая всегда выржается в секундах.

```{r}
as.duration(h_age)
```

Для длительностей предусмотрен целый ряд удобных конструкторов

```{r}
dseconds(15)

dminutes(10)

dhours(c(12, 24))

ddays(0:5)

dweeks(3)

dyears(1)
```

Длительности всегда выражают временные промежутки в секундах. Длительность можно умножать и складывать.

```{r}
2 * dyears(1)

dyears(1) + dweeks(3) + dhours(15)
```

Длительности могут участвовать в операциях сложения и вычитания совместно с днями.

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

Вместе с тем, поскольку длительности предоставляют точное количество секунд, можно получить неожиданные результаты.

```{r}
one_pm <- ymd_hms(
  "2016-03-12 13:00:00",
  tz = "America/New_York"
)

one_pm

one_pm + ddays(1)
```

Почему момент времени спустя сутки после 13:00 12 марта получился равным 14:00 13 марта. Это всё потому что произошло изменение часового пояса. ВВиду перехода на летнее время 12 марта содержит лишь 23 часа, но после добавления полных суток, выраженных в секундах, мы получаем доугой результат.

#### Периоды

Для разрешения этой проблемы пакет `lubridate` предоставляет *периоды*.
Это временные промежуткт, но оги не работают с фиксированной длительностью, выраженной в секундах. а используют такие единицы, используемые людьми, как дни и месяцы, благодаря чему работюь более интуитивным образом.

```{r}
one_pm

one_pm + days(1)
```

Подобно длительностям, периоды можно создавать с помощью целого ряда собственных функций конструкторов.

```{r}
seconds(15)

minutes(10)

hours(c(12, 24))

days(7)

months(1:6)

weeks(3)

years(1)
```

Периоды можно складывать и умножать на числа

```{r}
10 * (months(6) + days(1))

days(50) + hours(25) + minutes(2)
```

Периоды можно так же складывать с датами. В отличае от длительностей, работая с периодами вы будете полчать резльтаты в соответствии со своими ожиданиями.

```{r}
# Високосный год
ymd("2016-01-01") + dyears(1)

ymd("2016-01-01") + years(1)


# Переход на летнее время
one_pm + ddays(1)

one_pm + days(1)
```

Давайте используем периоды для устранения кажущихся странностей, связанных с датами авиарейсов. Некоторые самолёты, если верить данным, прилетают в пункт назначения еще до того, как вылетели из Нью-Йорка!

```{r}
flights_dt %>%
  filter(arr_time < dep_time)
```

Это авиарейсы, в которых при переходе через полночь самолет находится в воздухе. Мы использовали одну и ту же информацию о дате, как для времени вылета, так и для времени прилета, но эти ночные авиарейсы прибывают в аэропорт назначения на следуюзий день. Мы можем это учесть, добавив `days(1)` ко времени прибытия каждого ночного авиарейса. 

```{r}
flights_dt <- flights_dt %>%
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight * 1),
    # Бинарная переменная умножается на единицу --- FALSE * 1 = 0
    sched_arr_time = sched_arr_time + days(overnight * 1)
  )
```

Теперь все авирейсы подчиняются законам физики.

```{r}
flights_dt %>%
  filter(overnight, arr_time < dep_time)
```

#### Интервалы

Результат деления `dyears(1) / ddays(365)` результат очевиден --- 1. Поскольку длительности всегда представляются количеством секунд, а длительность года определяется как кол-во секунд в 365 днях.

А какой результат будет при делении `years(1) / days(1)`. Если имеется в виду 2015 год, то 365, а если 2016 то 366.

В данном случае пакет `lubridate` не располагает достаточной информацией для того чтобы дать однозначный ответ. Вместо этого он даст лишь оценку рещультата, сопроводив её предупреждающим сообщением.

```{r}
years(1) / days(1)
```

Для точности, нужно использовать интервал. Интервал --- это длительность, для которой указан начальный момент времени, что позволяет точно определить, сколько времени она занимает.

```{r}
next_year <- today() - years(1)
(today() %--% next_year) / ddays(1)
```

Чтобы выяснить сколько периодов приходится на интервал, необходимо использовать целочисленное деление.

```{r}
(today() %--% next_year) %/% days(1)
```

#### Резюме

Как обычно, всегда выбирайте самую простую структуру, которая позволяет решить вашу задачу. 

* Если вас интересует лишь физическое время --- длительность

* Если нужно выразить время в терминах --- период

* Если нужно выразить длительность временного промежутка --- интервал

* Вставка рисунка --- ![alt text](img/datetimes-arithmetic.png)

#### Упражнение 16.4.5.1

<div class="question">
Why is there `months()` but no `dmonths()`?
</div>

Потому что месяц это непостоянная величина.

* 31 день: январь, март, май, июль, август, октябрь

* 30 дней: апрель, июнь, сентябрь, ноябрь, декабрь

* 28 или 29 дней: февраль

Месяц --- это не продолжительность времени, определяемая независимо от того, когда он происходит, а специальный интервал между двумя датами.

#### Упражнение 16.4.5.2
<div class="question">
Explain `days(overnight * 1)` to someone who has just started learning R. How does it work?
</div>

Всё очень просто. `overnight = arr_time < dep_time` это бинарная переменная, которая принимает значения либо `TRUE` если время прибытия меньше времени отправления, либо `FALSE`, если наоборот. 
По правилу умножения бинарных операторов в `R` мы получим 0 если будем умножать на `FALSE` и 1 если будем умножать на `TRUE`.
Такой манёвр в функции `arr_time = arr_time + days(overnight * 1)` позволяет добавлять один день `days(1)` к дням, у которых время прибытия на день раньше, и не прибавлять ничего `days(0)`, в случае если прибытие было в день отправления.

#### Упражнение 16.4.5.3
<div class="question">
Create a vector of dates giving the first day of every month in 2015. Create a vector of dates giving the first day of every month in the current year.
</div>

```{r}
# Сначала я подумал, что нумерация месяцев идёт от первого месяца
ymd("2015-01-01") + months(1:12)

# Но это не так, первый месяц начинается с нуля
ymd("2015-01-01") + months(0:11)

```

Чтобы узнать первый месяц текущего года, снача возьмём текущую дату.
Округлим её до года, а затем добавим месяцы, как это делалось выше.

```{r}
floor_date(today(), unit = "year") + months(0:11)
```

#### Упражнение 16.4.5.4
<div class="question">
Write a function that given your birthday (as a date), returns how old you are in years.
</div>

```{r}
my_age <- function(birth) {
  (ymd(birth) %--% today()) %/% years(1)
}
age("1992-10-20")
```


#### Упражнение 16.4.5.5
<div class="question">
Why can’t `(today() %--% (today() + years(1)) / months(1)` work?
</div>

В коде нету скобки. Но даже если исправить выражение, и проставить в нужном месте скобочку, он работает не совсем так как ожидается. Потому что делим на период, а не на интервал или длительность.


```{r}
(today() %--% (today() + years(1))) / months(1)
```

Числитель выражения `(today ()% -% (today () + years (1))` представляет собой интервал, который представляет длительность времени вместе с начальной точкой. Интервал имеет точное количество секунд. 
Знаменатель выражения, `months(1)`, представляет собой период, который имеет значение для человека, но не определен в терминах точного количества секунд. 
Месяцы могут составлять 28, 29, 30 или 31 день, поэтому неясно на какие `months(1)` делится? 
Код не выдает предупреждающее сообщение, но не всегда дает правильный результат.


### Часовые пояса

Есть несколько трудностей, с котороми возможно предстоит столкнуться.

* Используемые названия часовых поясов бывают неоднозначны. Но в R для отображения часового пояса используется формат `"<континент>/<город>"`
Чтобы узнать свой текущий часовой пояс достаточно вызвать функцию `Sys.timezone()`

```{r}
Sys.timezone()
```

```{r}
# View(OlsonNames())
```

В `R` часовой пояс это атрибут даты/времени, которы лишь управляет выводом на печать. Например, следующие три объекта представляют один и тот же момент времени.

```{r}
(x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))

(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))

(x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))
```

Можно проверить это путём вычитания

```{r}
x1 - x2
x2 - x3
```

Если не указано иное, пакет `lubridate` всегда использует UTC. Это стандартный часовой пояс, используемый научным сообществом, который примерно эквивалентен своему предшественнику GMT. В нём отсутствует переход на летнее время, что удобно для выполнения вычислений. В операциях, объединяющих дату и время наподобие `c()` часовой пояс часто опускается. В этом случае дата и время будут отображаться с текущим часовым поясом

```{r}
(x4 <- c(x1, x2, x3))
```

Часовой пояс можно изменить двумя способами.

* Можно оставить тоже время, но изменить его отображение. Используйте этот метод, если хотите отобразить время в более естественном формате. 

```{r}
(x4a <- with_tz(x4, tzone = "Australia/Lord_Howe"))
```

Этот пример иллюстрирует ещё одну проблему --- разница между часовыми поясами не всегда выражается целым числом часов.

* МОжно изменить само время. Используйте этот метод, если время было выведено с некорректно указанным часовым поясом и вы хотите исправить это

```{r}
(x4b <- force_tz(x4, tzone = "Australia/Lord_Howe"))

x4b - x4
```

