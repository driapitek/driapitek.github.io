---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Аккуратизация данных с помощью пакета `tidyr`

### Введение

Есть три семейства глаголов, предназначенных для выполнениях следуюзщий операций над реляционными данными:

* видоизменение соединений

* фильтрация соединений

* операции над множествами

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(nycflights13)
library("datamodelr") # Пакет для моделирования схем баз данных
```

### Пакет `nycflights13`

Этот пакет содержит четыре связанных tibble-frame их взаимосвязь хорошо продемонстрирована на рисунке

![alt text](img/relational.png)

#### Упражнение 13.2.1.1
<div class="question">
Imagine you wanted to draw (approximately) the route each plane flies from its origin to its destination. What variables would you need? What tables would you need to combine?
</div>

Для того чтобы построить маршрут перелёта, необходимо понимать точные данные о местах отправления и назначения. Информацию о перелётах из аэропорта в аэропорт можно получить из фрейма данных `flights` --- переменны `origin` и `dest`, для определения точек отправления и назначения. А информацию о городе в котором расположен конкретный аэропорт можно получить из фрейма данных `airports` --- переменные `lat` и `lon` для получения широты и долготы, т.е. координат аэропорта.

#### Упражнение 13.2.1.2
<div class="question">
I forgot to draw the relationship between `weather` and `airports`. What is the relationship and how should it appear in the diagram?
</div>

На самом деле между ними косвенно указана связь через `flights`. Но если быть точным, то `airports$faa` это внешний ключ `weather$origin`

#### Упражнение 13.2.1.3
<div class="question">
Weather only contains information for the origin (NYC) airports. If it contained weather records for all airports in the USA, what additional relation would it define with `flights`?
</div>

Если бы в `weather` содержались данные о погодных условиях во всех аэропортах, то 'необходимо было бы установить  это обеспечило бы погоду для `dest` каждого рейса. Соответственно необходимо было бы установить соответствие в таблицах между `dest`.

#### Упражнение 13.2.1.4
<div class="question">
We know that some days of the year are “special”, and fewer people than usual fly on them. How might you represent that data as a data frame? What would be the primary keys of that table? How would it connect to the existing tables?
</div>

Можно добавить отдельную таблицу, например `special date`, в которой перечислить эти специальные даты. Первичным ключом была бы комбинация даты из `flights` вплоть до дня `year`, `month`, `day`.

```{r}
special_date <- tribble(
  ~year, ~month, ~day, ~holiday,
  2013, 01, 01, "New Years Day"
)
```

#### Ключи

Ключи бывают двух видов:

* Первичный ключ идентифицирует наблюдение в собственной таблице. Например `planes$tailnum` однозначно идентифицирует каждый самолет в таблице `planes`

* Внешний ключ однозначно идентифицирует наблюдение в другой таблице. Наприме, `flights$tailnum` --- внешний ключ, поскольку он появляется в таблице `flights`, в которой он устанавливает для каждого авиарейса однозначно определяемый самолёт.

Переменная может одновременно служить первичным и внешним ключом. Например переменная `origin` является частью первичного ключа для таблицы `weather` и одновременно внешним ключом для таблицы `airports`

Чтобы убедится в том, что переменная которую мы определили как внешний ключ, действительно является таковой, можно проверить следующим способом:

```{r}
planes %>%
  count(tailnum) %>%
  filter(n > 1)
```

Так как первичный ключ устанавливает однозначной соответствие, то количество раз которое встречается эта переменная должно быть строго не больше одного раза.

Бывает, что таблица не имеет явного первичного ключа: каждая строка является наблюдением, но ниодна комбинация не обеспечивает её надежную идентификацию.

Например, что является первичным ключом во `flights`? Комбинация даты и номера вылета? Это было бы так, если бы в день самолёт совершал один полёт, но это не так:

```{r}
flights %>%
  count(year, month, day, flight) %>%
  filter(n > 1)
```

Если в таблице отсутствует первичный ключ, иногда его бывает удобно добавить с помощью функций `mutate()` и `row_number()`. Такой улюч называют суррогатным.

#### Упражнение 13.3.1.1
<div class="question">
Add a surrogate key to `flights`.
</div>

Однозначно описать строку может её порядковый номер:

```{r}
flights %>% 
  mutate(id = row_number())
```

Ещё лучше сначала упорядочить текущий набор данных и только затем присваивать идентификационный номер:

```{r}
flights %>%
  arrange(year, month, day, sched_dep_time, carrier, flight) %>%
  mutate(flight_id = row_number())
```

#### Упражнение 13.3.1.2
<div class="question">
Identify the keys in the following datasets

1. `Lahman::Batting`

1. `babynames::babynames`

1. `nasaweather::atmos`

1. `fueleconomy::vehicles`

1. `ggplot2::diamonds`

(You might need to install some packages and read some documentation.)
</div>

1. Для меня совершенно не очевидный ответ, к которому я пришёл интуитивно:

```{r}
Lahman::Batting %>%
  count(playerID, yearID, stint) %>%
  filter(n > 1)
```

Таким образом, первичным ключом в этих данных будет связка параметров `playerID`, `yearID`, `stint`.
Эти данные --- статистика по игре в бейсбол. Первые два параметра это как не трудно догадаться ID игрока, и года в котором он играл. Сначала я проверил на однозначность описания совокупность этих двух параметров. Но так как в течении года у игрока может изменяться положение/роль (параметр `stint`), то первичным ключом будет комбинация трёх параметров.

Больше информации по этим данным содержится в оригинальном наборе данных <http://www.seanlahman.com/files/database/readme2012.txt>

1. Для работы с эим набором данных необходимо скачать пакет `babynames`. В этом наборе данных содержится информация о количестве имён используемых в каждом году и их популярность.

```{r}
# install.packages("babynames")
library(babynames)

babynames::babynames %>%
  count(year, sex, name) %>%
  filter(nn > 1) # Обрати мнимание, что в исходном наборе данных уже есть параметр n, поэтому для подсчёта количества вхождений используеться переменная nn
```

Первичным ключом будет комбинация из трёх параметров --- имя, пол (потому что есть бисексуальные имена) и год в котором было использовано это имя.

Больше информации по этому набору данных <https://github.com/hadley/babynames>

1. Для работы с этим набором данных необходимо установить пакет `nasaweather`. Данные представляют собой географические и атмосферные измерения на очень грубой сетке 24 на 24, охватывающей Центральную Америку. Переменными являются: высота, температура (поверхность и воздух), озон, давление воздуха и облачный покров (низкий, средний и высокий). За исключением повышения, все переменные являются среднемесячными с наблюдениями за январь 1995 года по декабрь 2000 года. Эти данные были получены из Центра данных атмосферных наук NASA Langley Research Center

```{r}
# install.packages("nasaweather")
library(nasaweather)
```

Таким образом, первичным ключом будет комбинация параметров --- ширина-долгота для идентификации местоположения, и месяц-год для идентификации события во времени. Другими словами:

```{r}
nasaweather::atmos %>%
  count(lat, long, year, month) %>%
  filter(n > 1)
```

Больше информации по этим данным содержится в оригинальном наборе данных <http://stat-computing.org/dataexpo/2006/>

1. Для работы с этим набором данных необходимо установить пакет `fueleconomy`. Данные об экономии топлива являются результатом испытаний транспортных средств, проведенных в Национальной лаборатории Агентства по охране окружающей среды и выбросов топлива в Анн-Арборе, штат Мичиган, в 1985-2015. А также производителями транспортных средств под надзором EPA. Данные об экономии топлива из EPA, 1985-2015. Этот набор данных содержит выбранные переменные и удаляет транспортные средства с неполными данными (например, без данных трансмиссии)

```{r}
# install.packages("fueleconomy")
library(fueleconomy)

fueleconomy::vehicles %>%
  count(id) %>%
  filter(n > 1)
```

В изначальном наборе данных введён первичный ключ --- переменная `id`.

Больше информации по этим данным содержится в оригинальном наборе данных <https://www.fueleconomy.gov/feg/download.shtml>

1. В наборе данных `ggplot2::diamonds`  изначально нет первичного ключа. Его нельзя задать комбинацией параметров, потому что теоретически в природе может существовать два идентичных бриллианта как по размерам и физико-химическим свойствам, так и по цене, запращиваемой за эти бриллианты. Таким образом, для определения первичного ключа, нужно вводить новую переменную (суррогатный первичный ключ).

#### Упражнение 13.3.1.3
<div class="question">
Draw a diagram illustrating the connections between the `Batting`, `Master`, and `Salaries` tables in the `Lahman` package. Draw another diagram that shows the relationship between `Master`, `Managers`, `AwardsManagers`.

How would you characterise the relationship between the `Batting`, `Pitching`, and `Fielding` tables?
</div>

Чтобы фиксировать взаимоотношения данных в таблицах можно использовать множество разных ресурсов. Вероятно на специализированных ресурсах отношения и стрелочки будут выглядеть лучше, но мне помнравилась идея отображать отношения в той рабочей среде в которой проводится анализ.

Для этого необходимо установить два пакета:

```{r}
install.packages("datamodelr")
install.packages("DiagrammeR")
```

Второй пакет необходим для отображения работы первого.

Подробно работа с пакетом описана в репозитории разработчика <https://github.com/bergant/datamodelr#model-diagram-of-interconnected-data-frames>

Общий подход такой --- для начала определяем первичные ключи:

-   `Master`

    -   Первичный: `playerID`

-   `Batting`

    -   Первичный: `playerID`, `yearID`, `stint`

    -   Внешний:

        -   `playerID` = `Master$playerID` (many-to-1)

-   `Salaries`

    -   Primary keys: `yearID`, `teamID`, `playerID`

    -   Foreign Keys

        -   `playerID` = `Master$playerID` (many-to-1)

После этого задаём их связи `Batting$playerID == Master$playerID`, `Salaries$playerID == Master$playerID`

И на третьем шаге можно строить отношения:
    
```{r}
dm1 <- dm_from_data_frames(list(Batting = Lahman::Batting,
                                Master = Lahman::Master,
                                Salaries = Lahman::Salaries)) %>%
  dm_set_key("Batting", c("playerID", "yearID", "stint")) %>%
  dm_set_key("Master", "playerID") %>%
  dm_set_key("Salaries", c("yearID", "teamID", "playerID")) %>%
  dm_add_references(
    Batting$playerID == Master$playerID,
    Salaries$playerID == Master$playerID
  )

dm_create_graph(dm1, rankdir = "LR", columnArrows = TRUE)
```

Теперь проделаем эту же процедуру для `Master`, `Managers`, `AwardsManagers`


-   `Master`

    -   Первичный: `playerID`

-   `Managers`

    -   Первичный: `yearID`, `teamID`, `inseason`

    -   Внешний:

        -   `playerID` = `Master$playerID` (many-to-1)

-   `AwardsManagers`:

    -   Первичный: `playerID`, `awardID`, `yearID`
    
    -   Внешний:
    
        -   `playerID` = `Master$playerID` (many-to-1)
    
```{r}
dm2 <- dm_from_data_frames(list(Managers = Lahman::Managers,
                                Master = Lahman::Master,
                                AwardsManagers = Lahman::AwardsManagers)) %>%
  dm_set_key("Managers", c("teamID", "yearID", "inseason")) %>%
  dm_set_key("Master", "playerID") %>%
  dm_set_key("AwardsManagers", c("yearID", "awardID", "playerID")) %>%
  dm_add_references(
    AwardsManagers$playerID == Master$playerID,
    Managers$playerID == Master$playerID
  )

dm_create_graph(dm2, rankdir = "LR", columnArrows = TRUE)
```


Таблицы `Batting`, `Pitching` и `Fielding` имеют первичный ключ, состоящий из переменных `playerID`, `yearID` и `stint`. Все они имеют отношения 1-1 друг к другу, потому что `Batting`, `Pitching` и `Fielding` это названия игровых позиций.


### Мутирующие соединения 