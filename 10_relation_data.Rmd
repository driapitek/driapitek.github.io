---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Аккуратизация данных с помощью пакета `tidyr`

### Введение

Есть три семейства глаголов, предназначенных для выполнениях следуюзщий операций над реляционными данными:

* видоизменение соединений

* фильтрация соединений

* операции над множествами

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(nycflights13)
library("datamodelr") # Пакет для моделирования схем баз данных
library(viridis)
```

### Пакет `nycflights13`

Этот пакет содержит четыре связанных tibble-frame их взаимосвязь хорошо продемонстрирована на рисунке

![alt text](img/relational.png)

#### Упражнение 13.2.1.1
<div class="question">
Imagine you wanted to draw (approximately) the route each plane flies from its origin to its destination. What variables would you need? What tables would you need to combine?
</div>

Для того чтобы построить маршрут перелёта, необходимо понимать точные данные о местах отправления и назначения. Информацию о перелётах из аэропорта в аэропорт можно получить из фрейма данных `flights` --- переменны `origin` и `dest`, для определения точек отправления и назначения. А информацию о городе в котором расположен конкретный аэропорт можно получить из фрейма данных `airports` --- переменные `lat` и `lon` для получения широты и долготы, т.е. координат аэропорта.

#### Упражнение 13.2.1.2
<div class="question">
I forgot to draw the relationship between `weather` and `airports`. What is the relationship and how should it appear in the diagram?
</div>

На самом деле между ними косвенно указана связь через `flights`. Но если быть точным, то `airports$faa` это внешний ключ `weather$origin`

#### Упражнение 13.2.1.3
<div class="question">
Weather only contains information for the origin (NYC) airports. If it contained weather records for all airports in the USA, what additional relation would it define with `flights`?
</div>

Если бы в `weather` содержались данные о погодных условиях во всех аэропортах, то 'необходимо было бы установить  это обеспечило бы погоду для `dest` каждого рейса. Соответственно необходимо было бы установить соответствие в таблицах между `dest`.

#### Упражнение 13.2.1.4
<div class="question">
We know that some days of the year are “special”, and fewer people than usual fly on them. How might you represent that data as a data frame? What would be the primary keys of that table? How would it connect to the existing tables?
</div>

Можно добавить отдельную таблицу, например `special date`, в которой перечислить эти специальные даты. Первичным ключом была бы комбинация даты из `flights` вплоть до дня `year`, `month`, `day`.

```{r}
special_date <- tribble(
  ~year, ~month, ~day, ~holiday,
  2013, 01, 01, "New Years Day"
)
```

#### Ключи

Ключи бывают двух видов:

* Первичный ключ идентифицирует наблюдение в собственной таблице. Например `planes$tailnum` однозначно идентифицирует каждый самолет в таблице `planes`

* Внешний ключ однозначно идентифицирует наблюдение в другой таблице. Наприме, `flights$tailnum` --- внешний ключ, поскольку он появляется в таблице `flights`, в которой он устанавливает для каждого авиарейса однозначно определяемый самолёт.

Переменная может одновременно служить первичным и внешним ключом. Например переменная `origin` является частью первичного ключа для таблицы `weather` и одновременно внешним ключом для таблицы `airports`

Чтобы убедится в том, что переменная которую мы определили как внешний ключ, действительно является таковой, можно проверить следующим способом:

```{r}
planes %>%
  count(tailnum) %>%
  filter(n > 1)
```

Так как первичный ключ устанавливает однозначной соответствие, то количество раз которое встречается эта переменная должно быть строго не больше одного раза.

Бывает, что таблица не имеет явного первичного ключа: каждая строка является наблюдением, но ниодна комбинация не обеспечивает её надежную идентификацию.

Например, что является первичным ключом во `flights`? Комбинация даты и номера вылета? Это было бы так, если бы в день самолёт совершал один полёт, но это не так:

```{r}
flights %>%
  count(year, month, day, flight) %>%
  filter(n > 1)
```

Если в таблице отсутствует первичный ключ, иногда его бывает удобно добавить с помощью функций `mutate()` и `row_number()`. Такой улюч называют суррогатным.

#### Упражнение 13.3.1.1
<div class="question">
Add a surrogate key to `flights`.
</div>

Однозначно описать строку может её порядковый номер:

```{r}
flights %>% 
  mutate(id = row_number())
```

Ещё лучше сначала упорядочить текущий набор данных и только затем присваивать идентификационный номер:

```{r}
flights %>%
  arrange(year, month, day, sched_dep_time, carrier, flight) %>%
  mutate(flight_id = row_number())
```

#### Упражнение 13.3.1.2
<div class="question">
Identify the keys in the following datasets

1. `Lahman::Batting`

1. `babynames::babynames`

1. `nasaweather::atmos`

1. `fueleconomy::vehicles`

1. `ggplot2::diamonds`

(You might need to install some packages and read some documentation.)
</div>

1. Для меня совершенно не очевидный ответ, к которому я пришёл интуитивно:

```{r}
Lahman::Batting %>%
  count(playerID, yearID, stint) %>%
  filter(n > 1)
```

Таким образом, первичным ключом в этих данных будет связка параметров `playerID`, `yearID`, `stint`.
Эти данные --- статистика по игре в бейсбол. Первые два параметра это как не трудно догадаться ID игрока, и года в котором он играл. Сначала я проверил на однозначность описания совокупность этих двух параметров. Но так как в течении года у игрока может изменяться положение/роль (параметр `stint`), то первичным ключом будет комбинация трёх параметров.

Больше информации по этим данным содержится в оригинальном наборе данных <http://www.seanlahman.com/files/database/readme2012.txt>

1. Для работы с эим набором данных необходимо скачать пакет `babynames`. В этом наборе данных содержится информация о количестве имён используемых в каждом году и их популярность.

```{r}
# install.packages("babynames")
library(babynames)

babynames::babynames %>%
  count(year, sex, name) %>%
  filter(nn > 1) # Обрати мнимание, что в исходном наборе данных уже есть параметр n, поэтому для подсчёта количества вхождений используеться переменная nn
```

Первичным ключом будет комбинация из трёх параметров --- имя, пол (потому что есть бисексуальные имена) и год в котором было использовано это имя.

Больше информации по этому набору данных <https://github.com/hadley/babynames>

1. Для работы с этим набором данных необходимо установить пакет `nasaweather`. Данные представляют собой географические и атмосферные измерения на очень грубой сетке 24 на 24, охватывающей Центральную Америку. Переменными являются: высота, температура (поверхность и воздух), озон, давление воздуха и облачный покров (низкий, средний и высокий). За исключением повышения, все переменные являются среднемесячными с наблюдениями за январь 1995 года по декабрь 2000 года. Эти данные были получены из Центра данных атмосферных наук NASA Langley Research Center

```{r}
# install.packages("nasaweather")
library(nasaweather)
```

Таким образом, первичным ключом будет комбинация параметров --- ширина-долгота для идентификации местоположения, и месяц-год для идентификации события во времени. Другими словами:

```{r}
nasaweather::atmos %>%
  count(lat, long, year, month) %>%
  filter(n > 1)
```

Больше информации по этим данным содержится в оригинальном наборе данных <http://stat-computing.org/dataexpo/2006/>

1. Для работы с этим набором данных необходимо установить пакет `fueleconomy`. Данные об экономии топлива являются результатом испытаний транспортных средств, проведенных в Национальной лаборатории Агентства по охране окружающей среды и выбросов топлива в Анн-Арборе, штат Мичиган, в 1985-2015. А также производителями транспортных средств под надзором EPA. Данные об экономии топлива из EPA, 1985-2015. Этот набор данных содержит выбранные переменные и удаляет транспортные средства с неполными данными (например, без данных трансмиссии)

```{r}
# install.packages("fueleconomy")
library(fueleconomy)

fueleconomy::vehicles %>%
  count(id) %>%
  filter(n > 1)
```

В изначальном наборе данных введён первичный ключ --- переменная `id`.

Больше информации по этим данным содержится в оригинальном наборе данных <https://www.fueleconomy.gov/feg/download.shtml>

1. В наборе данных `ggplot2::diamonds`  изначально нет первичного ключа. Его нельзя задать комбинацией параметров, потому что теоретически в природе может существовать два идентичных бриллианта как по размерам и физико-химическим свойствам, так и по цене, запращиваемой за эти бриллианты. Таким образом, для определения первичного ключа, нужно вводить новую переменную (суррогатный первичный ключ).

#### Упражнение 13.3.1.3
<div class="question">
Draw a diagram illustrating the connections between the `Batting`, `Master`, and `Salaries` tables in the `Lahman` package. Draw another diagram that shows the relationship between `Master`, `Managers`, `AwardsManagers`.

How would you characterise the relationship between the `Batting`, `Pitching`, and `Fielding` tables?
</div>

Чтобы фиксировать взаимоотношения данных в таблицах можно использовать множество разных ресурсов. Вероятно на специализированных ресурсах отношения и стрелочки будут выглядеть лучше, но мне помнравилась идея отображать отношения в той рабочей среде в которой проводится анализ.

Для этого необходимо установить два пакета:

```{r}
install.packages("datamodelr")
install.packages("DiagrammeR")
```

Второй пакет необходим для отображения работы первого.

Подробно работа с пакетом описана в репозитории разработчика <https://github.com/bergant/datamodelr#model-diagram-of-interconnected-data-frames>

Общий подход такой --- для начала определяем первичные ключи:

-   `Master`

    -   Первичный: `playerID`

-   `Batting`

    -   Первичный: `playerID`, `yearID`, `stint`

    -   Внешний:

        -   `playerID` = `Master$playerID` (many-to-1)

-   `Salaries`

    -   Primary keys: `yearID`, `teamID`, `playerID`

    -   Foreign Keys

        -   `playerID` = `Master$playerID` (many-to-1)

После этого задаём их связи `Batting$playerID == Master$playerID`, `Salaries$playerID == Master$playerID`

И на третьем шаге можно строить отношения:
    
```{r}
dm1 <- dm_from_data_frames(list(Batting = Lahman::Batting,
                                Master = Lahman::Master,
                                Salaries = Lahman::Salaries)) %>%
  dm_set_key("Batting", c("playerID", "yearID", "stint")) %>%
  dm_set_key("Master", "playerID") %>%
  dm_set_key("Salaries", c("yearID", "teamID", "playerID")) %>%
  dm_add_references(
    Batting$playerID == Master$playerID,
    Salaries$playerID == Master$playerID
  )

dm_create_graph(dm1, rankdir = "LR", columnArrows = TRUE)
```

Теперь проделаем эту же процедуру для `Master`, `Managers`, `AwardsManagers`


-   `Master`

    -   Первичный: `playerID`

-   `Managers`

    -   Первичный: `yearID`, `teamID`, `inseason`

    -   Внешний:

        -   `playerID` = `Master$playerID` (many-to-1)

-   `AwardsManagers`:

    -   Первичный: `playerID`, `awardID`, `yearID`
    
    -   Внешний:
    
        -   `playerID` = `Master$playerID` (many-to-1)
    
```{r}
dm2 <- dm_from_data_frames(list(Managers = Lahman::Managers,
                                Master = Lahman::Master,
                                AwardsManagers = Lahman::AwardsManagers)) %>%
  dm_set_key("Managers", c("teamID", "yearID", "inseason")) %>%
  dm_set_key("Master", "playerID") %>%
  dm_set_key("AwardsManagers", c("yearID", "awardID", "playerID")) %>%
  dm_add_references(
    AwardsManagers$playerID == Master$playerID,
    Managers$playerID == Master$playerID
  )

dm_create_graph(dm2, rankdir = "LR", columnArrows = TRUE)
```


Таблицы `Batting`, `Pitching` и `Fielding` имеют первичный ключ, состоящий из переменных `playerID`, `yearID` и `stint`. Все они имеют отношения 1-1 друг к другу, потому что `Batting`, `Pitching` и `Fielding` это названия игровых позиций.


### Мутирующие соединения 

Мутирующее соединение позволяет объединять переменные из двух таблиц. Сначала оно находит соответсвующие наблюдения по их ключам, а затем копирует переменные из одной таблицы в другую. 

Мутирующие соединения добавляют столбцы в правый конец таблицы.

Чтобы было проще понять происходящее с данными, возьмём тренировочный набор данных.

```{r}
(flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier))
```

Предположим, мы хотим соединить два фрейма данных `flights2` и `airlines`. Напомню, что последний фрейм это:

```{r}
airlines
```

Фреймы можно соединить при помощи `left_join()`

```{r}
flights2 %>%
  select(-origin, -dest) %>%
  left_join(airlines, by = "carrier")
```

#### Что представляют собой соединения

Проще всего понять как работает соединение продемонстрировать это графически. Введём две переменные для демонстрации:

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

Их объединение будет происходить по ключу. Количество точек на диаграмме = количеству совпадений = количеству строк в результате
![alt text](img/join-inner.png)

#### Внутреннее соединение

Это простейший тип соединения, которое устанавливает соответствие между парами наблюдений, если их ключи совпадают. Собственно оно и было указано в демонстрации выше

![alt text](img/join-inner.png)

Строго говоря, этот тип соединения является **внутренним соединением по эквивалентности**, так как для сопоставления ключей используется оператор равенства. Поскольку большинство ключей относится к этому типу, мы будем опускать это уточнение. 

Результатом внутреннего соединения является новый фрейм данных, котороый содержит ключе, значения `x` и значения `y`. Для того чтобы сообщить пакету `dplyr` какая переменная является ключом, мы используем параметр `by`

```{r}
x %>%
  inner_join(y, by = "key")
```

Самым важным свойством внутреннего соединения является тот факт, что несовпадающие значения не включаются в новый фрейм данных. Это означает, что обычное внутреннее соединение, как правило нельзя использовать в анализе, так как можно очень легко потерять наблюдения.

#### Внешние соединения

Внутреннее соединение сохраняет наблюдения которые встречаются в обеих таблицах (логическое И)

Внешнее соединение сохраняет наблюдения встречающиеся хотя бы в одной из таблиц. Различают три вида внешних соединений:

* левое соединение, сохраняет все наблюдения в `x`

* правое соединение, сохраняет все наблюдения в `y`

* полное соединение, сохраняет все наблюдения в `x` и `y`

Эти соединения работают, добавляя дополнительное "виртуальное" наблюдение в каждую таблицу. Данное наблюдение имеет ключ, который совпадает с любым ключом (если никакой другой ключе не совпадает), и значение `NA`

![alt text](img/join-outer.png)
Так как левое соединение оставляет исходную выборку нетронутой, то этот тип соединения используется практически по умолчанию всегда.

Для графического изображения различных типов соединений используется диаграмма Венна

![alt text](img/join-venn.png)

Однако она обладает одним существенным недостатком --- она не сообщает что делать в тех случаях, когда ключи не обечспечивают однозначную идентификацию.

#### Неуникальные ключи

Есть две ситуации неуникальных ключей

* Неуникальные ключи есть в одной таблице. Это модет быть полезно, если необходимо добавить информацию в тех случаях, когда имеется типичное отношение "один ко многим". 

![alt text](img/join-one-to-many.png)

* Неуникальные ключи есть в обеих таблицах. При соединении таких таблиц получаются все возможные соединения

![alt text](img/join-many-to-many.png)

#### Определение ключевых столбцов

До сих пор соединение происходило только по одной переменной, задаваемой параметром `by = "key"`. Есть другие способы:

* Заданному по умолчанию значению `by = NULL` соответствует использование всех переменных, встречающихся в обеих таблицах. Это естественное соединение. Например таблицы `flights` и `weather` согласуются по общим переменным: `year`, `month`, `day`, `hour` и `origin`.

```{r}
flights2 %>%
  left_join(weather)
```

* Символьный вектор, `by = "x"`. Можно соединять не по ключу, а по любой общей переменной. НАпример, переменная `year` содержится в обеих таблицах, `flights` и `planes`, но имеет в них разный смысл, и потому для соединения таблиц мы используем только переменную `tailnum`

```{r}
flights2 %>%
  left_join(planes, by = "tailnum")
```

Неоднозначность переменных устранена при помощи суффиксов `year.x` и `year.y`


* Именованный символьный вектор `by = c("a" = "b")`. Соединения этого типа сопоставляют переменную `a` в таблице `x` с перменной `b` в таблице `y`. В результате будут использованы перменные их `x`.

Это сильный инструмент --- этакий аналог этой функции в Excell это `ВПР()`. Но только по заданному ключу здесь, функция проводит поиск, устанавливает соответствие по всем доступным столбцам в таблице `y`. 

Например, если мы хоти нарисовать карту, необходимо соединить данные таблицы `flights` с данными таблицы `airports`, которая содержит широту и долготу каждого аэропорта. Каждый авиарейс характеризуется аэропортом вылета и аэропортом назначения, поэтому мы должны конкретизировать, какой из вариантов соединения нам необходим.

```{r}
flights2 %>%
  left_join(airports, c("dest" = "faa"))
```

```{r}
flights2 %>%
  left_join(airports, c("origin" = "faa"))
```

#### Упражнение 13.4.6.1

<div class="question">
Compute the average delay by destination, then join on the airports data frame so you can show the spatial distribution of delays. Here’s an easy way to draw a map of the United States:
</div>


```{r}
airports %>%
  semi_join(flights, c("faa" = "dest")) %>%
  ggplot(aes(lon, lat)) +
    borders("state") +
    geom_point() +
    coord_quickmap()
```

Вычислим для начала среднее время задержки по пунктам назначения. Для этого необходимо сгруппировать по направлению вылета `group_by(dest)`. Затем вычислить среднее значение задержки `delay = mean(arr_delay, na.rm = TRUE)`. И наконец просуммировать по группе --- summarise()

```{r}
flights %>%
  group_by(dest) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE))
```

Теперь выполним задачу по соединению для фрейма данных `airports`

```{r}
avg_dest <- flights %>%
  group_by(dest) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE)) %>%
  inner_join(airports, by = c(dest = "faa"))
```

Теперь нанесём значения времени задержки на карту

```{r}
avg_dest %>%
  ggplot(aes(lon, lat, color = delay)) +
    borders("state") +
    geom_point() +
    coord_quickmap()
```

#### Упражнение 13.4.6.2

<div class="question">
Add the location of the origin and destination (i.e. the `lat` and `lon`) to `flights`.
</div>

Чтобы не плодить сущностей, т.е. параметров сверх необходимых, мы изначально ограничим исходные наборы данных, требуемыми параметрами. В таблице аэропортов останется всего три параметра ключ `faa` и координата долготы и широты

```{r}
airports_locations <- airports %>%
  select(faa, lat, lon)
```

И далее в наборе данных с полётам возьмём только необходимые параметры даты вылета и направлений. Только после этого присоединим данные при помощи именнованного символьного вектора

```{r}
flights %>%
    select(year:day, hour, origin, dest) %>%
    inner_join(airports_locations, by = c(origin = "faa")) %>%
    inner_join(airports_locations, by = c(dest = "faa"))
```

В очередной раз спасибо [Jeffrey Arnold](https://github.com/jrnold) за отличный совет: всегда давать понятные названия переменным, а главное за подсказку способа реализации --- добавление параметра `suffix`

```{r}
flights %>%
    select(year:day, hour, origin, dest) %>%
    inner_join(airports_locations, by = c(origin = "faa")) %>%
    inner_join(airports_locations, by = c(dest = "faa"), suffix = c("_origin", "_dest"))
```

#### Упражнение 13.4.6.3

<div class="question">
Is there a relationship between the age of a plane and its delays?
</div>

Для того чтобы вспомнить, как между собой связаны таблицы полётов и самолётов, вспомним схему:

![alt text](img/relational.png)

Чтобы не тащить все данные, ограничимся несколькими переменными в таблице самолётов --- внешним ключом `tailnum`, и годом производства самолёта `year`

```{r}
year_planes <- planes %>%
  select(year, tailnum)
```

В исходной таблице полётов тоже много смежной информации, она избыточна для решения задачи. Возьмём информацию о дате полёта, времени задержки, и номере самолёта (внешний ключ).

Для того чтобы установить некую связь между сроком эксплуатации и задержками самолёта пойдём следующей логикой. Сджойним две таблицы по номеру самолёта, затем сгруппируем по дате производства. Посчитаем в группах средннее время задержки и построим график даты производства от средней времени задержки. Для того чтобы установить возраст самолёта возьмём разность между датой полёта и датой производства.

```{r}
flights %>%
  select(year:day, dep_delay, arr_delay, tailnum) %>%           # Убираем избыточные данные
  left_join(year_planes, 
            by = "tailnum",                                     # Присоединяем по внешнему ключу инфу о самолётах
            na.rm = TRUE, 
            suffix = c("_of_plane", "_of_manufactered")) %>%    # Переименовываем параметры `year`, чтобы не запутаться 
  mutate(age = year_of_plane - year_of_manufactered) %>%        # Вычисляем возраст самолёта
  filter(!is.na(age)) %>%                                       # Чтобы нарисовать график, фильтруем отсутствующие значения
  group_by(age) %>%                                             # Группируем самолёты по возрасту
  summarise(dep_delay_mean = mean(dep_delay, na.rm = TRUE)) %>% # чтобы посчитать среднее время задержки в возрасте
  ggplot(aes(age, dep_delay_mean)) +                            # Строим диаграмму рассеяния и сглаженную прямую по ним
  geom_point() +
  geom_smooth()
```

На этой диаграмме рассеяния видно, что самолёты в возрасте до 10 лет, имеют восходящий тренд задержки. Самолёты в возрасте от 10 до 20 лет, имеют плавный нисходящий тренд. Далее, чем старше самолёты тем меньше задержка отправления.

Уменьшение задержки вылета может быть связано с тем, что старые самолеты со многими механическими неисправностями выведены из эксплуатации или потому, что воздушные линии планируют эти самолеты с достаточным временем, чтобы механические неисправности не задерживали их. 

Этот график обладает рядом особенностей

* чтобы сказать сколько лет самолёту, нужно знать как минимум дату совершения полётов.

* Примерно между 30 и 40 годами, существенный разброс средних. 

* Кроме того, график отображает только задержки отправления, возможно связь с задержками по прибытию носит другой характер.

Учитывая указанные особенности строим график, на котором будут все точки попадающие в каждый год. Для проверки того, отличается ли характер распределения задержек по прибытию, объединим данные задержек и построим на одном графике две панели с задержками по прибытию и отправлению.

```{r}
flights %>%
  select(year:day, dep_delay, arr_delay, tailnum) %>%
  left_join(year_planes, by = "tailnum", na.rm = TRUE, suffix = c("_of_plane", "_of_manufactered")) %>%
  group_by(tailnum, year_of_manufactered) %>%
  summarise(departure = mean(dep_delay, na.rm = TRUE),
            arrival = mean(arr_delay, na.rm = TRUE)) %>%
  gather(departure, arrival, key = "delay", value = "value") %>%
  ggplot(aes(year_of_manufactered, value)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~delay) +
  scale_x_continuous("Year of manufactured") +
  scale_y_continuous("Mean Delay, minutes")
```

На графике выше видно, что на рейсы редко пускают самолёты младше 1980 года. Количество полётов на самолётах старше 1980 года существенно ниже, чем полётов на более современных самолётах. Посмотрим какое распределение полётов между 1980 и  

```{r}
flights %>%
  select(year:day, dep_delay, arr_delay, tailnum) %>%
  left_join(year_planes, 
            by = "tailnum", 
            na.rm = TRUE, 
            suffix = c("_of_plane", "_of_manufactured")) %>%
  group_by(tailnum, year_of_manufactured) %>%
  summarise(departure = mean(dep_delay, na.rm = TRUE),
            arrival = mean(arr_delay, na.rm = TRUE)) %>%
  ggplot(aes(year_of_manufactured, departure)) + 
  geom_boxplot(aes(group = cut_width(year_of_manufactured, 1))) +                 # Группируем по году
  geom_smooth() +
  scale_y_log10("Logorithmic mean departure delay") +                             # Логарифмическая ось
  scale_x_reverse("Year of manufactured", breaks = seq(1930, 2013, by = 4)) +  # Указываем на сетке каждые 4 года
  labs(title = "Dependence of flight delay on the plane manufactured year. 2013")
```

Я сконцентрировался на данных о задержках отправления, так как показал выше, что задержки по прилёту не имеют существенных различий в распределении.

Этот график представляет улучшенную версию первого графика. На нём показано распределение времени задержки вылета в зависимости от года производства самолёта. Как говорилось выше --- в представленном наборе данных мало наблюдений о полётах самолётов старше 1986 года. Это может свидетельствовать о том, что компании обновляют лётный парк и старые аппараты реже выпускают в рейс. Судя по представленным графикам компании тщетельнее и щепитильнее отнсятся к старым самолётам отправляя их в рейс, так как чем старее самолёт тем меньше у него задержка перед вылетом. 

Однако в возрасте до 10 лет, наблюдается увеличение год от года времени задержки, затем до 20 лет время задержки выравнивается.

#### Упражнение 13.4.6.4

<div class="question">
What weather conditions make it more likely to see a delay?
</div>

Задаём ключевые столбцы, по которым будет происходить соединение

```{r}
flights_with_weather <- flights %>%
    inner_join(weather, by = c("origin" = "origin",
                            "year" = "year",
                            "month" = "month",
                            "day" = "day",
                            "hour" = "hour"))

```

Есть несколько параметров характеризующих погодные условия, разберём каждый. Для начала, возьмём температуру

```{r}
flights_with_weather %>%
  group_by(temp) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(temp, delay)) +
  geom_point() +
  geom_smooth()
```

На диаграмме рассеяния не наблюдается зависимость температуры от времени. Рассмотрим влияение влажности на задержки вылетов.

```{r}
flights_with_weather %>%
  group_by(humid) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(humid, delay)) +
  geom_point() +
  geom_smooth()
```

Есть небольшой рост времени задержки при относительно высокой влажности. Между 26 и 60 единицами влажности не наблюдается корреляции с временем задержки. Рассмотрим скорость ветра

```{r}
flights_with_weather %>%
  group_by(wind_speed) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(wind_speed, delay)) +
  geom_point() +
  geom_smooth()
```

При увеличении скорости ветра от 0 до 20 миль в час, наблюдается увеличениее времени задержки. Однако характер зависимости при высоких значениях скорости ветра (от 20 до 35 миль в час) носит нелинейный характер и уменьшается практически до уровня задержки при отсутсвии ветра.

Рассмотрим порывы ветра

```{r}
flights_with_weather %>%
  group_by(wind_gust) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(wind_gust, delay)) +
  geom_point() +
  geom_smooth()
```

Есть небольшой рост времени задержки при увеличинии скорости порывов, однако это рост не значительный. При больших порывах (50-60 мил в час) не всегда увеличивается время задержки. Рассмотрим как влияют осадки на время задержки

```{r}
flights_with_weather %>%
  group_by(precip) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(precip, delay)) +
  geom_point() +
  geom_smooth()
```

Пожалуй, самая показательная зависимость, приближенная к линейной, с увеличением количества осадков, компании медлят с разрешением полёта. Рассмотрим как влияет атмосферное давление на задержки:

```{r}
flights_with_weather %>%
  group_by(pressure) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(pressure, delay)) +
  geom_point() +
  geom_smooth()
```

Увеличение давления, наоборот --- уменьшает время задержки вылета, хоть и не значительно.

```{r}
flights_with_weather %>%
  group_by(visib) %>%
  summarise(delay = mean(dep_delay, na.rm = TRUE)) %>%
  ggplot(aes(visib, delay)) +
  geom_point() +
  geom_smooth()
```

ВИдимость практически не влияет на время задержки.

Резюмируя: на время задержки вылета самолёта в большей степени влияют выпадаемые осадки (вероятно потому что необходимо расчищать взлётную полосу в зимнее время). Заметно на время задержки вылета влияет скорость и порывы ветра (вероятно потому что сложно взлетать при сильном ветре). Остальные представленные показатели погоды (температура, атмосферное давление, видимость) слабо увеличивают или вовсе уменьшают время задержки вылета.

#### Упражнение 13.4.6.5

<div class="question">
What happened on June 13 2013? Display the spatial pattern of delays, and then use Google to cross-reference with the weather.
</div>

Гуглим. Оказывается в этот день, точнее в дни 12-13 июня произошла [серия шторвом](https://en.wikipedia.org/wiki/June_12–13,_2013_derecho_series) на южном побережье. Вероятно это может вызвать задержки

Сравним к примеру два дня --- день шторма и любой другой день

```{r}
flights %>%
  filter(year == 2013, month == 6, day == 13) %>%
  group_by(dest) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE)) %>%
  inner_join(airports, by = c("dest" = "faa")) %>%
  ggplot(aes(y = lat, x = lon, size = delay, colour = delay)) +
  borders("state") +
  geom_point() +
  coord_quickmap() +
  scale_colour_viridis()
```

```{r}
flights %>%
  filter(year == 2013, month == 1, day == 13) %>%
  group_by(dest) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE)) %>%
  inner_join(airports, by = c("dest" = "faa")) %>%
  ggplot(aes(y = lat, x = lon, size = delay, colour = delay)) +
  borders("state") +
  geom_point() +
  coord_quickmap() +
  scale_colour_viridis()
```

Заметно существенное увеличение числа задержек прибытия самолётов в день штормов