---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Аккуратизация данных с помощью пакета `tidyr`

### Введение

Есть три семейства глаголов, предназначенных для выполнениях следуюзщий операций над реляционными данными:

* видоизменение соединений

* фильтрация соединений

* операции над множествами

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(nycflights13)
library("datamodelr") # Пакет для моделирования схем баз данных
```

### Пакет `nycflights13`

Этот пакет содержит четыре связанных tibble-frame их взаимосвязь хорошо продемонстрирована на рисунке

![alt text](img/relational.png)

#### Упражнение 13.2.1.1
<div class="question">
Imagine you wanted to draw (approximately) the route each plane flies from its origin to its destination. What variables would you need? What tables would you need to combine?
</div>

Для того чтобы построить маршрут перелёта, необходимо понимать точные данные о местах отправления и назначения. Информацию о перелётах из аэропорта в аэропорт можно получить из фрейма данных `flights` --- переменны `origin` и `dest`, для определения точек отправления и назначения. А информацию о городе в котором расположен конкретный аэропорт можно получить из фрейма данных `airports` --- переменные `lat` и `lon` для получения широты и долготы, т.е. координат аэропорта.

#### Упражнение 13.2.1.2
<div class="question">
I forgot to draw the relationship between `weather` and `airports`. What is the relationship and how should it appear in the diagram?
</div>

На самом деле между ними косвенно указана связь через `flights`. Но если быть точным, то `airports$faa` это внешний ключ `weather$origin`

#### Упражнение 13.2.1.3
<div class="question">
Weather only contains information for the origin (NYC) airports. If it contained weather records for all airports in the USA, what additional relation would it define with `flights`?
</div>

Если бы в `weather` содержались данные о погодных условиях во всех аэропортах, то 'необходимо было бы установить  это обеспечило бы погоду для `dest` каждого рейса. Соответственно необходимо было бы установить соответствие в таблицах между `dest`.

#### Упражнение 13.2.1.4
<div class="question">
We know that some days of the year are “special”, and fewer people than usual fly on them. How might you represent that data as a data frame? What would be the primary keys of that table? How would it connect to the existing tables?
</div>

Можно добавить отдельную таблицу, например `special date`, в которой перечислить эти специальные даты. Первичным ключом была бы комбинация даты из `flights` вплоть до дня `year`, `month`, `day`.

```{r}
special_date <- tribble(
  ~year, ~month, ~day, ~holiday,
  2013, 01, 01, "New Years Day"
)
```

#### Ключи

Ключи бывают двух видов:

* Первичный ключ идентифицирует наблюдение в собственной таблице. Например `planes$tailnum` однозначно идентифицирует каждый самолет в таблице `planes`

* Внешний ключ однозначно идентифицирует наблюдение в другой таблице. Наприме, `flights$tailnum` --- внешний ключ, поскольку он появляется в таблице `flights`, в которой он устанавливает для каждого авиарейса однозначно определяемый самолёт.

Переменная может одновременно служить первичным и внешним ключом. Например переменная `origin` является частью первичного ключа для таблицы `weather` и одновременно внешним ключом для таблицы `airports`

Чтобы убедится в том, что переменная которую мы определили как внешний ключ, действительно является таковой, можно проверить следующим способом:

```{r}
planes %>%
  count(tailnum) %>%
  filter(n > 1)
```

Так как первичный ключ устанавливает однозначной соответствие, то количество раз которое встречается эта переменная должно быть строго не больше одного раза.

Бывает, что таблица не имеет явного первичного ключа: каждая строка является наблюдением, но ниодна комбинация не обеспечивает её надежную идентификацию.

Например, что является первичным ключом во `flights`? Комбинация даты и номера вылета? Это было бы так, если бы в день самолёт совершал один полёт, но это не так:

```{r}
flights %>%
  count(year, month, day, flight) %>%
  filter(n > 1)
```

Если в таблице отсутствует первичный ключ, иногда его бывает удобно добавить с помощью функций `mutate()` и `row_number()`. Такой улюч называют суррогатным.

#### Упражнение 13.3.1.1
<div class="question">
Add a surrogate key to `flights`.
</div>

Однозначно описать строку может её порядковый номер:

```{r}
flights %>% 
  mutate(id = row_number())
```

Ещё лучше сначала упорядочить текущий набор данных и только затем присваивать идентификационный номер:

```{r}
flights %>%
  arrange(year, month, day, sched_dep_time, carrier, flight) %>%
  mutate(flight_id = row_number())
```

#### Упражнение 13.3.1.2
<div class="question">
Identify the keys in the following datasets

1. `Lahman::Batting`

1. `babynames::babynames`

1. `nasaweather::atmos`

1. `fueleconomy::vehicles`

1. `ggplot2::diamonds`

(You might need to install some packages and read some documentation.)
</div>

1. Для меня совершенно не очевидный ответ, к которому я пришёл интуитивно:

```{r}
Lahman::Batting %>%
  count(playerID, yearID, stint) %>%
  filter(n > 1)
```

Таким образом, первичным ключом в этих данных будет связка параметров `playerID`, `yearID`, `stint`.
Эти данные --- статистика по игре в бейсбол. Первые два параметра это как не трудно догадаться ID игрока, и года в котором он играл. Сначала я проверил на однозначность описания совокупность этих двух параметров. Но так как в течении года у игрока может изменяться положение/роль (параметр `stint`), то первичным ключом будет комбинация трёх параметров.

Больше информации по этим данным содержится в оригинальном наборе данных <http://www.seanlahman.com/files/database/readme2012.txt>

1. Для работы с эим набором данных необходимо скачать пакет `babynames`. В этом наборе данных содержится информация о количестве имён используемых в каждом году и их популярность.

```{r}
# install.packages("babynames")
library(babynames)

babynames::babynames %>%
  count(year, sex, name) %>%
  filter(nn > 1) # Обрати мнимание, что в исходном наборе данных уже есть параметр n, поэтому для подсчёта количества вхождений используеться переменная nn
```

Первичным ключом будет комбинация из трёх параметров --- имя, пол (потому что есть бисексуальные имена) и год в котором было использовано это имя.

Больше информации по этому набору данных <https://github.com/hadley/babynames>

1. Для работы с этим набором данных необходимо установить пакет `nasaweather`. Данные представляют собой географические и атмосферные измерения на очень грубой сетке 24 на 24, охватывающей Центральную Америку. Переменными являются: высота, температура (поверхность и воздух), озон, давление воздуха и облачный покров (низкий, средний и высокий). За исключением повышения, все переменные являются среднемесячными с наблюдениями за январь 1995 года по декабрь 2000 года. Эти данные были получены из Центра данных атмосферных наук NASA Langley Research Center

```{r}
# install.packages("nasaweather")
library(nasaweather)
```

Таким образом, первичным ключом будет комбинация параметров --- ширина-долгота для идентификации местоположения, и месяц-год для идентификации события во времени. Другими словами:

```{r}
nasaweather::atmos %>%
  count(lat, long, year, month) %>%
  filter(n > 1)
```

Больше информации по этим данным содержится в оригинальном наборе данных <http://stat-computing.org/dataexpo/2006/>

1. Для работы с этим набором данных необходимо установить пакет `fueleconomy`. Данные об экономии топлива являются результатом испытаний транспортных средств, проведенных в Национальной лаборатории Агентства по охране окружающей среды и выбросов топлива в Анн-Арборе, штат Мичиган, в 1985-2015. А также производителями транспортных средств под надзором EPA. Данные об экономии топлива из EPA, 1985-2015. Этот набор данных содержит выбранные переменные и удаляет транспортные средства с неполными данными (например, без данных трансмиссии)

```{r}
# install.packages("fueleconomy")
library(fueleconomy)

fueleconomy::vehicles %>%
  count(id) %>%
  filter(n > 1)
```

В изначальном наборе данных введён первичный ключ --- переменная `id`.

Больше информации по этим данным содержится в оригинальном наборе данных <https://www.fueleconomy.gov/feg/download.shtml>

1. В наборе данных `ggplot2::diamonds`  изначально нет первичного ключа. Его нельзя задать комбинацией параметров, потому что теоретически в природе может существовать два идентичных бриллианта как по размерам и физико-химическим свойствам, так и по цене, запращиваемой за эти бриллианты. Таким образом, для определения первичного ключа, нужно вводить новую переменную (суррогатный первичный ключ).

#### Упражнение 13.3.1.3
<div class="question">
Draw a diagram illustrating the connections between the `Batting`, `Master`, and `Salaries` tables in the `Lahman` package. Draw another diagram that shows the relationship between `Master`, `Managers`, `AwardsManagers`.

How would you characterise the relationship between the `Batting`, `Pitching`, and `Fielding` tables?
</div>

Чтобы фиксировать взаимоотношения данных в таблицах можно использовать множество разных ресурсов. Вероятно на специализированных ресурсах отношения и стрелочки будут выглядеть лучше, но мне помнравилась идея отображать отношения в той рабочей среде в которой проводится анализ.

Для этого необходимо установить два пакета:

```{r}
install.packages("datamodelr")
install.packages("DiagrammeR")
```

Второй пакет необходим для отображения работы первого.

Подробно работа с пакетом описана в репозитории разработчика <https://github.com/bergant/datamodelr#model-diagram-of-interconnected-data-frames>

Общий подход такой --- для начала определяем первичные ключи:

-   `Master`

    -   Первичный: `playerID`

-   `Batting`

    -   Первичный: `playerID`, `yearID`, `stint`

    -   Внешний:

        -   `playerID` = `Master$playerID` (many-to-1)

-   `Salaries`

    -   Primary keys: `yearID`, `teamID`, `playerID`

    -   Foreign Keys

        -   `playerID` = `Master$playerID` (many-to-1)

После этого задаём их связи `Batting$playerID == Master$playerID`, `Salaries$playerID == Master$playerID`

И на третьем шаге можно строить отношения:
    
```{r}
dm1 <- dm_from_data_frames(list(Batting = Lahman::Batting,
                                Master = Lahman::Master,
                                Salaries = Lahman::Salaries)) %>%
  dm_set_key("Batting", c("playerID", "yearID", "stint")) %>%
  dm_set_key("Master", "playerID") %>%
  dm_set_key("Salaries", c("yearID", "teamID", "playerID")) %>%
  dm_add_references(
    Batting$playerID == Master$playerID,
    Salaries$playerID == Master$playerID
  )

dm_create_graph(dm1, rankdir = "LR", columnArrows = TRUE)
```

Теперь проделаем эту же процедуру для `Master`, `Managers`, `AwardsManagers`


-   `Master`

    -   Первичный: `playerID`

-   `Managers`

    -   Первичный: `yearID`, `teamID`, `inseason`

    -   Внешний:

        -   `playerID` = `Master$playerID` (many-to-1)

-   `AwardsManagers`:

    -   Первичный: `playerID`, `awardID`, `yearID`
    
    -   Внешний:
    
        -   `playerID` = `Master$playerID` (many-to-1)
    
```{r}
dm2 <- dm_from_data_frames(list(Managers = Lahman::Managers,
                                Master = Lahman::Master,
                                AwardsManagers = Lahman::AwardsManagers)) %>%
  dm_set_key("Managers", c("teamID", "yearID", "inseason")) %>%
  dm_set_key("Master", "playerID") %>%
  dm_set_key("AwardsManagers", c("yearID", "awardID", "playerID")) %>%
  dm_add_references(
    AwardsManagers$playerID == Master$playerID,
    Managers$playerID == Master$playerID
  )

dm_create_graph(dm2, rankdir = "LR", columnArrows = TRUE)
```


Таблицы `Batting`, `Pitching` и `Fielding` имеют первичный ключ, состоящий из переменных `playerID`, `yearID` и `stint`. Все они имеют отношения 1-1 друг к другу, потому что `Batting`, `Pitching` и `Fielding` это названия игровых позиций.


### Мутирующие соединения 

Мутирующее соединение позволяет объединять переменные из двух таблиц. Сначала оно находит соответсвующие наблюдения по их ключам, а затем копирует переменные из одной таблицы в другую. 

Мутирующие соединения добавляют столбцы в правый конец таблицы.

Чтобы было проще понять происходящее с данными, возьмём тренировочный набор данных.

```{r}
(flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier))
```

Предположим, мы хотим соединить два фрейма данных `flights2` и `airlines`. Напомню, что последний фрейм это:

```{r}
airlines
```

Фреймы можно соединить при помощи `left_join()`

```{r}
flights2 %>%
  select(-origin, -dest) %>%
  left_join(airlines, by = "carrier")
```

#### Что представляют собой соединения

Проще всего понять как работает соединение продемонстрировать это графически. Введём две переменные для демонстрации:

```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

Их объединение будет происходить по ключу. Количество точек на диаграмме = количеству совпадений = количеству строк в результате
![alt text](img/join-inner.png)

#### Внутреннее соединение

Это простейший тип соединения, которое устанавливает соответствие между парами наблюдений, если их ключи совпадают. Собственно оно и было указано в демонстрации выше

![alt text](img/join-inner.png)

Строго говоря, этот тип соединения является **внутренним соединением по эквивалентности**, так как для сопоставления ключей используется оператор равенства. Поскольку большинство ключей относится к этому типу, мы будем опускать это уточнение. 

Результатом внутреннего соединения является новый фрейм данных, котороый содержит ключе, значения `x` и значения `y`. Для того чтобы сообщить пакету `dplyr` какая переменная является ключом, мы используем параметр `by`

```{r}
x %>%
  inner_join(y, by = "key")
```

Самым важным свойством внутреннего соединения является тот факт, что несовпадающие значения не включаются в новый фрейм данных. Это означает, что обычное внутреннее соединение, как правило нельзя использовать в анализе, так как можно очень легко потерять наблюдения.

#### Внешние соединения

Внутреннее соединение сохраняет наблюдения которые встречаются в обеих таблицах (логическое И)

Внешнее соединение сохраняет наблюдения встречающиеся хотя бы в одной из таблиц. Различают три вида внешних соединений:

* левое соединение, сохраняет все наблюдения в `x`

* правое соединение, сохраняет все наблюдения в `y`

* полное соединение, сохраняет все наблюдения в `x` и `y`

Эти соединения работают, добавляя дополнительное "виртуальное" наблюдение в каждую таблицу. Данное наблюдение имеет ключ, который совпадает с любым ключом (если никакой другой ключе не совпадает), и значение `NA`

![alt text](img/join-outer.png)
Так как левое соединение оставляет исходную выборку нетронутой, то этот тип соединения используется практически по умолчанию всегда.

Для графического изображения различных типов соединений используется диаграмма Венна

![alt text](img/join-venn.png)

Однако она обладает одним существенным недостатком --- она не сообщает что делать в тех случаях, когда ключи не обечспечивают однозначную идентификацию.

#### Неуникальные ключи

Есть две ситуации неуникальных ключей

* Неуникальные ключи есть в одной таблице. Это модет быть полезно, если необходимо добавить информацию в тех случаях, когда имеется типичное отношение "один ко многим". 

![alt text](img/join-one-to-many.png)

* Неуникальные ключи есть в обеих таблицах. При соединении таких таблиц получаются все возможные соединения

![alt text](img/join-many-to-many.png)

#### Определение ключевых столбцов

До сих пор соединение происходило только по одной переменной, задаваемой параметром `by = "key"`. Есть другие способы:

* Заданному по умолчанию значению `by = NULL` соответствует использование всех переменных, встречающихся в обеих таблицах. Это естественное соединение. Например таблицы `flights` и `weather` согласуются по общим переменным: `year`, `month`, `day`, `hour` и `origin`.

```{r}
flights2 %>%
  left_join(weather)
```

* Символьный вектор, `by = "x"`. Можно соединять не по ключу, а по любой общей переменной. НАпример, переменная `year` содержится в обеих таблицах, `flights` и `planes`, но имеет в них разный смысл, и потому для соединения таблиц мы используем только переменную `tailnum`

```{r}
flights2 %>%
  left_join(planes, by = "tailnum")
```

Неоднозначность переменных устранена при помощи суффиксов `year.x` и `year.y`


* Именованный символьный вектор `by = c("a" = "b")`. Соединения этого типа сопоставляют переменную `a` в таблице `x` с перменной `b` в таблице `y`. В результате будут использованы перменные их `x`.

Это сильный инструмент --- этакий аналог этой функции в Excell это `ВПР()`. Но только по заданному ключу здесь, функция проводит поиск, устанавливает соответствие по всем доступным столбцам в таблице `y`. 

Например, если мы хоти нарисовать карту, необходимо соединить данные таблицы `flights` с данными таблицы `airports`, которая содержит широту и долготу каждого аэропорта. Каждый авиарейс характеризуется аэропортом вылета и аэропортом назначения, поэтому мы должны конкретизировать, какой из вариантов соединения нам необходим.

```{r}
flights2 %>%
  left_join(airports, c("dest" = "faa"))
```

```{r}
flights2 %>%
  left_join(airports, c("origin" = "faa"))
```

#### Упражнение 13.4.6.1

<div class="question">
Compute the average delay by destination, then join on the airports data frame so you can show the spatial distribution of delays. Here’s an easy way to draw a map of the United States:
</div>


```{r}
airports %>%
  semi_join(flights, c("faa" = "dest")) %>%
  ggplot(aes(lon, lat)) +
    borders("state") +
    geom_point() +
    coord_quickmap()
```

Вычислим для начала среднее время задержки по пунктам назначения. Для этого необходимо сгруппировать по направлению вылета `group_by(dest)`. Затем вычислить среднее значение задержки `delay = mean(arr_delay, na.rm = TRUE)`. И наконец просуммировать по группе --- summarise()

```{r}
flights %>%
  group_by(dest) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE))
```

Теперь выполним задачу по соединению для фрейма данных `airports`

```{r}
avg_dest <- flights %>%
  group_by(dest) %>%
  summarise(delay = mean(arr_delay, na.rm = TRUE)) %>%
  inner_join(airports, by = c(dest = "faa"))
```

Теперь нанесём значения времени задержки на карту

```{r}
avg_dest %>%
  ggplot(aes(lon, lat, color = delay)) +
    borders("state") +
    geom_point() +
    coord_quickmap()
```

#### Упражнение 13.4.6.2

<div class="question">
Add the location of the origin and destination (i.e. the `lat` and `lon`) to `flights`.
</div>

Чтобы не плодить сущностей, т.е. параметров сверх необходимых, мы изначально ограничим исходные наборы данных, требуемыми параметрами. В таблице аэропортов останется всего три параметра ключ `faa` и координата долготы и широты

```{r}
airports_locations <- airports %>%
  select(faa, lat, lon)
```

И далее в наборе данных с полётам возьмём только необходимые параметры даты вылета и направлений. Только после этого присоединим данные при помощи именнованного символьного вектора

```{r}
flights %>%
    select(year:day, hour, origin, dest) %>%
    inner_join(airports_locations, by = c(origin = "faa")) %>%
    inner_join(airports_locations, by = c(dest = "faa"))
```

В очередной раз спасибо [Jeffrey Arnold](https://github.com/jrnold) за отличный совет: всегда давать понятные названия переменным, а главное за подсказку способа реализации --- добавление параметра `suffix`

```{r}
flights %>%
    select(year:day, hour, origin, dest) %>%
    inner_join(airports_locations, by = c(origin = "faa")) %>%
    inner_join(airports_locations, by = c(dest = "faa"), suffix = c("_origin", "_dest"))
```



