---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Создание модели
### Введение

В прошлой главе были искусственные данные, сейчас поработаем на реальных.

Порядок будет такой --- мы будем обнаруживать тенденции посредством визуализации, а затем конкретизировать и уточнять из с помощью модели.
Затем мы повторим процесс, но заменим старую пременную отклика остатками, опеределённой модели.

Нашей целью является переход от неявных знаний, содержащихся в данных и наших головах, к явным знаниям, содержащимся в количественной модели. Это облешчит их применение в новых областях и использование другими людьми.

Нужно уметь вовремя остановится

Давным-давно на уроке рисования мой учитель сказал мне: «Художник должен знать, когда произведение готово. Вы не можете что-то настроить в совершенстве - заверните это. Если вам это не нравится, сделайте это снова. В противном случае начните что-то новое ». Позже я услышал: «Бедная швея делает много ошибок. Хорошая швея усердно работает над исправлением этих ошибок. Великая швея не боится выбросить одежду и начать все сначала ».

<https://www.reddit.com/r/datascience/comments/4irajq>

#### Необходимые ресурсы

```{r}
library(tidyverse)
library(modelr)
options(na.action = na.warn)

library(nycflights13)
library(lubridate)
```

### Почему бриллианты низкого качества оказались более дорогими

В предыдущих главах мы наблюдали необычное соотношение между качеством бриллиантов и их ценой.
Бриллианты низкого качества, плохая огранка, неудачный цвет, и худшая чистота стоят дороже

```{r}
ggplot(diamonds, aes(cut, price)) + geom_boxplot()
ggplot(diamonds, aes(color, price)) + geom_boxplot()
ggplot(diamonds, aes(clarity, price)) + geom_boxplot()
```

Худший цвет бриллианта --- J
Худший класс чистоты --- I1


#### Цена и вес

Похоже, цена низкокачественных бриллиантов оказалась выше из-за одной важной переменной --- `carat` (вес в каратах).
Вес бриллианта --- единственно важный фактор, для определения его цены. А низкокачественные бриллианты имеют как правило большие размеры

```{r}
ggplot(diamonds, aes(carat, price)) + 
  geom_hex(bins = 50)
```

Нам будет проще увидеть, как другие атрибуты бриллианта влияют на его относительную цену, если мы построим модель, отделяющую эффект прпеменной карат. Но сначала немного подправим набор данных, чтобы с ним легче было работать

1. Сфокусируемся на бриллиантах весом меньше 2.5 карата (99,7 данных)

2. Перейдём к логарифмам переменных карат и прайс

```{r}
diamonds2 <- diamonds %>% 
  filter(carat <= 2.5) %>% 
  mutate(lprice = log2(price), lcarat = log2(carat))
```

Совместное внесение этих изменений упрощает выявление взаимосвязи переменных карат и прайс

```{r}
ggplot(diamonds2, aes(lcarat, lprice)) + 
  geom_hex(bins = 50)
```

В данном случае логарифмическое преобразование особенно удобно, посколько оно линеаризует шаблон, а с линейными шаблонами легче работать.

Сделем еще один шаг и исключим эту ярко выраженную линейную тенденцию. Сначала мы явно создаём шаблон путём построения модели

```{r}
mod_diamond <- lm(lprice ~ lcarat, data = diamonds2)
```

Затем мы смотрим что говорит о данных эта модель. Мы выполняем обратное преобразование предсказаний отменяя логарифмическое преобразование, чтобы предсказания можно было наложить на исходные данные

```{r}
grid <- diamonds2 %>% 
  data_grid(carat = seq_range(carat, 20)) %>% 
  mutate(lcarat = log2(carat)) %>% 
  add_predictions(mod_diamond, "lprice") %>% 
  mutate(price = 2 ^ lprice)

ggplot(diamonds2, aes(carat, price)) + 
  geom_hex(bins = 50) + 
  geom_line(data = grid, colour = "red", size = 1)
```

В результате получаем интересную информацию о данных. Если мы долверяем нашей модели, то большие бриллианты намного дешевле, мем можно было ожидать. Вероятно это объясняется тем, что ни один бриллиант в данном наборе не стоит более 19000 долларов.

Рассмотрение остатков подтверждает, что мы успешно исключили ярковыраженный линейный шаблон. На графике сплошное облако шума.

```{r}
diamonds2 <- diamonds2 %>% 
  add_residuals(mod_diamond, "lresid")

ggplot(diamonds2, aes(lcarat, lresid)) + 
  geom_hex(bins = 50)
```

Важно что теперь мы можем заново построить наши мотивирующие графики используя остатки, вместо переменной прайс

```{r}
ggplot(diamonds2, aes(cut, lresid)) + geom_boxplot()
ggplot(diamonds2, aes(color, lresid)) + geom_boxplot()
ggplot(diamonds2, aes(clarity, lresid)) + geom_boxplot()
```

Теперь мы видим ожидаемую взаимосвязь --- по мере улучшения качества бриллиантов растёт их относительная цена.
 Для интерпретации оси игрее необходимо подумать о том, о чем на говорят остатки и по какой шкале они измеряются.
 
 Остаток -1 указывает на то, что переменная `lprice`была на единицу ниже предсказанного значения, если основываться на его весе. $2^{-1}$ равно $\frac{1}{2}$ поэтому точка со значением -1 соответствует половине ожидаемой цены. А остатки со значением 1 соответствуют двойной предсказанной цене.
 
### Более сложная модель

При желании можно достраивть модель, усложняя её имеющимися параметрами

```{r}
mod_diamond2 <- lm(lprice ~ lcarat + color + cut + clarity, data = diamonds2)
```

Теперь модель включает 4 предиктора и её труднее визуализировать. К счастью, к настоящему моменту все они независимы, а это означает что мы можем отобразить их по отдельности на 3 графиках.

```{r}
grid <- diamonds2 %>% 
  data_grid(cut, .model = mod_diamond2) %>% 
  add_predictions(mod_diamond2)
grid

ggplot(grid, aes(cut, pred)) + 
  geom_point()
```

Если модель нуждается в переменных, которые вы не продоставили ей явно, функция `data_grid()` автоматически заполнит их типичными значениям. Для непрерывных переенных она использует медиану, а для категориальных --- моду. 

```{r}
diamonds2 <- diamonds2 %>% 
  add_residuals(mod_diamond2, "lresid2")

ggplot(diamonds2, aes(lcarat, lresid2)) + 
  geom_hex(bins = 50)
```

Этот график указывает на то, что имеюбтся бриллианты с довольно большими остатками --- вспомните о том, что остаток 2 означет 4-кратное превышение цены по сравнению с ожидаемой. Часто целесообразно рассматривать необчные значения по отдельности

```{r}
diamonds2 %>% 
  filter(abs(lresid2) > 1) %>% 
  add_predictions(mod_diamond2) %>% 
  mutate(pred = round(2 ^ pred)) %>% 
  select(price, pred, carat:table, x:z) %>% 
  arrange(price)
```

В данном случае мы не находим ничего необычного, но вероятно стоило потратить какое-то время на выяснение того, не указывает ли это на возможноые проблемы с нашей моделью или на наличие ошибок в данных. В случае существования ошибок в данных это могло бы обернуться счастливыой возможностью купить бриллианты по неоправданно заниженной цене. Сила в данных

#### Упражнение 24.2.3.1
<div class="question">
In the plot of `lcarat` vs. `lprice`, there are some bright vertical strips. What do they represent?
</div>


```{r}
ggplot(diamonds2, aes(lcarat, lprice)) + 
  geom_point()
```

Распределение алмазов имеет больше алмазов в круглых или дружественных для человека числах (дроби).


#### Упражнение 24.2.3.2
<div class="question">
If `log(price) = a_0 + a_1 * log(carat)`, what does that say about the relationship between price and carat?
</div>

Переведём исходное выражение в привычную математическую запись. Цену `price` я запишу как $y$, а караты `carat` как $x$

$$\log_b y = a_0 + a_1\log_b x$$

Сравним между собой отношение двух исходных выражений. Мы хотим понять, как изменяется отношение $y$ при изменении $x$. 

$$\log_b y_1 = a_0 + a_1\log_b x_1$$
$$\log_b y_2 = a_0 + a_1\log_b x_2$$
$$\log_b (y_2) - \log_b (y_1) = (a_0 + a_1\log_b x_2) - (a_0 + a_1\log_b x_1)$$
$$\log_b(\frac{y_2}{y_1}) = \log_b(\frac{x_2}{x_1})^{a_1}$$

$$\frac{y_2}{y_1} = (\frac{x_2}{x_1})^{a_1}$$

Собственно это и будет решением.

#### Упражнение 24.2.3.3
<div class="question">
Extract the diamonds that have very high and very low residuals. Is there anything unusual about these diamonds? Are the particularly bad or good, or do you think these are pricing errors?
</div>

Я буду искать подозрительные остатки, по предложенному Тьюки способу —-- буду считать выбросом, значение отклоняющиеся от квартилей на полтора размаха. 

```{r}
left <- diamonds2 %>% 
  filter(lresid2 <= quantile(lresid2,0.25) - 1.5*(quantile(lresid2,0.75) - quantile(lresid2,0.25)))

right <- diamonds2 %>% 
  filter(lresid2 >= quantile(lresid2,0.75) + 1.5*(quantile(lresid2,0.75) - quantile(lresid2,0.25)))

outliers_lresid2 <- rbind(left, right)
```

Теперь давайте визуализируем ч


```{r}
diamonds2 %>%
  ggplot(aes(cut, lresid2)) +
  geom_boxplot()
```

Вроде бы ничего подозрительного нет. 
Выбросы равномерно распределены, относительно качества огранки.
Наблюдается некая тенденция, что большая часть выбросов лижит в пределах от -1 до 1

Но давайте взглянем на остатки поближе.


```{r}
outliers_lresid2 %>%
  ggplot(aes(lresid2, color = cut)) +
  geom_freqpoly(binwidth = 0.1) + 
  facet_grid(cut~.)

outliers_lresid2 %>%
  ggplot(aes(lresid2, color = color)) +
  geom_freqpoly(binwidth = 0.1) + 
  facet_grid(color~.)

outliers_lresid2 %>%
  ggplot(aes(lresid2, color = clarity)) +
  geom_freqpoly(binwidth = 0.1) + 
  facet_grid(clarity~.)
```

Основная масса выбросов приходится на значения плюс-минус 0.5.
Практически в одинаковой мере попадаются плохие и хорошие. 
Заметно чаще эти ошибки встречаются в более дорогих алмазах.
Можно предположить, что цена искусственно завышена-занижена.

#### Упражнение 24.2.3.4
<div class="question">
Does the final model, `mod_diamond2`, do a good job of predicting diamond prices? 
Would you trust it to tell you how much to spend if you were buying a diamond?
</div>

```{r}
summary(mod_diamond2)
```

Adjusted R-squared имеет значение 0.9828.
Это очень хороший результат. Возьмём теперь предсказанные значение логарифма цены.

```{r}
diamonds2$predict <- predict(object = mod_diamond2)
```

Сравним предсказания, с реальной ценой. Я введу новую переменную, которая показывает во сколько раз предсказание отличается от реальной цены

```{r}
diamonds2 <- diamonds2 %>% 
  mutate(result = 1 - (predict / lprice))

diamonds2 %>% 
  ggplot(aes(cut, result)) +
  geom_boxplot()

mean(abs(diamonds2$result))
max(abs(diamonds2$result))
```

То есть средняя ошибка модели это 1%.
Я бы доверился такой модели перед покупкой
